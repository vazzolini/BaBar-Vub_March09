#include <ext/numeric>

#include "TStopwatch.h"

#include "RooFitCore/RooDataHist.hh"
#include "RooFitCore/RooHist.hh"

#include "RooFitCore/RooChi2Var.hh"
#include "RooFitCore/RooMinuit.hh"
#include "RooFitCore/RooFitResult.hh"
#include "RooFitCore/RooNLLVar.hh"
#include "RooFitCore/RooBinning.hh"

#include "RooFitCore/RooAbsPdf.hh"
#include "RooFitCore/RooAddPdf.hh"
#include "RooFitCore/RooExtendPdf.hh"

#include "RooFitModels/RooCBShape.hh"
#include "RooFitModels/RooArgusBG.hh"
#include "RooFitModels/RooGaussian.hh"
#include "RooFitModels/RooBifurGauss.hh"

#include "VirVubFitter/RooSumArgusBG.hh"
#include "VirVubFitter/RooCCB.hh"
#include "VirVubFitter/RooSumCCB.hh"
#include "VirVubFitter/RooThorstenSig.hh"

#include "RooFitCore/RooFormulaVar.hh"

#include "TKey.h"
#include "TDecompChol.h"
#include "TMatrixD.h"
#include "TVectorD.h"
#include "TMatrixDUtils.h"

//! helper access method used by vubMesUnb
RooRealVar* getPointer(RooAbsPdf* pdf, const char* name)
{
  RooArgSet* list = pdf->getParameters(RooArgSet());
  RooRealVar* var = dynamic_cast<RooRealVar*>(list->find(name));
  delete list;

  return var;
}

//! helper access method used by vubMesUnb
Double_t getVal(RooAbsPdf* pdf, const char* name)
{
  RooRealVar* var = getPointer(pdf, name);
  return (var != 0 ? var->getVal() : 0.);
}

//! helper access method used by vubMesUnb
Double_t getError(RooAbsPdf* pdf, const char* name)
{
  RooRealVar* var = getPointer(pdf, name);
  return (var != 0 ? var->getError() : 0.);
}

// Displays the mes histogram, fits  argus+gaus and prints some numbers
mesData* VirClass::vubMesUnb(RooDataSet *data, RooRealVar *x, std::vector<double>& results, int print, int fixpar, const std::vector<double>& inputPar, const double nSIG, const double nBKG, const char *simply, bool fixsigtopeakratio, int jmatch)
{
  static bool firstCall = true;

  //bool countMC = true;

  /* --- prepare the dataset --- */

  // maximum of mes
  double mesMax( (data==datadata) ? 5.291 : 5.2891 );
  mesMax = 5.291; //Kerstin  

  // do magic with NOTUNBINNED to get right bin size (given as width in keV)
  //  int nBins = 40; //Kerstin
  int nBins = int((mesMax-5.22)/0.0005);
  if (NOTUNBINNED == 2) nBins = int((mesMax-5.22)/0.0005);
  if (NOTUNBINNED == 3) nBins = int((mesMax-5.22)/0.0005);
  if (NOTUNBINNED == 4) nBins = int((mesMax-5.22)/0.0005);
  if (NOTUNBINNED == 5) nBins = int((mesMax-5.22)/0.0005);
  if (NOTUNBINNED == 6) nBins = int((mesMax-5.22)/0.0005);
  if (NOTUNBINNED == 7) nBins = int((mesMax-5.22)/0.0005);
  if (NOTUNBINNED == 8) nBins = int((mesMax-5.22)/0.0005);
  if (NOTUNBINNED == 9) nBins = int((mesMax-5.22)/0.0005);
  if (TMath::Abs(NOTUNBINNED) > 10) nBins = int((mesMax-5.22)/0.0005);

  //Mes in a reduced range for yielding
  RooRealVar* mes(x);
  mes->setBins(nBins);
  mes->setMin(5.22); mes->setMax(mesMax);
  
  if(FITALLMESRANGE){
    cout << "---> Getting Yields for WHOLE mES RANGE! [5.22," << mesMax << "]" << endl;
    mes->setRange("mesint", 5.22, mesMax);
  } else {
    cout << "---> Getting Yields for REDUCED mES Range! [5.27," << mesMax << "]" << endl;
    mes->setRange("mesint", 5.27, mesMax);
  }
  
  // RooFit remembers old ranges
  std::cout << "Binning is " << mes->getBins() << " for range [" << mes->getMin() << ";" << mes->getMax() << "]" << std::endl;
  
  if (countMC && jmatch ==2) {
    
    //CB count truth-matched events
    char reduced[100];
    if(FITALLMESRANGE)
      sprintf(reduced,"%s%s",simply,"&& (trumtch == 2)");
    else
      sprintf(reduced,"%s%s",simply,"&& (trumtch == 2) && mes > 5.27");
    
    std::cout << "Applying truth-matching criteria: Selection cut is actually " << reduced << std::endl;

    RooAbsData* datadispl = data->reduce(reduced);
    std::cout << "Number of entries in reduced " << data->GetName() << " dataset with truth-matched events: " 
	      << datadispl->numEntries() << " weighted: " << datadispl->numEntries(kTRUE) << std::endl;
    std::cout << "" << std::endl;
    
    //  sprintf(reduced,"%s%s",simply,"&& (trumtch == 2) && mes>5.27");
    //  sprintf(reduced,"%s%s",simply,"&& (trumtch == 2)"); 

    RooAbsData* dataredd = data->reduce(reduced);
    std::cout << "Number of entries in reduced " << data->GetName() << " dataset above "
	      << (FITALLMESRANGE ? "5.22 GeV: " : "5.27 GeV: ")
	      << dataredd->numEntries() << " weighted: " << dataredd->numEntries(kTRUE) << std::endl;
    std::cout << "" << std::endl;
    std::cout << "mES fit: returning the number of entries in dataset" << std::endl;
    
    float tmpx = dataredd->numEntries(kTRUE);
    float tmpy = sqrt(tmpx);

    // make plot
    xframec = mes->frame() ;
    xframec->SetTitle((data->GetTitle()+std::string(" ")+reduced).c_str());
    
    // plot data on it
    RooBinning tbins(mes->getBins(), mes->getMin(), mes->getMax(), "plotbinning");
    datadispl->plotOn(xframec, RooFit::Binning(tbins), RooFit::MarkerSize(0.10), RooFit::DataError(RooAbsData::SumW2));

    //print number of events
    //    if(tbox1 != NULL) {delete tbox1; tbox1 = 0;}
    TPaveText* tboxc = new TPaveText(0.1, 0.75, 0.6, 0.85, "BRNDC");
    char linec[50];
    //  sprintf(linec,"Events m_{ES}>5.27: %6.0f #pm %6.0f",tmpx,tmpy);
    sprintf(linec,"Events m_{ES}>%3.2f: %6.0f #pm %6.0f",(FITALLMESRANGE ? 5.22 : 5.27),tmpx,tmpy);
    tboxc->AddText(linec);
    xframec->addObject(tboxc);
    xframec->Draw();

    mesData *pD = new mesData(dataredd->GetName(),tmpx,tmpy,0,0,0,0);

    //    mesData *pD = new mesData(datared->GetName(),datared->numEntries(kTRUE),sqrt(float(datared->numEntries(kTRUE))),0,0,0,0);
    
    //ANTONIO 1 mar 2007: delete all reduced dataset
    delete dataredd;
    delete datadispl;
    return pD; 
  }

  // generate reduced dataset
  std::cout << "Simply = " << simply << std::endl;
  RooAbsData* datared = data->reduce(simply);
  std::cout << "Number of entries in reduced " << data->GetName() << " dataset: " 
	    << datared->numEntries() << " weighted: " << datared->numEntries(kTRUE) << std::endl;

  Double_t buddahs = datared->sumEntries((std::string(simply)+"&&mes>5.27").c_str());

  // create binned dataset to evaluate chisquare
  RooDataHist* bdatared = new RooDataHist(data->GetName(),data->GetTitle(), RooArgSet(*mes), *datared);
  
  // overwrite unbinned dataset if binned fit requested
  RooAbsData* dataset = datared;
  if (NOTUNBINNED == 1) dataset = bdatared;
  if (NOTUNBINNED == 2 && datared->numEntries() >  15000) dataset = bdatared;
  if (NOTUNBINNED == 3 && datared->numEntries() >  20000) dataset = bdatared;
  if (NOTUNBINNED == 4 && datared->numEntries() >  50000) dataset = bdatared;
  if (NOTUNBINNED == 5 && datared->numEntries() > 100000) dataset = bdatared;
  if (NOTUNBINNED == 6 && datared->numEntries() > 200000) dataset = bdatared;
  if (NOTUNBINNED == 7 && datared->numEntries() > 300000) dataset = bdatared;
  if (NOTUNBINNED == 8 && datared->numEntries() > 400000) dataset = bdatared;
  if (NOTUNBINNED == 9 && datared->numEntries() > 500000) dataset = bdatared;
  if (TMath::Abs(NOTUNBINNED) > 10) dataset = bdatared;

  std::cout << "This is a" << (dataset->IsA() == RooDataHist::Class() ? " " : "n un") << "binned fit!" << std::endl;

  /* --- prepare fit model --- */

  //Signal and Background events
  RooRealVar* nsig = new RooRealVar("S","number of sig events", 100., 0., 800000.);
  RooRealVar* nbpk = new RooRealVar("P","number of bpk events", 1., 0., 800000.);
  RooRealVar* nbkg = new RooRealVar("B","number of bkg events", 1., 0., 800000.);

  nsig->setMax(dataset->numEntries(kTRUE));
  nbpk->setMax(dataset->numEntries(kTRUE));
  nbkg->setMax(dataset->numEntries(kTRUE));

  //Formula to fix signal to peaking bkg ratio
  RooFormulaVar *newbpk;
  RooRealVar *rat;

  // final model pdf
  RooAbsPdf* model = 0;
  RooExtendPdf *sigpointer,*arguspointer,*ccbpointer(NULL);

  if (model == 0) { // build new models
    
    switch(MESFITMODEL) { 
    
    case GaussFit: { // GAUSSIAN FIT
      
      /* --- Build Argus background PDF --- */
      RooAbsPdf* a = createArgus(*mes);

      // Gaussian for signal component
      RooRealVar* Rm = new RooRealVar("mean","mean of gaussian 1",5.28,5.275,5.285);
      RooRealVar* Rs = new RooRealVar("sigma","width of gaussians",.003,.002,.004);

      RooGaussian* g = new RooGaussian("g", "Gaussian", *mes, *Rm, *Rs);

      /* --- build extended pdfs --- */

      //-----------------------ANTONIO 23-APR-2007
//       RooExtendPdf* ae = new RooExtendPdf("ae","ae", *a, *nbkg, "mesint");
//       RooExtendPdf* ge = new RooExtendPdf("ge","ge", *g, *nsig, "mesint");
      RooExtendPdf* ae = new RooExtendPdf("ae","ae", *a, *nbkg);
      RooExtendPdf* ge = new RooExtendPdf("ge","ge", *g, *nsig);
      //------------------------

      /* --- build final model --- */
      model = new RooAddPdf("gmodel","a+g",RooArgList(*ge,*ae),RooArgList(*nsig,*nbkg));
      sigpointer = ge; arguspointer = ae;
    } break;

    case ArgusAndCB: {//ARGUS AND CRYSTAL BALL MODEL

      /* --- Build Argus background PDF --- */
      RooAbsPdf* a = createArgus(*mes);
      
      /* --- Build Crystal Ball signal function --- */
      RooAbsPdf* cb = createCB(*mes);
      
      /* --- build extended pdfs --- */

      //-----------------------ANTONIO 23-APR-2007
//       RooExtendPdf* ae  = new RooExtendPdf("ae", "ae", *a, *nbkg, "mesint");
//       RooExtendPdf* cbe = new RooExtendPdf("cbe", "cbe", *cb, *nsig, "mesint");
      RooExtendPdf* ae  = new RooExtendPdf("ae", "ae", *a, *nbkg);
      RooExtendPdf* cbe = new RooExtendPdf("cbe", "cbe", *cb, *nsig);
      //------------------------
      
      /* --- build final model --- */
      model = new RooAddPdf("model","a+cb",RooArgList(*cbe,*ae),RooArgList(*nsig,*nbkg));
      
      sigpointer = cbe; arguspointer = ae;
    } break;
      
    case ArgusAndThosig: {//ARGUS And Thorsten Signal Function AKA Frankenstein
      
      /* --- Build Argus background PDF --- */
      RooAbsPdf* a = createArgus(*mes);

      /* --- Build Thorsten signal (AKA Frankenstein) PDF --- */
      RooAbsPdf* pSignal = createThorsten(*mes);

      /* --- build extended pdfs --- */
      //-----------------------ANTONIO 23-APR-2007
      // RooExtendPdf* ae  = new RooExtendPdf("ae", "ae", *a, *nbkg, "mesint");
      // RooExtendPdf* se = new RooExtendPdf("se","signal extended", *pSignal, *nsig, "mesint");
    
      RooExtendPdf* ae  = new RooExtendPdf("ae", "ae", *a, *nbkg);
      RooExtendPdf* se = new RooExtendPdf("se","signal extended", *pSignal, *nsig);
      //------------------------

      /* --- build final model --- */
      model = new RooAddPdf("model","a+tho",RooArgList(*se,*ae),RooArgList(*nsig,*nbkg));

      sigpointer = se; arguspointer = ae;
     
    } break;
      
    case ThreePDFs: {// 3 PDFs fit model

      
      /* --- Fixing the ratio peaking bkg/continuum bkg --- */
      if (fixsigtopeakratio){
	float rr=1./(*activecorrection);
	rat=new RooRealVar("ratio","ratio signal to peaking",rr);
	newbpk=new RooFormulaVar("ratiosigtopeak","@0*@1",RooArgList(*nsig,*rat));
	std::cout<<"DEBUGGONE signal= "<<nsig->getVal()<<" PEAKING ="<<newbpk->getVal()<<" ratio= "<<rat->getVal()<<std::endl;
      }
            
      /* --- Build Argus background PDF --- */
      RooAbsPdf* pArgus = createArgus(*mes, (EPOINTCOR && data==datadata));
      
      /* --- Build modified Crystal Ball peaking background PDF --- */
      RooAbsPdf* pCcb = createCCB(*mes, (EPOINTCOR && data==datadata));

      /* --- Build modified Gauz signal PDF --- */
      RooAbsPdf* pSignal = createThorsten(*mes);

      // build extended pdfs
      //-----------------------ANTONIO 23-APR-2007
      //      RooExtendPdf* ae = new RooExtendPdf("ae", "argus extended", *pArgus, *nbkg, "mesint");
      RooExtendPdf* ae = new RooExtendPdf("ae", "argus extended", *pArgus, *nbkg);
      //----------------------
      
      RooExtendPdf* ccbe;
      
      if(fixsigtopeakratio)
	//-----------------------ANTONIO 23-APR-2007
	//	ccbe = new RooExtendPdf("ccbe", "ccb extended", *pCcb, *newbpk, "mesint");
	ccbe = new RooExtendPdf("ccbe", "ccb extended", *pCcb, *newbpk);
      //----------------------
      else
	//-----------------------ANTONIO 23-APR-2007
	//	ccbe = new RooExtendPdf("ccbe", "ccb extended", *pCcb, *nbpk, "mesint");
	ccbe = new RooExtendPdf("ccbe", "ccb extended", *pCcb, *nbpk);
      //----------------------
      
      //-----------------------ANTONIO 23-APR-2007
      //      RooExtendPdf* se = new RooExtendPdf("se","signal extended", *pSignal, *nsig, "mesint");
      RooExtendPdf* se = new RooExtendPdf("se","signal extended", *pSignal, *nsig);
      //----------------------

      /* --- build final model --- */
      if(jmatch == 0){
	if(fixsigtopeakratio)
	  model = new RooAddPdf("model","a+ccb+s", RooArgList(*ae,*ccbe,*se),RooArgList(*nbkg,*newbpk,*nsig));
	else 
	  model = new RooAddPdf("model","a+ccb+s", RooArgList(*ae,*ccbe,*se),RooArgList(*nbkg,*nbpk,*nsig));
	std::cout << " ----- fit model is argus + ccb + signal function ---- " << std::endl;
      } else if (jmatch == 1){
	if(fixsigtopeakratio)
	  model = new RooAddPdf("model","a+ccb", RooArgList(*ae,*ccbe),RooArgList(*nbkg,*newbpk));
	else
	  model = new RooAddPdf("model","a+ccb", RooArgList(*ae,*ccbe),RooArgList(*nbkg,*nbpk));
	std::cout << " ----- fit model is argus + ccb  ---- " << std::endl;
      } else if (jmatch == 2){
	model = new RooAddPdf("model","s", RooArgList(*se),RooArgList(*nsig));
	std::cout << " ----- fit model is signal function ---- " << std::endl;
      } else {
	std::cout << "----> WARNING : not able to build a model for the current mES fit! " << std::endl; 
	std::cout << " ---> I am nevertheless going on. Keep fingers crossed... " << std::endl;
      }
      sigpointer = se; arguspointer = ae; ccbpointer = ccbe;
     } break;
    default:
      cout<<"VirClass::vubMesUnb(): W A R N I N G  No known mes fit model detected! This is an error!"<<endl;
      break;
    }
  } // if (model == 0)


  /* --- init parameters --- */
  /*  double nSignal = datared->sumEntries((std::string(simply)+"&&mes>5.27").c_str());

  if (nSIG > 0. && nSIG < nsig->getMax())  
    nsig->setVal(nSIG); 
  else {
    nsig->setVal(nSignal);
    if (MESFITMODEL == ThreePDFs) nsig->setVal(0.6*nSignal);
  }
  
  if (nBKG > 0. && nBKG < nbkg->getMax()) 
    nbkg->setVal(nBKG); 
  else {
    nbkg->setVal(datared->sumEntries((std::string(simply)+"&&mes<5.27").c_str())); 
    if (MESFITMODEL == ThreePDFs) nbkg->setVal(0.2*nSignal);
  }

  if (MESFITMODEL == ThreePDFs) 
    nbpk->setVal(nsig->getVal()/3.);
  */

  //CB AP 4/23/2007 make nsig and nbkg initialization values _independent_ of 
  // whatever we might ask when calling sighistounb
  // define nsig and nbkg starting points as 60% of the mES> 5.27 and all events <5.27
  // respectively. 

  nsig->setVal(0.6*datared->sumEntries((std::string(simply)+"&&mes>5.27").c_str()));
  nbkg->setVal(datared->sumEntries((std::string(simply)+"&&mes<5.27").c_str())); 

  cout << "========= vubMesUnb: processing dataset " << datared->GetName() << ", cuts " << simply 
       << ". Initialization values for nsig = " << nsig->getVal() 
       << "; nbkg = " << nbkg ->getVal() << endl; 

  if( TMath::Abs(nsig->getVal()) < 1. && TMath::Abs(nbkg->getVal()) < 1. ) {
    cout << "Skipping this mES fit as we have " << nsig->getVal() << " candidates signal events and " << nbkg->getVal() 
	 << " candidates background events. " << endl;
    mesIdx++;
    return new mesData(datared->GetName(),0,0,0,0,0,0);
  }

  //   ------> HORRIBLE IMPLEMENTATION ONWARD: an holder class would be more elegant  //
  
  /* ========= Set Parameter for Argud and Gauss Model  ============ */

  if (MESFITMODEL == GaussFit) {

    // get hook to parameters
    RooRealVar* ar     = getPointer(model, "ar");
    RooRealVar* cutoff = getPointer(model, "cutoff");

    // get hook to parameters
    RooRealVar* Rm     = getPointer(model, "mean");
    RooRealVar* Rs     = getPointer(model, "sigma");

    cutoff->setVal(5.29); cutoff->setConstant();

    // preset parameters and fix some if requested by flag func
    if (fixpar == 0) { // preset parameters only
      Rm->setVal(inputPar[VirClass::iMean]); 
      Rs->setVal(inputPar[VirClass::iSigma]);
      ar->setVal(inputPar[VirClass::iArgus]);
    } else if (fixpar == 1) { // set and fix all parameters (if reasonable value is given)
      if (inputPar[VirClass::iMean]  > 0.)   { Rm->setVal(inputPar[VirClass::iMean]);  Rm->setConstant(); }
      if (inputPar[VirClass::iSigma] > 0.)   { Rs->setVal(inputPar[VirClass::iSigma]); Rs->setConstant(); }
      if (inputPar[VirClass::iArgus] > -55.) { ar->setVal(inputPar[VirClass::iArgus]); }
      //CB we fit the argus shape with USECB=1 ar.setConstant();
    }
    std::cout<< "Parameters before fitting:: " << Rm->getVal() << " " << Rs->getVal() << " " << ar->getVal() 
	     << " " << nsig->getVal() << " " << nbkg->getVal() << std::endl;
  }
  
  /* ========= Set Parameter for Argus and CB Model  ============ */
  
  if(MESFITMODEL == ArgusAndCB){

    // get hook to parameters
    RooRealVar* ar     = getPointer(model, "ar");
    RooRealVar* cutoff = getPointer(model, "cutoff");

    // get hook to parameters
    RooRealVar* Rm = getPointer(model, "mean");
    RooRealVar* Rs = getPointer(model, "sigma");
    RooRealVar* Ra = getPointer(model, "alpha");
    RooRealVar* Rn = getPointer(model, "n");


    cout << "CHECKING PARAMETERS WHAT DO WE USE? " << Rm->GetName() << "= " << Rm->getVal() << "; "
     << Rs->GetName() << "= " << Rs->getVal() << "; " << Ra->GetName() << "= " << Ra->getVal() << "; "
     << Rn->GetName() << "= " << Rn->getVal() << endl;

    
    // DO WE WANT TO FIX THIS ON DATA TOO???//
    cutoff->setVal(5.2895); 
    cutoff->setConstant();

    // preset parameters and fix some if requested by flag fixpar
    if (fixpar == 0) {   // preset paramters and fix necessary parameters
      Rm->setVal(inputPar[VirClass::iMean]); 
      Rs->setVal(inputPar[VirClass::iSigma]);  
      Ra->setVal(inputPar[VirClass::iAlpha]);
      Rn->setVal(inputPar[VirClass::iN]);  //   Rn->setConstant();
      ar->setVal(inputPar[VirClass::iArgus]);
    } else if(fixpar == 1) {   // set and fix all parameters (if reasonable value is given)
      if (inputPar[VirClass::iMean]  > 0.)   { Rm->setVal(inputPar[VirClass::iMean]); Rm->setConstant();  }
      if (inputPar[VirClass::iSigma] > 0.)   { Rs->setVal(inputPar[VirClass::iSigma]); Rs->setConstant();  }
      if (inputPar[VirClass::iN] > 0.)       { Rn->setVal(inputPar[VirClass::iN]);      Rn->setConstant();  }
      if (inputPar[VirClass::iAlpha] > 0.)   { Ra->setVal(inputPar[VirClass::iAlpha]);  Ra->setConstant();  }
      if (inputPar[VirClass::iArgus] > -55.) { ar->setVal(inputPar[VirClass::iArgus]); }
      //CB we fit the argus shape with USECB=1 ar.setConstant();
    }
    std::cout<< "Parameters before fitting:: " << Rm->getVal() << " " << Rs->getVal() << " " << Ra->getVal() << " " << Rn->getVal() << " " << ar->getVal() 
	     << " " << nsig->getVal() << " " << nbkg->getVal() << std::endl;
  }
   
  /* ========= Set Parameter for Argus and Thosig Model (AKA Frankenstein)  ============ */
  
  if(MESFITMODEL == ArgusAndThosig) {
    // get hook to parameters
    RooRealVar* ar     = getPointer(model, "ar");
    RooRealVar* cutoff = getPointer(model, "cutoff");

    // get hook to parameters
    RooRealVar* Thor        = getPointer(model,"ThoSigR"); 
    RooRealVar* Thosigma_r1 = getPointer(model,"sigma_r1"); 
    RooRealVar* Thoxc       = getPointer(model,"ThoSigXc"); 
    RooRealVar* Thosigma_r2 = getPointer(model,"sigma_r2"); 
    RooRealVar* Thosigma_l  = getPointer(model,"sigma_l"); 
    RooRealVar* Thon        = getPointer(model,"ThoSigN"); 
    RooRealVar* Thoalpha    = getPointer(model,"ThoSigAlpha"); 

    
    //    if (data != datadata) { // fix endpoint on MC
    //      cutoff->setVal(5.288); cutoff->setConstant(); //5.2895 old value
    //    }

    // preset parameters and fix some if requested by flag fixpar
    if (fixpar == 0) {   // preset paramters and fix necessary parameters
      if (inputPar[VirClass::iThoSigR] > 0.)     { Thor->setVal(inputPar[VirClass::iThoSigR]);    Thor->setConstant(); }
      if (inputPar[VirClass::iSigma_r1] > 0.)    { Thosigma_r1->setVal(inputPar[VirClass::iSigma_r1]); }
      if (inputPar[VirClass::iThoSigXc] > 0.)    { Thoxc->setVal(inputPar[VirClass::iThoSigXc]); }          
      if (inputPar[VirClass::iSigma_r2] > 0.)    { Thosigma_r2->setVal(inputPar[VirClass::iSigma_r2]); Thosigma_r2->setConstant(); }
      if (inputPar[VirClass::iSigma_l]  > 0.)    { Thosigma_l->setVal(inputPar[VirClass::iSigma_l]); }
      if (inputPar[VirClass::iThoSigN] > 0.)     { Thon->setVal(inputPar[VirClass::iThoSigN]);         Thon->setConstant(); }
      if (inputPar[VirClass::iThoSigAlpha] > 0.) { Thoalpha->setVal(inputPar[VirClass::iThoSigAlpha]); Thoalpha->setConstant(); }
      ar->setVal(inputPar[VirClass::iArgus]);
    
    } else if(fixpar == 1) {   // set and fix all parameters (if reasonable value is given)
      if (inputPar[VirClass::iThoSigR] > 0.)     { Thor->setVal(inputPar[VirClass::iThoSigR]);          Thor->setConstant(); }
      if (inputPar[VirClass::iSigma_r1] > 0.)    { Thosigma_r1->setVal(inputPar[VirClass::iSigma_r1]);  Thosigma_r1->setConstant(); }
      if (inputPar[VirClass::iThoSigXc] > 0.)    { Thoxc->setVal(inputPar[VirClass::iThoSigXc]);        Thoxc->setConstant(); }
      if (inputPar[VirClass::iSigma_r2] > 0.)    { Thosigma_r2->setVal(inputPar[VirClass::iSigma_r2]);  Thosigma_r2->setConstant(); }
      if (inputPar[VirClass::iSigma_l]  > 0.)    { Thosigma_l->setVal(inputPar[VirClass::iSigma_l]);    Thosigma_l->setConstant(); }
      if (inputPar[VirClass::iThoSigN] > 0.)     { Thon->setVal(inputPar[VirClass::iThoSigN]);          Thon->setConstant(); }
      if (inputPar[VirClass::iThoSigAlpha] > 0.) { Thoalpha->setVal(inputPar[VirClass::iThoSigAlpha]);  Thoalpha->setConstant(); }
      if (inputPar[VirClass::iArgus] > -55.) { ar->setVal(inputPar[VirClass::iArgus]); }
      //CB we fit the argus shape with USECB=1 ar.setConstant();
      /*      if( buddahs < 500. ) {
	Thosigma_r1->setConstant(); 
	Thoxc->setConstant();	
	Thosigma_l->setConstant(); 
      }*/
    }
      
    std::cout<< "Parameters before fitting:: " << Thor->GetName()<<": "<<Thor->getVal() << " " 
	     << Thosigma_r1->GetName()<<": "<<Thosigma_r1->getVal() << " " 
	     << Thoxc->GetName()<<": "<<Thoxc->getVal() << " " 
	     << Thosigma_r2->GetName()<<": "<<Thosigma_r2->getVal()<< " " 
	     << Thosigma_l->GetName()<<": "<<Thosigma_l->getVal() << " " 
	     << Thon->GetName()<<": "<<Thon->getVal() << " " 
	     << Thoalpha->GetName()<<": "<<Thoalpha->getVal()<< " " 
	     << ar->GetName()<<": "<<ar->getVal() << " " 
	     << cutoff->GetName()<<": "<<cutoff->getVal() << std::endl;
  }

  /* ========= Set Parameter for 3 Pdf Model  ============ */
  
  if (MESFITMODEL == ThreePDFs) { // For Thorsten's stuff

    //CB allow for separate signal and background fits by using jmatch
    RooRealVar* ar; 
    RooRealVar* cutoff;

    RooRealVar* Rm; 
    RooRealVar* Rs;
    RooRealVar* Ra; 
    RooRealVar* Rn;
    RooRealVar* Rendpoint;

    RooRealVar* Thor; 
    RooRealVar* Thosigma_r1;
    RooRealVar* Thoxc;
    RooRealVar* Thosigma_r2; 
    RooRealVar* Thosigma_l; 
    RooRealVar* Thon; 
    RooRealVar* Thoalpha;

    // get hook to parameters
    if (jmatch != 2){
      ar     = getPointer(model, "ar");
      cutoff = getPointer(model, "cutoff");
    
      if (data != datadata) { // fix endpoint on MC
	cutoff->setVal(5.2891); cutoff->setConstant();
      }
    }

    // get hook to parameters
    if (jmatch != 2){
      Rm        = getPointer(model, "ccbmean");
      Rs        = getPointer(model, "ccbsigma");
      Ra        = getPointer(model, "ccbalpha");
      Rn        = getPointer(model, "ccbn");
      Rendpoint = getPointer(model, "ccbcutoff");
      
      if (data != datadata) { // fix endpoint on MC
	Rendpoint->setVal(5.2891); Rendpoint->setConstant();
      }
    }

    // get hook to parameters
    if (jmatch != 1){
      Thor        = getPointer(model, "ThoSigR");
      Thosigma_r1 = getPointer(model, "sigma_r1");
      Thoxc       = getPointer(model, "ThoSigXc");
      Thosigma_r2 = getPointer(model, "sigma_r2");
      Thosigma_l  = getPointer(model, "sigma_l");
      Thon        = getPointer(model, "ThoSigN");
      Thoalpha    = getPointer(model, "ThoSigAlpha");
    }      

    // preset parameters and fix some if requested by flag fixpar
    if (fixpar == 0) { // preset variables, but don't fix all

      //SIGNAL PDF

      if (jmatch == 0){         //allow only some parameters to float when fitting on all components
	if (inputPar[VirClass::iThoSigR] > 0.)     { Thor->setVal(inputPar[VirClass::iThoSigR]);        Thor->setConstant(); }
	if (inputPar[VirClass::iSigma_r1] > 0.)    { Thosigma_r1->setVal(inputPar[VirClass::iSigma_r1]); }
	if (inputPar[VirClass::iThoSigXc] > 0.)    { Thoxc->setVal(inputPar[VirClass::iThoSigXc]); }          
	if (inputPar[VirClass::iSigma_r2] > 0.)    { Thosigma_r2->setVal(inputPar[VirClass::iSigma_r2]); Thosigma_r2->setConstant(); }
	if (inputPar[VirClass::iSigma_l]  > 0.)    { Thosigma_l->setVal(inputPar[VirClass::iSigma_l]); }
	if (inputPar[VirClass::iThoSigN] > 0.)     { Thon->setVal(inputPar[VirClass::iThoSigN]);         Thon->setConstant(); }
	if (inputPar[VirClass::iThoSigAlpha] > 0.) { Thoalpha->setVal(inputPar[VirClass::iThoSigAlpha]); Thoalpha->setConstant(); }
      }

      if (jmatch == 2){         //allow all parameters to float when fitting on signal only
	if (inputPar[VirClass::iThoSigR] > 0.)     { Thor->setVal(inputPar[VirClass::iThoSigR]); }
	if (inputPar[VirClass::iSigma_r1] > 0.)    { Thosigma_r1->setVal(inputPar[VirClass::iSigma_r1]); }
	if (inputPar[VirClass::iThoSigXc] > 0.)    { Thoxc->setVal(inputPar[VirClass::iThoSigXc]); }          
	if (inputPar[VirClass::iSigma_r2] > 0.)    { Thosigma_r2->setVal(inputPar[VirClass::iSigma_r2]);  }
	if (inputPar[VirClass::iSigma_l]  > 0.)    { Thosigma_l->setVal(inputPar[VirClass::iSigma_l]); }
	if (inputPar[VirClass::iThoSigN] > 0.)     { Thon->setVal(inputPar[VirClass::iThoSigN]); }
	if (inputPar[VirClass::iThoSigAlpha] > 0.) { Thoalpha->setVal(inputPar[VirClass::iThoSigAlpha]); }
      }
    
      //BACKGROUND PDFs

      if (jmatch ==0){          //do not touch CCB parameters when fitting on all components
	if (inputPar[VirClass::iMean]  > 0.)       { Rm->setVal(inputPar[VirClass::iMean]);  Rm->setConstant(); }
	if (inputPar[VirClass::iSigma] > 0.)       { Rs->setVal(inputPar[VirClass::iSigma]); Rs->setConstant(); }
	if (inputPar[VirClass::iN] > 0.)           { Rn->setVal(inputPar[VirClass::iN]);     Rn->setConstant(); }
	if (inputPar[VirClass::iAlpha] > 0.)       { Ra->setVal(inputPar[VirClass::iAlpha]); Ra->setConstant(); }
	if (data == datadata && !EPOINTCOR) { // only on data without endpoint correction
	  if (inputPar[VirClass::iEndpoint] > 0.)  { Rendpoint->setVal(inputPar[VirClass::iEndpoint]); }
	}
	
	if (inputPar[VirClass::iArgus] > -55.)     { ar->setVal(inputPar[VirClass::iArgus]); }
	if (data == datadata && !EPOINTCOR) { // only on data without endpoint correction
	  if (inputPar[VirClass::iCutOff] > 0.)    { cutoff->setVal(inputPar[VirClass::iCutOff]); }
	}
      }

      if (jmatch ==1){          //allow all CCB parameters to float when fitting on background only
	if (inputPar[VirClass::iMean]  > 0.)       { Rm->setVal(inputPar[VirClass::iMean]);  }
	if (inputPar[VirClass::iSigma] > 0.)       { Rs->setVal(inputPar[VirClass::iSigma]); }
	if (inputPar[VirClass::iN] > 0.)           { Rn->setVal(inputPar[VirClass::iN]);     }
	if (inputPar[VirClass::iAlpha] > 0.)       { Ra->setVal(inputPar[VirClass::iAlpha]); }
	if (data == datadata && !EPOINTCOR) { // only on data without endpoint correction
	  if (inputPar[VirClass::iEndpoint] > 0.)  { Rendpoint->setVal(inputPar[VirClass::iEndpoint]); }
	}
	
	if (inputPar[VirClass::iArgus] > -55.)     { ar->setVal(inputPar[VirClass::iArgus]); }
	if (data == datadata && !EPOINTCOR) { // only on data without endpoint correction
	  if (inputPar[VirClass::iCutOff] > 0.)    { cutoff->setVal(inputPar[VirClass::iCutOff]); }
	}
      }

    } else if(fixpar == 1) { // set and fix all parameters (if reasonable value is given)
    
      if (jmatch != 1){
	if (inputPar[VirClass::iThoSigR] > 0.)     { Thor->setVal(inputPar[VirClass::iThoSigR]);         Thor->setConstant(); }
	if (inputPar[VirClass::iSigma_r1] > 0.)    { Thosigma_r1->setVal(inputPar[VirClass::iSigma_r1]); Thosigma_r1->setConstant(); }
	if (inputPar[VirClass::iThoSigXc] > 0.)    { Thoxc->setVal(inputPar[VirClass::iThoSigXc]);       Thoxc->setConstant(); }
	if (inputPar[VirClass::iSigma_r2] > 0.)    { Thosigma_r2->setVal(inputPar[VirClass::iSigma_r2]); Thosigma_r2->setConstant(); }
	if (inputPar[VirClass::iSigma_l]  > 0.)    { Thosigma_l->setVal(inputPar[VirClass::iSigma_l]);   Thosigma_l->setConstant(); }
	if (inputPar[VirClass::iThoSigN] > 0.)     { Thon->setVal(inputPar[VirClass::iThoSigN]);         Thon->setConstant(); }
	if (inputPar[VirClass::iThoSigAlpha] > 0.) { Thoalpha->setVal(inputPar[VirClass::iThoSigAlpha]); Thoalpha->setConstant(); }
      }

      if (jmatch !=2){
	if (inputPar[VirClass::iMean]  > 0.)       { Rm->setVal(inputPar[VirClass::iMean]);  Rm->setConstant(); }
	if (inputPar[VirClass::iSigma] > 0.)       { Rs->setVal(inputPar[VirClass::iSigma]); Rs->setConstant(); }
	if (inputPar[VirClass::iN] > 0.)           { Rn->setVal(inputPar[VirClass::iN]);     Rn->setConstant(); }
	if (inputPar[VirClass::iAlpha] > 0.)       { Ra->setVal(inputPar[VirClass::iAlpha]); Ra->setConstant(); }
	if (data == datadata && !EPOINTCOR) { // only on data without endpoint correction
	  if (inputPar[VirClass::iEndpoint] > 0.)  { Rendpoint->setVal(inputPar[VirClass::iEndpoint]); Rendpoint->setConstant(); }
	}
	
	if (inputPar[VirClass::iArgus] > -55.)  { ar->setVal(inputPar[VirClass::iArgus]); }
	if (data == datadata && !EPOINTCOR) { // only on data without endpoint correction
	  if (inputPar[VirClass::iCutOff] > 0.)    { cutoff->setVal(inputPar[VirClass::iCutOff]); cutoff->setConstant(); }
	}
      }
    }
    if (jmatch == 0){ 
      std::cout<< "Parameters before fitting::" 
	       << " " << Thor->getVal() << " " << Thosigma_r1->getVal() << " " << Thoxc->getVal() << " " << Thosigma_r2->getVal() 
	       << " " << Thosigma_l->getVal() << " " << Thon->getVal() << " " << Thoalpha->getVal()
	       << " " << Rm->getVal() << " " << Rs->getVal() << " " << Ra->getVal() << " " << Rn->getVal() << " " << Rendpoint->getVal()
	       << " " << ar->getVal() << " " << cutoff->getVal() << std::endl;
    } else if (jmatch == 1){
      std::cout<< "Parameters before fitting::" 
	       << " " << Rm->getVal() << " " << Rs->getVal() << " " << Ra->getVal() << " " << Rn->getVal() << " " << Rendpoint->getVal()
	       << " " << ar->getVal() << " " << cutoff->getVal() << std::endl;
    } else if (jmatch == 2){
      std::cout<< "Parameters before fitting::" 
	       << " " << Thor->getVal() << " " << Thosigma_r1->getVal() << " " << Thoxc->getVal() << " " << Thosigma_r2->getVal() 
	       << " " << Thosigma_l->getVal() << " " << Thon->getVal() << " " << Thoalpha->getVal() << std::endl;
    }
    
    if(fixsigtopeakratio)
      std::cout<< " " << nsig->getVal() << " " << newbpk->getVal() << " " << nbkg->getVal() << std::endl;
    else
      std::cout<< " " << nsig->getVal() << " " << nbpk->getVal() << " " << nbkg->getVal() << std::endl;
    
  } 


  if (firstCall) { model->printCompactTree(); firstCall = false; }


  /* --- do the actual fitting --- */

  switch(MESFITMODEL){
  case GaussFit: std::cout << "Fitting Gaussian instead of Crystal Ball" << std::endl; break;
  case ArgusAndCB:  std::cout << "Fitting Argus and Crystal Ball" << std::endl; break;
  case ArgusAndThosig: std::cout << "Fitting Argus and Frankenstein" << std::endl; break;
  case ThreePDFs:
    if (jmatch ==0) std::cout << "Fitting Thorsten Signal and background PDFs" << std::endl;
    else if (jmatch ==1) std::cout << "Fitting Thorsten Background PDFs" << std::endl;
    else if (jmatch ==2) std::cout << "Fitting Thorsten Signal PDFs" << std::endl; break;
  default: std::cout<<" W A R N I N G !   no known model to fit mES distribution ! ! ! This is an ERROR!" << std::endl; break;
  }
    

  RooFitResult* r = 0; 
  if (NOTUNBINNED < -10) { // use chi2 fit
    RooChi2Var chi2var("chi2var", "chi2var", *model, *bdatared, DataError(RooAbsData::SumW2), Extended(kTRUE));
    std::cout << "Created chi2 variable" << std::endl;
    RooMinuit minuit(chi2var);
    std::cout << "Created RooMinut object" << std::endl;
    minuit.migrad();
    minuit.hesse();
    r = minuit.save();
  } else {               // standard fit: extended maximum likelikhood
    //-----------------------ANTONIO 23-APR-2007
    //    r = model->fitTo(*dataset, "rmhe","mesint");
    r = model->fitTo(*dataset, RooFit::Save(kTRUE), RooFit::Minos(kFALSE), RooFit::Hesse(kTRUE), RooFit::Extended(kTRUE));
    //----------------------
  }

  // dump final model
  if (_debug > 0) {
    RooArgSet* comps = model->getComponents();

    std::cout << std::endl;
    std::cout << "Full tree for " << model->ClassName() << "::" << model->GetName();
    std::cout << " Components: "; comps->Print(); std::cout << std::endl;

    TIterator* iter= comps->createIterator();
    RooAbsArg* pdf = 0;
    while ((pdf=(RooAbsArg*)iter->Next())) {
    
      if (std::string(pdf->GetName()) == std::string(model->GetName())) continue;

      RooArgSet* params = pdf->getParameters(RooArgSet());

      std::cout << " Component " << pdf->ClassName() << "::" << pdf->GetName();
      std::cout << " Variables: "; params->Print("v"); std::cout << std::endl;

      delete params;
    }
    delete iter; delete comps;
  }

  //determine nDOF
  Int_t floatParms = (r->floatParsFinal()).getSize();
  std::cout << " control : number of floating params ----> " << floatParms << std::endl; 

  // make plot
  xframe = mes->frame() ;
  xframe->SetTitle((data->GetTitle()+std::string(" ")+simply).c_str());
  
  // plot data on it
  if (dataset->IsA() == RooDataHist::Class()) {
    dataset->plotOn(xframe, RooFit::MarkerSize(0.10), RooFit::DataError(RooAbsData::SumW2));
  } else {
    RooBinning tbins(mes->getBins(), mes->getMin(), mes->getMax(), "plotbinning");
    dataset->plotOn(xframe, RooFit::Binning(tbins), RooFit::MarkerSize(0.10), RooFit::DataError(RooAbsData::SumW2));
  }

  // plot bkg PDFs
  model->plotOn(xframe, RooFit::Components("ae"), RooFit::LineWidth(2), RooFit::LineColor(kRed)) ;
  if (MESFITMODEL == ThreePDFs) {
    model->plotOn(xframe, RooFit::Components("ccb"), RooFit::LineWidth(2), RooFit::LineColor(kYellow)) ;
  }

  // plot total model
  model->plotOn(xframe, LineWidth(2));
  model->paramOn(xframe, dataset, "Fit Results",1,"ne",0.15,0.55,0.8);

  // plot data on it (for display purposes?)
  /*
  if (dataset->IsA() == RooDataHist::Class()) {
    dataset->plotOn(xframe, RooFit::MarkerSize(0.25), RooFit::DataError(RooAbsData::SumW2));
  } else {
    RooBinning tbins(mes->getBins(), mes->getMin(), mes->getMax(), "plotbinning");
    dataset->plotOn(xframe, RooFit::Binning(tbins), RooFit::MarkerSize(0.25), RooFit::DataError(RooAbsData::SumW2));
  }
  */

  // Output of Various useful information.
  std::cout << " TOTINFO: Dataset " << dataset->GetName() << " cut " << simply << " xframe chisquare = " << xframe->chiSquare(floatParms) << " Error Matrix Status " <<  r->covQual() << std:: endl;

  std::cout << "xframe chisquare = " << xframe->chiSquare(floatParms) << std::endl;

  TPaveText*  tbox1 = new TPaveText(0.79, 0.94, 0.99, 0.99, "NDC");
  char line1[50];
  sprintf(line1, "#chi^{2} = %5.4f",  xframe->chiSquare(floatParms));
  tbox1->AddText(line1);
  tbox1->SetFillColor(0);
  //  tbox1->SetShadowColor(0);
  xframe->addObject(tbox1);
    
  //compute single contributions to chisquare...
  
  //  cout<<((RooHist*)(xframe->getObject(0)))->GetName()<<" "<<((RooCurve*)(xframe->getObject(2)))->GetName()<<endl;

  RooHist* pullhisto = xframe->pullHist();// ((RooHist*)(xframe->getObject(0)))->GetName(),((RooCurve*)(xframe->getObject(2)))->GetName() );
  RooPlot* pullframe = mes->frame();
  //  pullframe->addObject(pullhisto); 
  pullframe->addPlotable(pullhisto);//,"",kFALSE,kTRUE);
  //  pullframe->updateYAxis(pullhisto->getYAxisMin(),pullhisto->getYAxisMax(),pullhisto->getYAxisLabel());
  //pullframe->updateFitRangeNorm(pullhisto,kFALSE) ; //?? kTRUE ??
  pullframe->SetMarkerStyle(24);
  pullframe->SetNdivisions(504, "Y");
  pullframe->SetLabelSize(0.52, "X");  pullframe->SetLabelSize(0.15, "Y");
  pullframe->SetStats(0);
  pullframe->SetTitle("");
  pullframe->SetTitleSize(0.22, "Y");
  pullframe->SetTitleOffset(0.22, "Y");
  pullframe->SetYTitle("Pull");
  pullhisto->Print("Verbose");

  //compute chisquare probability
  Double_t probchi = TMath::Prob((xframe->chiSquare(floatParms)) * 
				 (pullhisto->GetN()-floatParms), (pullhisto->GetN()-floatParms));
  std::cout << "chisq probability = " << probchi << std::endl;

  // print chisquare
  // if(tbox1 != NULL) {delete tbox1; tbox1 = 0;}

  //    RooChi2Var fitchisq("fitchisq","fitchisq",model,*bdatared);
  //    //RooChi2Var fitchisq("fitchisq","fitchisq",tmodel,*bdatared);
  //    cout << "chisquare is ---> " << fitchisq.getVal()/(bmes.getBins()-floatParms) << endl; 
  //

  //print chisquare probability
  //  if(tbox2 != NULL) {delete tbox2; tbox2 = 0;}

  /* Chi square probability on plots: removed
  TPaveText*  tbox2 = new TPaveText(0.79, 0.94, 0.99, 0.99, "BRNDC");
  char line2[50];
  sprintf(line2, "Prob(#chi^{2}) = %4.2f", probchi);
  tbox2->AddText(line2);
  xframe->addObject(tbox2);
  */

  //CB put also pull distributions
  //  if(mPad != NULL) {delete mPad; mPad = 0;}
  //  if(pPad != NULL) {delete pPad; pPad = 0;}

  TPad* mPad = new TPad("mES plot",  "", 0.02, 0.30, 0.98, 0.98);  mPad->Draw(); 
  TPad* pPad = new TPad("pull plot", "", 0.02, 0.02, 0.98, 0.28);  pPad->Draw();
  
  mPad->cd();
  xframe->Draw(); mPad->Modified();
  
  pPad->cd();
  pullframe->Draw();//pullframe->Draw();
  
  pPad->Modified();
  pPad->Update();

  
  Double_t sig_fraction = FITALLMESRANGE ? 1 : sigpointer->createIntegral(*mes,RooArgSet(*mes),"mesint")->getVal();
  Double_t arg_fraction = FITALLMESRANGE ? 1 : arguspointer->createIntegral(*mes,RooArgSet(*mes),"mesint")->getVal();
  Double_t ccb_fraction(0);
if(ccbpointer != NULL)
    ccb_fraction = FITALLMESRANGE ? 1 : ccbpointer->createIntegral(*mes,RooArgSet(*mes),"mesint")->getVal();
  
  cout<<" Now rescaling signal and background yields and errors for fraction inside mes Range "<<endl;
  cout<<" Mes range is ["<< (FITALLMESRANGE ? "5.22, " : "5.27, ") <<mesMax<<"]; Fractions: Signal "<<sig_fraction<<" Argus "<<arg_fraction;
  if(MESFITMODEL == ThreePDFs)
    cout<<" CCB "<<ccb_fraction;
  cout<<endl;
    
  // get results and fill mesData object
  double p0 = sig_fraction*nsig->getVal(); double Dp0 = sig_fraction*nsig->getError();
  
  //modifiche antonio petrella per sstematiche in mes alla vera
  /*
  p0 = dataset->sumEntries("mes > 5.27");
  Dp0 = TMath::Sqrt(p0);
  p0 -= arg_fraction*nbkg->getVal();
  Dp0 = TMath::Sqrt(Dp0*Dp0 + arg_fraction*nbkg->getError()* arg_fraction*nbkg->getError());
  */
  //fine modifiche
  
  if (MESFITMODEL == ThreePDFs && jmatch == 1) {p0 = ccb_fraction*nbpk->getVal(); Dp0 = ccb_fraction*nbpk->getError();}

  if (p0 < 0.1 && Dp0 > 1000.) {
    std::cout << "Warning: adjusting error for Nsig in dataset " << data->GetName() 
	      << " and cuts " << simply << " from " << Dp0 << "to zero!" << std::endl;
    Dp0 =0.;
  }
  
  double p1 = arg_fraction*nbkg->getVal(); double Dp1 = arg_fraction*nbkg->getError();  
  if (p1 < 0.1 && Dp1 > 1000.) {
    std::cout << "Warning: adjusting error for Nbkg in dataset " << data->GetName() 
	      << " and cuts " << simply << " from " << Dp1 << "to zero!" << std::endl;
    Dp1 =0.;
  }
  if (MESFITMODEL == ThreePDFs && jmatch == 0) { // add peaking background to continuum background
    double p2,Dp2;
    if(fixsigtopeakratio){
      p2 = sig_fraction*nsig->getVal()/(*activecorrection);  //To be changed in p2=newbpk->getVal() 
      cout << ccb_fraction*newbpk->getVal()<<endl;
      Dp2 = sig_fraction*nsig->getError()/(*activecorrection); 
    } else { 
      p2 = ccb_fraction*nbpk->getVal(); 
      Dp2 = ccb_fraction*nbpk->getError();
    }
    if (p2 < 0.1 && Dp2 > 1000.) {
      std::cout << "Warning: adjusting error for Nbkg in dataset " << data->GetName() 
		<< " and cuts " << simply << " from " << Dp2 << "to zero!" << std::endl;
      Dp2 =0.;
    }
    p1 += p2;
    Dp1 = sqrt(Dp1*Dp1 + Dp2*Dp2);
  }
  if (datared->sumEntries() == 0) p0 = Dp0 = p1 = Dp1 = 0.;

  mesData *pD = new mesData(datared->GetName(),p0,Dp0,p1,Dp1,p0/(p0+p1),dBinomial(p0, p0+p1));

  // get best fit for reuse
  if (MESFITMODEL == ThreePDFs) {

    //CB we always give 14 parameters to MODEL regardless we are fitting all, or signal/background separately
    results.resize(14);

    //    if (jmatch == 0){
    //      results.resize(14);
    //    } else if (jmatch == 1 || jmatch == 2){
    //      results.resize(7);
    //    }
    if (results.size() != inputPar.size()) {
      std::cout << "Error: inconsistency in input/output parameters for mes fit! Exiting!" << std::cout;
      exit(EXIT_FAILURE);
    }

    if (jmatch != 1){
      results[VirClass::iThoSigR]     = getVal(model, "ThoSigR");
      results[VirClass::iSigma_r1]    = getVal(model, "sigma_r1");
      results[VirClass::iThoSigXc]    = getVal(model, "ThoSigXc");
      results[VirClass::iSigma_r2]    = getVal(model, "sigma_r2");
      results[VirClass::iSigma_l]     = getVal(model, "sigma_l");
      results[VirClass::iThoSigN]     = getVal(model, "ThoSigN");
      results[VirClass::iThoSigAlpha] = getVal(model, "ThoSigAlpha");
    }

    if (jmatch !=2){
      results[VirClass::iMean]        = getVal(model, "ccbmean");
      results[VirClass::iSigma]       = getVal(model, "ccbsigma");
      results[VirClass::iN]           = getVal(model, "ccbalpha");
      results[VirClass::iAlpha]       = getVal(model, "ccbn");
      results[VirClass::iEndpoint]    = getVal(model, "ccbcutoff");
      
      results[VirClass::iArgus]       = getVal(model, "ar");
      results[VirClass::iCutOff]      = getVal(model, "cutoff");
    }

  }

  if (MESFITMODEL==ArgusAndCB){
    results.resize(5);
    if (results.size() != inputPar.size()) {
      std::cout << "Error: inconsistency in input/output parameters for mes fit! Exiting!" << std::cout;
      exit(EXIT_FAILURE);
    }

    results[VirClass::iMean]  = getVal(model, "mean");
    results[VirClass::iSigma] = getVal(model, "sigma");
    results[VirClass::iAlpha] = getVal(model, "alpha");
    results[VirClass::iN]     = getVal(model, "n");
    results[VirClass::iArgus] = getVal(model, "ar");
  }

  if (MESFITMODEL==ArgusAndThosig){ //MAYBE DANGEROUS!!! WE HAVE A VECTOR WITH NOT VALID POSITION !!!
    results.resize(14);
    if (results.size() != inputPar.size()) {
      std::cout << "Error: inconsistency in input/output parameters for mes fit! Exiting!" << std::cout;
      exit(EXIT_FAILURE);
    }
    
    results[VirClass::iThoSigR]     = getVal(model, "ThoSigR");
    results[VirClass::iSigma_r1]    = getVal(model, "sigma_r1");
    results[VirClass::iThoSigXc]    = getVal(model, "ThoSigXc");
    results[VirClass::iSigma_r2]    = getVal(model, "sigma_r2");
    results[VirClass::iSigma_l]     = getVal(model, "sigma_l");
    results[VirClass::iThoSigN]     = getVal(model, "ThoSigN");
    results[VirClass::iThoSigAlpha] = getVal(model, "ThoSigAlpha");
    
    results[VirClass::iArgus] = getVal(model, "ar");
  }


  // hack for systematic errors on floating parameters
  if (ME!=0) {

    if (MESFITMODEL == ThreePDFs) {

      // these parameters are floating in the big sample fit and fixed in the final fits

      if (ME==1 && jmatch != 1) results[VirClass::iSigma_r1]  = getVal(model, "sigma_r1")  + getError(model, "sigma_r1");
      if (ME==2 && jmatch != 1) results[VirClass::iThoSigXc]  = getVal(model, "ThoSigXc")  + getError(model, "ThoSigXc");
      if (ME==3 && jmatch != 1) results[VirClass::iSigma_l]   = getVal(model, "sigma_l")   + getError(model, "sigma_l");
      if (ME==4 && jmatch != 2) results[VirClass::iArgus]     = getVal(model, "ar")        + getError(model, "ar");

      if (ME==5 && jmatch != 1) results[VirClass::iSigma_r1]  = getVal(model, "sigma_r1")  - getError(model, "sigma_r1");
      if (ME==6 && jmatch != 1) results[VirClass::iThoSigXc]  = getVal(model, "ThoSigXc")  - getError(model, "ThoSigXc");
      if (ME==7 && jmatch != 1) results[VirClass::iSigma_l]   = getVal(model, "sigma_l")   - getError(model, "sigma_l");
      if (ME==8 && jmatch != 2) results[VirClass::iArgus]     = getVal(model, "ar")        - getError(model, "ar");

      // these parameters are always fixed. Errors come from MC studies and are applied while reading parameter file.

      // endpoints are treated differently

      if (ME==25 && jmatch != 2) results[VirClass::iEndpoint]     = getVal(model, "ccbcutoff")    + (data==datadata ? getError(model, "ccbcutoff") : 0.);
      if (ME==26 && jmatch != 2) results[VirClass::iCutOff]       = getVal(model, "cutoff")       + (data==datadata ? getError(model, "cutoff")    : 0.);
      if (ME==27 && jmatch != 2) results[VirClass::iEndpoint]     = getVal(model, "ccbcutoff")    - (data==datadata ? getError(model, "ccbcutoff") : 0.);
      if (ME==28 && jmatch != 2) results[VirClass::iCutOff]       = getVal(model, "cutoff")       - (data==datadata ? getError(model, "cutoff")    : 0.);

      if (ME==29 && jmatch != 2) {
	results[VirClass::iEndpoint]     = getVal(model, "ccbcutoff")    + (data==datadata ? getError(model, "ccbcutoff") : 0.);
	results[VirClass::iCutOff]       = getVal(model, "cutoff")       + (data==datadata ? getError(model, "cutoff")    : 0.);
      }
      if (ME==30 && jmatch != 2) {
	results[VirClass::iEndpoint]     = getVal(model, "ccbcutoff")    - (data==datadata ? getError(model, "ccbcutoff") : 0.);
	results[VirClass::iCutOff]       = getVal(model, "cutoff")       - (data==datadata ? getError(model, "cutoff")    : 0.);
      }
    } else if (MESFITMODEL == ArgusAndThosig){

//       Double_t rho34 = r->correlation("ThoSigXc","ar");     
//       Double_t rho36 = r->correlation("ThoSigXc","sigma_l");
//       Double_t rho37 = r->correlation("ThoSigXc","sigma_r1");

//       Double_t rho46 = r->correlation("ar","sigma_l");     
//       Double_t rho47= r->correlation("ar","sigma_r1");
      
//       Double_t rho67 = r->correlation("sigma_l","sigma_r1");

      
      if (ME==1) {
	results[VirClass::iSigma_r1]  = getVal(model, "sigma_r1")  + getError(model, "sigma_r1");
	results[VirClass::iThoSigXc]  = getVal(model, "ThoSigXc")  + TMath::Sqrt(getError(model, "ThoSigXc")*getError(model, "sigma_r1")*r->correlation("ThoSigXc","sigma_r1"));
	results[VirClass::iSigma_l]  = getVal(model, "sigma_l")  + TMath::Sqrt(getError(model, "sigma_l")*getError(model, "sigma_r1")*r->correlation("sigma_l","sigma_r1"));
	//results[VirClass::iArgus]     =getVal(model, "ar")        + TMath::Sqrt(getError(model, "ar")*
	//	       getError(model, "sigma_r1")*r->correlation("ar","sigma_r1"));
      }
      if (ME==2) { 
	results[VirClass::iThoSigXc]  = getVal(model, "ThoSigXc")  + getError(model, "ThoSigXc");
	results[VirClass::iSigma_r1]  = getVal(model, "sigma_r1")  + TMath::Sqrt(getError(model, "ThoSigXc")*getError(model, "sigma_r1")*r->correlation("ThoSigXc","sigma_r1"));
	results[VirClass::iSigma_l]  = getVal(model, "sigma_l")  + TMath::Sqrt(getError(model, "sigma_l")*getError(model, "ThoSigXc")*r->correlation("sigma_l","ThoSigXc"));
	//	results[VirClass::iArgus]     =getVal(model, "ar")        + TMath::Sqrt(getError(model, "ar")*/						       getError(model, "ThoSigXc")*r->correlation("ar","ThoSigXc"));
      }
      if (ME==3) {
	results[VirClass::iSigma_l]   = getVal(model, "sigma_l")   + getError(model, "sigma_l");
	results[VirClass::iSigma_r1]  = getVal(model, "sigma_r1")  + TMath::Sqrt(getError(model, "sigma_l")*getError(model, "sigma_r1")*r->correlation("sigma_l","sigma_r1"));
	results[VirClass::iThoSigXc]  = getVal(model, "ThoSigXc")  + TMath::Sqrt(getError(model, "ThoSigXc")*getError(model, "sigma_l")*r->correlation("ThoSigXc","sigma_l"));
	//	results[VirClass::iArgus]     =getVal(model, "ar")        + TMath::Sqrt(getError(model, "ar")*
	//									       getError(model, "sigma_l")*r->correlation("ar","sigma_l"));
      }

      if (ME==4) {
	results[VirClass::iArgus]     = getVal(model, "ar")        + getError(model, "ar");
	//	results[VirClass::iThoSigXc]  = getVal(model, "ThoSigXc")  + TMath::Sqrt(getError(model, "ThoSigXc")*getError(model, "ar")*r->correlation("ThoSigXc","ar"));
	//	results[VirClass::iSigma_r1]  = getVal(model, "sigma_r1")  + TMath::Sqrt(getError(model, "ar")*
	//										 getError(model, "sigma_r1")*r->correlation("ar","sigma_r1"));
	//	results[VirClass::iSigma_l]  = getVal(model, "sigma_l")  + TMath::Sqrt(getError(model, "sigma_l")*
	//									       getError(model, "ar")*r->correlation("sigma_l","ar"));	
      }

      if (ME==5) {
	results[VirClass::iSigma_r1]  = getVal(model, "sigma_r1")  - getError(model, "sigma_r1");
	results[VirClass::iThoSigXc]  = getVal(model, "ThoSigXc")  - TMath::Sqrt(getError(model, "ThoSigXc")*getError(model, "sigma_r1")*r->correlation("ThoSigXc","sigma_r1"));
	results[VirClass::iSigma_l]  = getVal(model, "sigma_l")  - TMath::Sqrt(getError(model, "sigma_l")*getError(model, "sigma_r1")*r->correlation("sigma_l","sigma_r1"));
	//results[VirClass::iArgus]     =getVal(model, "ar")       - TMath::Sqrt(getError(model, "ar")*
	//									       getError(model, "sigma_r1")*r->correlation("ar","sigma_r1"));
      }


      if (ME==6){
	
	results[VirClass::iThoSigXc]  = getVal(model, "ThoSigXc")  - getError(model, "ThoSigXc");
	results[VirClass::iSigma_r1]  = getVal(model, "sigma_r1")  - TMath::Sqrt(getError(model, "ThoSigXc")*getError(model, "sigma_r1")*r->correlation("ThoSigXc","sigma_r1"));
	results[VirClass::iSigma_l]  = getVal(model, "sigma_l")  - TMath::Sqrt(getError(model, "sigma_l")*getError(model, "ThoSigXc")*r->correlation("sigma_l","ThoSigXc"));
	//	results[VirClass::iArgus]     =getVal(model, "ar")        - TMath::Sqrt(getError(model, "ar")*
	//										getError(model, "ThoSigXc")*r->correlation("ar","ThoSigXc"));
      } 
      if (ME==7) {
	results[VirClass::iSigma_l]   = getVal(model, "sigma_l")   - getError(model, "sigma_l");
	results[VirClass::iSigma_r1]  = getVal(model, "sigma_r1")  - TMath::Sqrt(getError(model, "sigma_l")*getError(model, "sigma_r1")*r->correlation("sigma_l","sigma_r1"));
	results[VirClass::iThoSigXc]  = getVal(model, "ThoSigXc")  - TMath::Sqrt(getError(model, "ThoSigXc")*getError(model, "sigma_l")*r->correlation("ThoSigXc","sigma_l"));
	//	results[VirClass::iArgus]     =getVal(model, "ar")        - TMath::Sqrt(getError(model, "ar")*
	//									       getError(model, "sigma_l")*r->correlation("ar","sigma_l"));
      }
      if (ME==8) {
	results[VirClass::iArgus]     = getVal(model, "ar")        - getError(model, "ar");
	//	results[VirClass::iThoSigXc]  = getVal(model, "ThoSigXc")  - TMath::Sqrt(getError(model, "ThoSigXc")*
	//										 getError(model, "ar")*r->correlation("ThoSigXc","ar"));
	//	results[VirClass::iSigma_r1]  = getVal(model, "sigma_r1")  - TMath::Sqrt(getError(model, "ar")*
	//										 getError(model, "sigma_r1")*r->correlation("ar","sigma_r1"));
	//	results[VirClass::iSigma_l]  = getVal(model, "sigma_l")  - TMath::Sqrt(getError(model, "sigma_l")*
	//									       getError(model, "ar")*r->correlation("sigma_l","ar"));
      }
      
    } else {
      if (ME==1) results[VirClass::iMean]  = getVal(model, "mean")  + getError(model, "mean");
      if (ME==2) results[VirClass::iSigma] = getVal(model, "sigma") + getError(model, "sigma");
      if (ME==3) results[VirClass::iAlpha] = getVal(model, "alpha") + getError(model, "alpha");
      if (ME==4) results[VirClass::iArgus] = getVal(model, "ar")    + getError(model, "ar");

      if (ME==5) results[VirClass::iMean]  = getVal(model, "mean")  - getError(model, "mean");
      if (ME==6) results[VirClass::iSigma] = getVal(model, "sigma") - getError(model, "sigma");
      if (ME==7) results[VirClass::iAlpha] = getVal(model, "alpha") - getError(model, "alpha");
      if (ME==8) results[VirClass::iArgus] = getVal(model, "ar")    - getError(model, "ar");
    }

  } // if (ME!=0)
  
  Double_t Lumino; Int_t idx;
  if(TString("DATA").CompareTo(dataset->GetName()) == 0) { idx=0; Lumino = LUMI_DATA;}
  if(TString("PStar").CompareTo(dataset->GetName()) == 0) { idx=1; Lumino = LUMI_GENERIC;}
  if(TString("VubIN").CompareTo(dataset->GetName()) == 0) { idx=2; Lumino = LUMI_SIGNAL;}
  if(TString("VubOUT").CompareTo(dataset->GetName()) == 0) {idx=3; Lumino = LUMI_SIGNAL;}
  if(TString("VcbOth").CompareTo(dataset->GetName()) == 0) {idx=4; Lumino = LUMI_GENERIC;}
  if(TString("Vcb").CompareTo(dataset->GetName()) == 0 ) {idx=5; Lumino = LUMI_GENERIC;}

  mesIdx++; cout << "MESINDEX "<< mesIdx << endl;

  if( SAVEPDFTREE ) {
    cout << "SCONTROLLAMI dataset " << dataset->GetName() << " luminositi " << Lumino << " mesIdx " << mesIdx << " cut " << simply << endl;
    FillPDFTree(model,mesIdx++,Lumino,idx);
  }

  // clean up
  delete datared;  datared  = 0;
  delete bdatared; bdatared = 0;

  // clean up model and associated pdfs/RooRealVars

  // get list of parameters and delete them
  RooArgSet* params = model->getParameters(RooArgSet());

  TIterator* iter = params->createIterator();
  RooAbsArg* var = 0;
  while ((var=(RooAbsArg*)iter->Next())) {
    if (std::string(var->GetName()) == "mes") continue;
    if (_debug > 1) std::cout << "Deleting variable " << var->ClassName() << "::" << var->GetName() << std::endl;
    delete var;
  }
  delete params;;

  // get list of pdfs and delete them
  RooArgSet* comps = model->getComponents();

  iter = comps->createIterator();
  RooAbsArg* pdf = 0;
  while ((pdf=(RooAbsArg*)iter->Next())) {
    if (_debug > 1) std::cout << "Deleting component " << pdf->ClassName() << "::" << pdf->GetName() << std::endl;
    delete pdf;
  }
  delete iter; delete comps;

  model = 0;

  // done

  return pD;
}

  // ----------------------------------------------------------------------
  double VirClass::dBinomial(double n, double N) {
  if ((N <= 0) || (n < 0.)) return 0.;
  double w = n/N;
  return TMath::Sqrt(TMath::Abs(w*(1-w)/N));
}

void VirClass::evaluatePeakingBackground(Int_t comb, bool kinematic_scan){
  
  vector<double> fitresults, initpars; //will it work without the scope resolutor std::?
  char simply[100];
  char *cut[5];

  TString mesRangeCut = (FITALLMESRANGE ? "":" && mes > 5.27");
  cout<<" MESRANGECUT = "<<mesRangeCut.Data()<<endl;

  cut[0]="lepYes==1";
  cut[1]="lepYaSe==1";
  cut[2]="flavB==3";
  cut[3]="flavB==4";
  cut[4]="flavB==5";

  c1 = new TCanvas("cc","cc",1273,900); //,1200,1000);
  TVector2 signal;
  RooDataSet *reduced=NULL;
  sprintf(simply,"%s%s",DIRNAME.Data(),"peaking_bkg_eval.txt");
  
  FILE *fout=fopen(simply,"a");

  Float_t mtchd,ratio,errratio,ntotal;

  c1->Divide(3,2);
  TVector2 *tmpsignal, fitcorr_bch_SL, fitcorr_bneuos_SL, fitcorr_bneuss_SL, fitcorr_bch_allcut, fitcorr_bneuos_allcut, fitcorr_bneuss_allcut;

  TObjArray holder;
  holder.Add(&fitcorr_bch_SL);     //holder[0]
  holder.Add(&fitcorr_bneuos_SL);  //holder[1]
  holder.Add(&fitcorr_bneuss_SL);  //holder[2]
  holder.Add(&fitcorr_bch_allcut); //holder[3]
  holder.Add(&fitcorr_bneuos_allcut); //holder[4]
  holder.Add(&fitcorr_bneuss_allcut); //holder[5]
  
  for(Int_t k=0;k<2;k++){ //Loop for SL cut / All cuts
    initpars = (k==0) ? mespstarMC : mespstarcuts;
    
    for(Int_t i=2;i<5;i++){  //Loop for bch, bos, bss
      c1->cd(i-1+3*k);
      sprintf(simply,"%s && %s %s",cut[k],cut[i],mesRangeCut.Data());
      
      reduced = (RooDataSet*)pstarsample->reduce(simply);
      ntotal = reduced->numEntries(kTRUE);
      delete reduced;
      
      sprintf(simply,"%s && %s",cut[k],cut[i]);
      signal = sighistounb(pstarsample,Vmes,fitresults, initpars, 60000.,  15000., simply, 0); 
      
      sprintf(simply,"%s && %s && trumtch ==2 %s",cut[k],cut[i],mesRangeCut.Data()); //selects only truth-matched events && mes>5.27
      reduced = (RooDataSet*)pstarsample->reduce(simply);
      mtchd = reduced->numEntries(kTRUE); // Check for reweighting case
      cout<<"TRUTHMATCHED "<<mtchd<<" NTOTAL "<<ntotal<<endl;
      
      //Check for 0
      if(TMath::Abs(signal.X())<1) {
	ratio=1; errratio=0;
      } else {
	ratio=mtchd/(signal.X());
	errratio = ratio*sqrt(1/mtchd*(1-mtchd/ntotal)+signal.Y()*signal.Y()/( signal.X()*signal.X()) - 
			      2*mtchd/ntotal*sqrt(1/mtchd*(1-mtchd/ntotal))*signal.Y()/signal.X());
      }
      
      tmpsignal = dynamic_cast<TVector2*>(holder[i-2+3*k]);  // global index-1 because holder starts from 0 !
      tmpsignal->Set(ratio,errratio);
      
      fprintf(fout,"%s %f +- %f\n",simply,ratio,errratio);
      //Antonio 1 mar 2007
      delete reduced;
      reduced=NULL;
    }
  }
  
  cout<<"Saving canvas with plots of peaking background evaluation with SL/AC cuts..."<<endl;
  sprintf(simply,"%s%s",DIRNAME.Data(),"peakeval.eps");
  c1->Print(simply);
    
  delete c1; c1 = NULL;
  
  pkgbkgcorr_SL.push_back(fitcorr_bch_SL);
  pkgbkgcorr_SL.push_back(fitcorr_bneuos_SL);
  pkgbkgcorr_SL.push_back(fitcorr_bneuss_SL);
  pkgbkgcorr_AC.push_back(fitcorr_bch_allcut);
  pkgbkgcorr_AC.push_back(fitcorr_bneuos_allcut);
  pkgbkgcorr_AC.push_back(fitcorr_bneuss_allcut);
  
  if(kinematic_scan){               // KINEMATIC VARIABLE SCAN CASE

    gStyle->SetPaperSize(4.*20., 4.*26.);
    c1 = new TCanvas("cc","cc",1273,900);
    c1->Divide(6,6);

    if(pkgbkgcorr_AC.size()!=0)
      pkgbkgcorr_AC.resize(0);
    
    vector<double> dummyVector;
    
    for(Int_t i=2;i<5;i++){  //Loop for bch, bos, bss
      //get shape for PDF
      if(comb){
	c1->cd( (i-2)*(xB1.size())+1);
	sprintf(simply,"%s && %s",cut[1],cut[i]);
      } else {
	c1->cd( (i-2)*nB+1 ); 
	sprintf(simply,"%s && %s && chop < %.3f && chop > %.3f",cut[1],cut[i],chophighB,choplowB);
      }
      
      signal = sighistounb(pstarsample,Vmes,fitresults, mespstarcuts, 60000.,  15000., simply, 0); 

      Int_t topbin = comb ? xB1.size() : nB;
      
      for (Int_t iBin=1; iBin<topbin; iBin++) {  
	c1->cd( (i-2)*topbin+iBin+1);  
	
	if(comb)
	  sprintf(simply,"%s && %s && mx > %.3f && mx < %.3f %s",cut[1],cut[i],xB1[iBin-1],xB1[iBin],mesRangeCut.Data());
	else
	  sprintf(simply,"%s && %s && chop > %.3f && chop < %.3f %s",cut[1],cut[i],chopB1[iBin-1],chopB1[iBin],mesRangeCut.Data());
      
	reduced = (RooDataSet*)pstarsample->reduce(simply);
	ntotal = reduced->numEntries(kTRUE);
	delete reduced;

	//sprintf(simply,"%s && %s && chop > %.3f && chop < %.3f",cut[1],cut[i],chopB1[iBin-1],chopB1[iBin]);
	if(comb)
	  sprintf(simply,"%s && %s && mx > %.3f && mx < %.3f",cut[1],cut[i],xB1[iBin-1],xB1[iBin]);
	else
	  sprintf(simply,"%s && %s && chop > %.3f && chop < %.3f",cut[1],cut[i],chopB1[iBin-1],chopB1[iBin]);
	signal = sighistounb(pstarsample,Vmes,dummyVector, fitresults, 60000.,  15000., simply, 1); 
	
	if(comb)
	  sprintf(simply,"%s && %s && trumtch == 2 && mx > %.3f && mx < %.3f %s",cut[1],cut[i],xB1[iBin-1],xB1[iBin],mesRangeCut.Data());
	else
	  sprintf(simply,"%s && %s && trumtch == 2 && chop > %.3f && chop < %.3f %s",cut[1],cut[i],chopB1[iBin-1],chopB1[iBin],mesRangeCut.Data());
	
	reduced = (RooDataSet*)pstarsample->reduce(simply);
	mtchd = reduced->numEntries(kTRUE); // Check for reweighting case
	cout<<"kinematic scan: TRUTHMATCHED "<<mtchd<<" NTOTAL "<<ntotal<<endl;
	if(TMath::Abs(signal.X())<1.) {
	  ratio=1; errratio=0;
	} else {
	  ratio=mtchd/(signal.X());
	  errratio = ratio*sqrt(1/mtchd*(1-mtchd/ntotal)+signal.Y()*signal.Y()/( signal.X()*signal.X()) - 
				2*mtchd/ntotal*sqrt(1/mtchd*(1-mtchd/ntotal))*signal.Y()/signal.X());
	}
	
	pkgbkgcorr_AC.push_back(TVector2(ratio,errratio));
	fprintf(fout,"%s %f +- %f\n",simply,ratio,errratio);
	delete reduced; reduced=NULL;
      }
    }
    
    cout<<"Saving canvas with plots of peaking background evaluation MX SCAN..."<<endl;
    sprintf(simply,"%s%s",DIRNAME.Data(),"peakeval_KineScan.eps");
    c1->Print(simply); 
    delete c1; c1 = NULL;
  }
  
  fclose(fout);
  gStyle->SetPaperSize(20.,26.);
  
  //========================================================
  //This section randomizes peaking background evaluation.
 
  if(SEME!=0){
    float corr;
    UInt_t seme=SEME;
    Int_t topbin = comb ? xB1.size() : nB; 
    topbin-=1;
   
    cout<<" SEED for randomization of peaking background evaluation: "<<seme<<endl;
    cout<<" NOTICE: the randomized peaking background evaluation are NOT written into peaking_bkg_eval.txt text file ";
    cout<<" they are only written into vubfit.out "<<endl;

    TRandom rndm(seme);

    for(UInt_t i=0; i<pkgbkgcorr_SL.size(); i++){
      corr = SPrandomized(pkgbkgcorr_SL[i].X(),pkgbkgcorr_SL[i].Y(),pkgbkgcorr_SL[i].Y(),rndm,seme);
      std::cout << "randomizing peaking background evaluation on SL cuts " << (i==0 ? "charged " :  (i==1 ? "neutrals OS " : "neutrals SS")) 
		<< " : new value is " << corr << std::endl;
      pkgbkgcorr_SL[i].Set((float)corr,(float)pkgbkgcorr_SL[i].Y());  //we have new central value, old error (error is not used...);
    }

    for(UInt_t i=0; i<pkgbkgcorr_AC.size(); i++){
      cout<<"BEFORE CORRECTION "<<i<<" "<<pkgbkgcorr_AC[i].X()<<endl;
      corr = SPrandomized(pkgbkgcorr_AC[i].X(),pkgbkgcorr_AC[i].Y(),pkgbkgcorr_AC[i].Y(),rndm,seme);
      std::cout << "randomizing peaking background evaluation on All Cuts ";
      
      //HORRIBLE IMPLEMENTATION!!! TO TEST OUTPUT

      if(pkgbkgcorr_AC.size() > 3) { //this means kinematic scan
	if(i < topbin)  cout <<"charged: bin n' "<<i+1;
	if(i >= topbin && i < 2*topbin) cout<<" neutrals OS: bin n' "<<i-topbin+1;
	if(i >= 2*topbin) cout<<" neutrals SS: bin n' "<<i-2*topbin+1;
      } else 
	cout<< i==0 ? "charged: " : ((i==1) ? "neutrals OS: " : "neutrals SS: ");
      
      cout<<" new value is "<<corr<<endl;
      
      pkgbkgcorr_AC[i].Set((float)corr,(float)pkgbkgcorr_AC[i].Y());  //we have new central value, old error (error is not used...);
    }
  }
  //=======================================================
}

void VirClass::FitMes(const char* comp, int mcat, int signalUnfolding, bool fixsigpeakratio)
{

  TStopwatch timer; // for timing purpose  

  vector<double> fitResults[3]; //3: one for each charge (bch, bos, bss);
  
  std::map<std::string, RooDataSet*> dataSets; // xxx maybe move somewhere more general
  dataSets["data"] = datadata;
  if (signalUnfolding == 1) {
    dataSets["vubin"]  = datavubin; 
    dataSets["vubout"] = datavubout;
    dataSets["vcboth"] = datavcboth;
  } else {
    dataSets["vub"]    = datamcvub;
    dataSets["vcb"]    = datamcvcb; 
    dataSets["other"]  = datamcoth;
  }

  if (dataSets.find(comp) == dataSets.end()) {
    std::cout << "No dataset with name " << comp << " found! Doing nothing!" << std::endl;
    return;
  }
    

  //CB get the signal/peaking background ratios for the various datasets in bins of the kinematic variables
  //CB do nothing if event counting is enabled

  if(fixsigpeakratio && !countMC) getSOverPk(comp, mcat, signalUnfolding); 

  //---------------------------------------------------------

  //  TCanvas *c2  = new TCanvas("c2"," ",200,10,1200,1000); 

  TVector2 signalsig;
  
  char simply[200],name[100];
  double sigs[nB-1]; double errsigs[nB-1];

  int catnum = mcat ? 5 : 1;  // Multiplicity categories
  int matchMC = countMC ? 2: 0;

  std::vector<double> dummyVector;
  Double_t corr;

  // Calculating default fits parameters.

  for(Int_t jFlav = 3; jFlav < 6; jFlav++){ // loop on neutrals and charged.

    c1 = new TCanvas("c1"," ",1414,1000);//,200,10,1200,1000); 
    c1->Clear();
    
    // The acutal number of pads in this Canvas depends on the number of bins in the kinematic variable:
    // see VirClass.cc for nB; 
    // We need at least 11 (10+1) for m_x, 14 (13+1) for q^2 and 9 (8+1) for P+. However, we need 19 with the current binning for the unfolding analysis.
    // This following division is oversized for each kinematic variable but could not be sufficient if we
    // change the default binning.

    c1->Divide(5, 4);
    c1->cd(1); 

    // Mes Fit on all cuts distribution without kinematic cut. This is needed to get PDF parameters for the kinematic 
    // variable cut. Neither MIXCORR nor SUBTRACTPEAKING needed. We do this for each jFlav, that's why this is the main loop.

    sprintf(simply,"%s%.3f%s%.3f%s%d%s","(chop>",choplowB,") && chop<",chophighB," && flavB== ",jFlav," && lepYaSe==1");
    if(signalUnfolding == 1){
      if (std::string(comp) == "vubin") 
	signalsig = sighistounb(datavubin,  Vmes, fitResults[jFlav-3], mesvubcuts, 2500., 200., simply, USECB);
      else if (std::string(comp) == "vubout") 
	signalsig = sighistounb(datavubout, Vmes, fitResults[jFlav-3], mesvubcuts, 2500., 200., simply, USECB);
      else if (std::string(comp) == "vcboth") 
	signalsig = sighistounb(datavcboth, Vmes, fitResults[jFlav-3], mesothcuts,  800., 180., simply, USECB); //o mesvcboth?
    } else {
      if (std::string(comp) == "vub") 
	signalsig = sighistounb(datamcvub, Vmes, fitResults[jFlav-3], mesvubcuts, 2500., 200., simply, USECB);
      else if (std::string(comp) == "vcb") 
	signalsig = sighistounb(datamcvcb, Vmes, fitResults[jFlav-3], mesvcbcuts, 4000., 700., simply, USECB);
      else if (std::string(comp) == "other") 
	signalsig = sighistounb(datamcoth, Vmes, fitResults[jFlav-3], mesothcuts,  800., 180., simply, USECB);
    }
    
    if(std::string(comp) == "data") {
      std::cout << "fitting mes data " << std::endl;
      signalsig = sighistounb(datadata, Vmes, fitResults[jFlav-3], mesdatacuts, 2000., 1000., simply, USECB);
      std::cout << "finished fitting mes data " << std::endl;

      std::cout << "ALLCUTSTUDY: SERVICE " << SERVICE << " simply " << simply << " " << signalsig.X() << " +- " << signalsig.Y() << " No PKGBKG subtracton!!" << endl;

    }

    // And now the 1d plane is filled

    for (int k = 1; k < catnum+1; k++) {
      for (int iBin = 1; iBin < nB; iBin++) {  

        c1->cd(iBin+1);

	// prepare the cut
	sprintf(simply,"%s%.3f%s%.3f%s%d%s","(chop>",chopB1[iBin-1],") && (chop<",chopB1[iBin],") && (flavB==",jFlav,") && lepYaSe==1");
	
	if (mcat) { sprintf(simply,"%s%s%d%s", simply," && (multcat== ",k,")"); }
	
	// default parameters
	double nSignalStart = 200., nBackgroundStart = 1.;
	// exceptions from these (please add more here if needed)
	// if (signalUnfolding!= 1 && TString(comp) == "vcb") { nSignalStart = 200; nBackgroundStart = 1.; }
		
	if(fixsigpeakratio) {
	  //CB always compute data corrections
	  //CB compute MC corrections ounly if we are not counting events
	  if((std::string(comp) == "data") || (!countMC)) setActiveCorrection(comp, signalUnfolding, iBin);
	}
	
	if (countMC && std::string(comp) != "data")
	  signalsig = sighistounb(dataSets[comp], Vmes, dummyVector, fitResults[jFlav-3], nSignalStart, nBackgroundStart, simply, 1, 0, matchMC);
	 else 
	  signalsig = sighistounb(dataSets[comp], Vmes, dummyVector, fitResults[jFlav-3], nSignalStart, nBackgroundStart, simply, 1, fixsigpeakratio);
	
	// getting fit result: number of events and error 
	sigs[iBin-1] = errsigs[iBin-1] =  0.;
	
	if(signalsig.X()>0.00001) {
	  sigs[iBin-1] = signalsig.X();
	  errsigs[iBin-1] =  signalsig.Y();
        }
	
	//apply correction for peaking background evaluation on data, if requested
	if(std::string(comp) == "data" && SUBTRACTPEAKING){

	  //retrieve the peaking background evaluation from memory: check if mx scan performed
	  if(pkgbkgcorr_AC.size() > 3) 
	    corr = pkgbkgcorr_AC[(jFlav-3)*(nB-1)+iBin-1].X();
	  //  switch(jFlav){
	  // 	    case 3 : corr = pkgbkgcorr_AC[iBin-1].X(); break;
	  // 	    case 4 : corr = pkgbkgcorr_AC[]; break;
	  // 	    case 5 : corr = pkgbkgcorr_AC[]; break;
	  // 	    default: corr = pkgbkgcorr_AC[nB-1+iBin-1].X(); break;
	  // 	    }
	  else
	    corr = pkgbkgcorr_AC[jFlav-3].X();
	  // 	    switch(jFlav){
	  // 	    case 3 : corr = pkgbkgcorr_AC[0].X();  break;
	  // 	    case 4 : corr = pkgbkgcorr_AC[1].X();  break;
	  // 	    case 5 : corr = pkgbkgcorr_AC[2].X();  break;
	  // }
	  
	  cout<<"Subtracting peaking background: correction "<<corr<<endl;
	  
	  sigs[iBin-1]*=corr;
	  errsigs[iBin-1]*=corr;
	}
	std::cout << "ALLCUTSTUDY: comp "<<comp<<" SERVICE "<<SERVICE<<" simply "<<simply<<" "<<signalsig.X()<<" +- "<<signalsig.Y()<<endl;

	// put number of signal events and error into result grid
	
        if(mcat) 
          sprintf(name,"%s%d%s%d",comp,jFlav,"chop",k);
	else 
          sprintf(name,"%s%d%s",comp,jFlav,"chop");
	
        ((TH1D*)gDirectory->Get(name))->SetBinContent(iBin, sigs[iBin-1]);
        ((TH1D*)gDirectory->Get(name))->SetBinError(iBin, errsigs[iBin-1]);
      }
    }

    // generate plots
    sprintf(name,"%s%s%s%s%d%s",DIRNAME.Data(),PREFIXOUT.Data(),"mES_",comp,jFlav,".eps");
    gStyle->SetPaperSize(4.*20., 4.*26.);
    c1->Print(name);
    delete c1; c1 = NULL;
  }  // jFlav Loop
  
  
  if(BTYPE != 2) {
    if( MIXCORR != 0 ) {
      const Float_t chid = 0.188;
      //Do the Mixing correction here and not later beacuse of Crossfeed corrections and to not break the code.
      sprintf(name,"%s%s",comp,"4chop");
      sprintf(simply,"%s%s",comp,"5chop");
      
      for(Int_t ix = 0; ix < ((TH1*)gDirectory->Get(name))->GetNbinsX(); ix++)
	for(Int_t iy = 0; iy < ((TH1*)gDirectory->Get(name))->GetNbinsY(); iy++)
	  cout << "before Mixing Correction flavB 4 bin (" << ix << "," << iy <<")= " << ((TH1*)gDirectory->Get(name))->GetBinContent(ix,iy) << endl;

      ((TH1*)gDirectory->Get(name))->Scale((1-chid)/(1-2*chid));
      ((TH1*)gDirectory->Get(name))->Add( (TH1*)gDirectory->Get(simply),(-chid/(1-2*chid)) );
      
      for(Int_t ix = 0; ix < ((TH1*)gDirectory->Get(name))->GetNbinsX(); ix++)
	for(Int_t iy = 0; iy < ((TH1*)gDirectory->Get(name))->GetNbinsY(); iy++)
	  cout << "and after Mixing Correction flavB 4 bin (" << ix << "," << iy <<")= " << ((TH1*)gDirectory->Get(name))->GetBinContent(ix,iy) << endl;
    }

    sprintf(name,"%s%s",comp,"3chop");
    sprintf(simply,"%s%s",comp,"4chop");
    
    ApplyCrossFeedCalculations(TString(dataSets[comp]->GetName()),TString("lepYaSe == 1"),((TH1*)gDirectory->Get(name)),((TH1*)gDirectory->Get(simply)));
  }

  sprintf(name,"%s%s",comp,"4chop");
  cout << "DEBUGGONE after " << ((TH1D*)gDirectory->Get(name))->Integral() << endl;
    
  // reset the standard paper size.
  gStyle->SetPaperSize(20., 26.);

    // print out timer
  std::cout << "Timer for fitMes: "; timer.Print();

  return;
}


//! wrapper function around binned/unbinned fitting
TVector2 VirClass::sighistounb(RooDataSet *Adata, RooRealVar *Ax, std::vector<double>& results, const std::vector<double>& inputPar, const double AnSIG, const double AnBKG, const char* Asimply, int fixpar,bool fixsigpeakratio, int jmatch)
{
  mesData* themes = 0;

  if (BINNED) { //BINNED FIT
    
    ((TH1D*)gDirectory->Get("dummy"))->Reset();
    Adata->fillHistogram(((TH1D*)gDirectory->Get("dummy")),RooArgList(*Ax),Asimply);
    
    recoilAnalysis b;
    double thesigma = -1111111;
    double themean = -1111111;
    double theargus = -1111111;
    double thealpha = -1111111;
    double then = -1111111;


    
    if (fixpar > 0) {
      if (FIXMEANVALUE) themean  = inputPar[iMean];
      if (FIXSIGMA)     thesigma = inputPar[iSigma];
      if (FIXCB1)       thealpha = inputPar[iAlpha];
      if (FIXCB2)       then     = inputPar[iN];
      if (FIXARGUS1)    theargus = inputPar[iArgus];
    }

    themes = b.vubMes(((TH1D*)gDirectory->Get("dummy")), results[VirClass::iMean], results[VirClass::iSigma], results[VirClass::iAlpha], results[VirClass::iN],
		      1, fixpar, themean, thesigma, thealpha, then, theargus);

    std::cout << "fit result: " << themes->theSig() << " +/- " << themes->theErrSig() << std::endl;
    
  } else { //UNBINNED FIT BELOW...
    
    if( READPDFTREE ) { 
      cout  << "ReadingPdfTree mesIdx " << mesIdx << " with cut " << Asimply << endl;
      Adata = RetrieveDataset(mesIdx);
      char *tmpo = "mes > 5.2"; ///fake cut to make everything work
      mesIdx++;
      if (Adata == NULL) {
	cout << " !!!! ------- !!!! << Dataset not found in file, returnig 0 +- 0 yields!!! "  << endl;
	return TVector2(0,0); 
      }
      else
	themes = vubMesUnb(Adata,Ax, results, 1, fixpar, inputPar, AnSIG, AnBKG, tmpo, fixsigpeakratio, jmatch);
    } else
        themes = vubMesUnb(Adata,Ax, results, 1, fixpar, inputPar, AnSIG, AnBKG, Asimply, fixsigpeakratio, jmatch);

    if( READPDFTREE ) delete Adata;

    std::cout << "fit result: " << (FITALLMESRANGE ? "" : "(with rescaled yields for mes > 5.27) ") << themes->theSig() << " +/- " << themes->theErrSig() << std::endl;
    std::cout << "====================================> END OF MES FIT <==========================="<<endl;
  } // if (BINNED)
  
  TVector2 temp(themes->theSig(),themes->theErrSig()); 
  
  // ANTONIO 2 mar 2007
  // we don'tneed anymore mesData... so release its memory!!!

  delete themes;
   return temp;
}

void VirClass::chargeCorr(int su, int comb)
{
  std::vector<double> fitResults;
  char simply[100], line[200];

  int matchMC = countMC ? 2: 0;
  
  //Computes statistical correction for B0/B+ events ratio
  TVector2 signalsig;
  c1  = new TCanvas("c2"," ",200,10,1273,900); 
  c1->Clear();
  c1->Divide(4, 2);

  //----------leptondatabch-----------
  c1->cd(1);    
  sprintf(simply,"(flavB==3) && lepYes==1");
  std::vector<double> mesNslTmp(mesNsl); mesNslTmp[3] = 5.;
  if(!SMALLSTATCORR)
    signalsig = sighistounb(datadata, Vmes, fitResults, mesNslTmp,  20000, 10000, simply, USECB);
  else{
    sprintf(simply,"(flavB==3) && lepYaSe==1");
    signalsig = sighistounb(datadata, Vmes, fitResults, mesdatacuts,  20000, 10000, simply, USECB);
  }
  double nbchdata = signalsig.X();
  //if(BINNED){}else{xframe->Draw();};
  //----------leptondatabos------------
  c1->cd(2);    
  sprintf(simply,"(flavB==4) && lepYes==1");
  if(!SMALLSTATCORR)
    signalsig = sighistounb(datadata, Vmes, fitResults, mesNslTmp,  10000, 3000, simply, USECB);
  else{
    sprintf(simply,"(flavB==4) && lepYaSe==1");
    signalsig = sighistounb(datadata, Vmes, fitResults, mesdatacuts,  10000, 3000, simply, USECB);
  }
  double nb0osdata = signalsig.X();

  c1->cd(3);    
  sprintf(simply,"(flavB==5) && lepYes==1");
  if(!SMALLSTATCORR)
    signalsig = sighistounb(datadata, Vmes, fitResults, mesNslTmp,  10000, 3000, simply, USECB);
  else{
    sprintf(simply,"(flavB==5) && lepYaSe==1");
    signalsig = sighistounb(datadata, Vmes, fitResults, mesdatacuts,  10000, 3000, simply, USECB);
  }
  double nb0ssdata = signalsig.X();

  if(matchMC || SUBTRACTPEAKING){
    cout<<" Subtracting peaking background: correction SL charged "<<pkgbkgcorr_SL[0].X()<<" SL neutrals os ";
    cout <<pkgbkgcorr_SL[1].X()<<" SL neutrals ss "<<pkgbkgcorr_SL[2].X()<<endl;
    nbchdata *= pkgbkgcorr_SL[0].X();
    nb0osdata  *= pkgbkgcorr_SL[1].X();    
    nb0ssdata *= pkgbkgcorr_SL[2].X();
  }

  double nb0data = nb0osdata+nb0ssdata;

  //if(BINNED){}else{xframe->Draw();};
  //if we count on MC we have to subtract peaking bkgd from fit on data...

  //----------vcbleptonmcbch------------
  c1->cd(4);    
  sprintf(simply,"(flavB==3) && lepYes==1");
  if(su ==1)
    signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 60000., 15000., simply, USECB, 0, matchMC);
  else {
    if(!SMALLSTATCORR)
      signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 60000., 15000., simply, USECB, 0, matchMC);
    else{
      sprintf(simply,"(flavB==3) && lepYaSe==1");
      signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbcuts, 60000., 15000., simply, USECB, 0, matchMC);
    }
  }
  double nbchvcb = signalsig.X();
  //if(BINNED){}else{xframe->Draw();};
  //----------vcbleptonmcbos------------
  c1->cd(5);  
  sprintf(simply,"(flavB==4 || flavB==5) && lepYes==1");
  if(su ==1)
    signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 30000., 7000., simply, USECB, 0, matchMC);
  else {
    if(!SMALLSTATCORR)
      signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 30000., 7000., simply, USECB, 0, matchMC);
    else{
      sprintf(simply,"(flavB==4 || flavB==5) && lepYaSe==1");
      signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbcuts, 30000., 7000., simply, USECB, 0, matchMC);
    }
  }
  double nb0vcb = signalsig.X();
  //if(BINNED){}else{xframe->Draw();};
  //
  //CB THIS NEEDS TO BE CHECKED...SHOULD WE ADD VUBIN+VUBOUT?!? FOR THE MOMENT I LEAVE ONLY VUBIN...
  //
  //----------vubleptonmcbch-----------    
  c1->cd(6);  
  sprintf(simply,"(flavB==3) && lepYes==1");
  if(su ==1)
    signalsig = sighistounb(datavubin, Vmes, fitResults, mesvubMC,  3000, 800,  simply, USECB, 0, matchMC);
  else {
    if(!SMALLSTATCORR)
      signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubMC,  3000, 800,  simply, USECB, 0, matchMC);
    else {
      sprintf(simply,"(flavB==3) && lepYaSe==1");
      signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubcuts,  3000, 800,  simply, USECB, 0, matchMC);
    }
  }
  double nbchvub = signalsig.X();
  //if(BINNED){}else{xframe->Draw();};
  //----------vubleptonmcbos----------- 
  c1->cd(7);    
  sprintf(simply,"(flavB==4 || flavB==5) && lepYes==1");
  if(su ==1)
    signalsig = sighistounb(datavubin, Vmes, fitResults, mesvubMC,  1600, 500, simply, USECB, 0, matchMC);
  else {
    if(!SMALLSTATCORR)
      signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubMC,  1600, 500, simply, USECB, 0, matchMC);
    else {
      sprintf(simply,"(flavB==4 || flavB==5) && lepYaSe==1");
      signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubcuts,  1600, 500, simply, USECB, 0, matchMC);
    }
  }
  double nb0vub = signalsig.X();
  //if(BINNED){}else{xframe->Draw();};
  //Print out the mES fits
  sprintf(line,"%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"mES_ChCorr.eps");
  gStyle->SetPaperSize(3.*20., 3.*26.);
  c1->Print(line);
  gStyle->SetPaperSize(20., 26.);

  delete c1; c1=NULL;

  // Commented out all those quantities already computed in computeChargeCorr!
  //  double ratiobchb0 = nbchdata/nb0data;
  //  double ratiobchb0vcb = nbchvcb/nb0vcb;
  //  double ratiobchb0vub = nbchvub/nb0vub;
  //  correctionratiovcb = ratiobchb0/ratiobchb0vcb;
  //  correctionratiovub = ratiobchb0/ratiobchb0vub; //OLD CORRECTION RATIO CALCULATION: in principle we don't want
  // to apply the correction on vub as on data (which is actually vcb)
  // ! ! ! ! ! ! ! ! ! ! ! ! WARNING !!!!!!!!!!!!!!!!!!!!
  // WHEN we are NOT fitting MC (thas has for all components the same file) we gotta correct for ratios of Branching
  // fraction and number of B+ and B0 that is actually on each (vub, generic) component
  // THIS STILL NEED TO BE IMPLEMENTED!!!!!! BE CAREFUL WHEN IMPLEMENTING STUFF ON DATA 

  //  correctionratiovub = correctionratiovcb * ratiobchb0vub/ratiobchb0vcb;

  cout << "correctionratiovcb " << correctionratiovcb << endl;
  cout << "correctionratiovub " << correctionratiovub << endl;
  //  cout << "correctionratiovubOUT " << correctionratiovubout <<endl;
  //  cout << " WARNING CORRECTIONRATIO STILL DOES NOT WORK ON DATA"<<endl;

  // WARNING VERY DANGEROUS REMOVE the following isfitMC()
  
//   if(FIXCORRRATIO){
//     correctionratiovubout=1;
//     correctionratiovub=1;
//     correctionratiovcb=1;
//      cout<<" ! ! ! ! ! W A R N I N G ! correction ratio set to 1 by hand. This is not correct"<<endl;
//   }

}

void VirClass::computeNSLandEfficiencies(int su, int comb) {
  // // ////////////////////////////add mixing Mes
 
  std::vector<double> fitResults;
  char simply[100], line[200];
  int matchMC = countMC ? 2: 0;
  TVector2 signalsig;

  TCanvas *c1 = new TCanvas("c2"," ",200,10,1414,1000); 
  c1->Clear();
  c1->Divide(4, 5);
  double chid = 0.188;

  vubmcSB = errvubmcSB = 0;
  ///////////////////////   NSL  //////////////////////////////
  c1->cd(1); 
  //----lepton data bch----
  sprintf(simply,"(flavB==3) && lepYes==1");
  signalsig = sighistounb(datadata, Vmes, fitResults, mesNsl,  40000, 20000, simply, USECB);
  std::cout << "Fitting semileptonic events on DATA3!!! :: " <<  fitResults << std::endl;
  double data3 = signalsig.X();                   double   errdata3 = signalsig.Y();     
  
  //if(BINNED){}else{xframe->Draw();};

  c1->cd(2); 
  //----------lepton data bos------------
  sprintf(simply,"(flavB==4) && lepYes==1");
  signalsig = sighistounb(datadata, Vmes, fitResults, mesNsl,  40000, 20000, simply, USECB);
  std::cout << "Fitting semileptonic events on DATA4!!! :: " <<  fitResults << std::endl;
  double data4 = signalsig.X();                   double   errdata4 = signalsig.Y();     
  //if(BINNED){}else{xframe->Draw();};

  c1->cd(3); 
  //----------lepton data bss------------
  sprintf(simply,"(flavB==5) && lepYes==1");
  signalsig = sighistounb(datadata, Vmes, fitResults, mesNsl,  40000, 20000, simply, USECB);
  std::cout << "Fitting semileptonic events on DATA5!!! :: " << fitResults << std::endl;
  double data5 = signalsig.X();                   double     errdata5 = signalsig.Y();    
  //if(BINNED){}else{xframe->Draw();};

  /// subtract peaking bkg from fit on data

  if(SUBTRACTPEAKING){
    cout << "Subtracting peaking background: correction SL charged " << pkgbkgcorr_SL[0].X() << " correction SL neutrals " << pkgbkgcorr_SL[1].X() << endl;
    data3 *= pkgbkgcorr_SL[0].X();
    errdata3 *= pkgbkgcorr_SL[0].X();
    
    data4 *= pkgbkgcorr_SL[1].X();
    errdata4 *= pkgbkgcorr_SL[1].X();
    
    data5 *= pkgbkgcorr_SL[2].X();
    errdata5 *= pkgbkgcorr_SL[2].X();
  }

  if( MIXCORR == 0 ){
    tot = data3 + data4 +data5;
    errtot = sqrt(errdata3 * errdata3 + errdata4 * errdata4 + errdata5 * errdata5);
  } else {      
    tot = data3 + ((1-chid)/(1-2*chid)) * data4 - (chid/(1-2*chid)) * data5;
    errtot = sqrt(errdata3 * errdata3 +
		  ((1-chid)/(1-2*chid)) * ((1-chid)/(1-2*chid)) * errdata4 * errdata4 +
		  (chid/(1-2*chid)) * (chid/(1-2*chid)) * errdata5 * errdata5);

    cout<<"control:::::" << " data3  "<<data3<<"  errdata3  "<<errdata3<<" data4  "<<data4<<"  errdata4  "<<errdata4<<" data5  "<<data5<<"  errdata5  "<<errdata5<<endl;    
    cout<<"control:::::" << "           tot  "<<tot<<"  errtot  "<<errtot<<endl; 
  }     
  
  signalsig = ApplyCorrFactors(TVector2(data3,errdata3),TVector2(data4,errdata4),TVector2(data5,errdata5),true,TString(datadata->GetName()),"lepYes == 1",1);
  tot = signalsig.X();
  errtot = signalsig.Y();

  //------------------ EPSILON SL ----------------------------------------------------------------------------------
  c1->cd(4); 
  //----------vub lepton mc bch----------- 
  sprintf(simply,"(flavB==3) && lepYes==1");
  if(su == 1)
    signalsig = sighistounb(datavubin, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  else 
    signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  
  std::cout << "Fitting semileptonic events on vub mc3!!! :: " <<  fitResults << std::endl;
  double  vub3 = signalsig.X();                    double  errvub3 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};

  c1->cd(5); 
  //----------vub lepton mc bos----------- 
  sprintf(simply,"(flavB==4) && lepYes==1");
  if(su == 1)
    signalsig = sighistounb(datavubin, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  else 
    signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  
  std::cout << "Fitting semileptonic events on vub mc4!!! :: " << fitResults << std::endl;
  double  vub4 = signalsig.X();                    double errvub4 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};

  c1->cd(6);
  //----------vub lepton mc bss----------- 
  sprintf(simply,"(flavB==5) && lepYes==1");
  if(su == 1)
    signalsig = sighistounb(datavubin, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  else
    signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  
  std::cout << "Fitting semileptonic events on vub mc5!!! :: " << fitResults << std::endl;
  double  vub5 = signalsig.X();                    double  errvub5 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};
  
  if(MIXCORR == 0) {
    vubmc = vub3 + vub4 +vub5;
    errvubmc = sqrt(errvub3 * errvub3 + errvub4 * errvub4 + errvub5 * errvub5);
  } else {      
    vubmc = vub3 + ((1-chid)/(1-2*chid)) * vub4 - (chid/(1-2*chid)) * vub5;
    errvubmc = sqrt(errvub3 * errvub3 +
		    ((1-chid)/(1-2*chid)) * ((1-chid)/(1-2*chid)) * errvub4 * errvub4 +
		    (chid/(1-2*chid)) * (chid/(1-2*chid)) * errvub5 * errvub5);
    cout<<"control:::::"<<"vub3  "<<vub3<<"  errvub3  "<<errvub3<<" vub4  "<<vub4<<"  errvub4  "<<errvub4<<" vub5  "<<vub5<<"  errvub5  "<<errvub5<<endl;    
    cout<<"control:::::"<<"           vubmc  "<<vubmc<<"  errvubmc  "<<errvubmc<<endl;    
  }
  
  // ANTONIO 26/03/2007 Applying mixing correction AND correction ratio for fact calculation.
  RooDataSet *rdss = su == 1 ? datavubin : datamcvub;
  signalsig = ApplyCorrFactors(TVector2(vub3,errvub3),TVector2(vub4,errvub4),TVector2(vub5,errvub5),true,TString(rdss->GetName()),"lepYes == 1",correctionratiovub);
  vubmc = signalsig.X();
  errvubmc = signalsig.Y();

  //    //true number of vub MC events after lepton cut for efficiency calculation (only vub-generic)----vubleptonmceff
  vubmcleptforeff = vubmc;//         ---vuballcutsmceff
  
  //   //--------------NSL MC---------------------------------------------------------------------

  c1->cd(7);
  //----------vcb lepton mc bch----------- 
  sprintf(simply,"(flavB==3) && lepYes==1");
  if(su ==1)
    signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  else
    signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  
  std::cout << "Fitting semileptonic events on vcb mc3!!! :: " << fitResults << std::endl;
  double  vcb3 = signalsig.X();               double  errvcb3 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};

  c1->cd(8);
  //   //----------vcb lepton mc bos----------- 
  sprintf(simply,"(flavB==4) && lepYes==1");
  if(su ==1)
    signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  else
    signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  
  std::cout << "Fitting semileptonic events on vcb mc4!!! :: " << fitResults << std::endl;
  double  vcb4 = signalsig.X();                   double   errvcb4 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};

  c1->cd(9);
  //   //----------vcb lepton mc bss----------- 
  sprintf(simply,"(flavB==5) && lepYes==1");
  if(su ==1)
    signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  else
    signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  
  std::cout << "Fitting semileptonic events on vcb mc5!!! :: " << fitResults << std::endl;
  double  vcb5 = signalsig.X();                    double  errvcb5 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};

  if(MIXCORR==0){
    vcbmc = vcb3 + vcb4 +vcb5;
    errvcbmc = sqrt(errvcb3 * errvcb3 + errvcb4 * errvcb4 + errvcb5 * errvcb5);
  } else {      
    vcbmc = vcb3 + ((1-chid)/(1-2*chid)) * vcb4 - (chid/(1-2*chid)) * vcb5;
    errvcbmc = sqrt(errvcb3 * errvcb3 +
		    ((1-chid)/(1-2*chid)) * ((1-chid)/(1-2*chid)) * errvcb4 * errvcb4 +
		    (chid/(1-2*chid)) * (chid/(1-2*chid)) * errvcb5 * errvcb5);
    cout<<"control:::::"<<" vcb3 "<< vcb3 <<" errvcb3 "<< errvcb3 << " vcb4 " << vcb4 << " errvcb4 "<< errvcb4 <<" vcb5 " << vcb5 << " errvcb5 "<<errvcb5<<endl;    
    cout<<"control:::::"<<"           vcbmc "<<vcbmc<<" errvcbmc "<<errvcbmc<<endl;    
  }
  
  // ANTONIO 26/03/2007 Applying mixing correction AND correction ratio for fact calculation.
  signalsig = ApplyCorrFactors(TVector2(vcb3,errvcb3),TVector2(vcb4,errvcb4),TVector2(vcb5,errvcb5),true,TString(datamcvcb->GetName()),"lepYes == 1",correctionratiovcb);
  vcbmc = signalsig.X();
  errvcbmc = signalsig.Y();
  
  if(!su) {
    totmc = vcbmc;
    errtotmc = errvcbmc;
  }
  
  c1->cd(10);
  //----------oth lepton mc bch----------- 
  sprintf(simply,"(flavB==3) && lepYes==1");
  if(su ==1)
    signalsig = sighistounb(datavcboth, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  else
    signalsig = sighistounb(datamcoth, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  
  std::cout << "Fitting semileptonic events on oth mc3!!! :: " << fitResults << std::endl;
  double  oth3 = signalsig.X();               double  erroth3 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};

  c1->cd(11);
  //   //----------vcb lepton mc bos----------- 
  sprintf(simply,"(flavB==4) && lepYes==1");
  if(su ==1)
    signalsig = sighistounb(datavcboth, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  else
    signalsig = sighistounb(datamcoth, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  
  std::cout << "Fitting semileptonic events on oth mc4!!! :: " << fitResults << std::endl;
  double  oth4 = signalsig.X();                   double   erroth4 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};

  c1->cd(12);
  //   //----------vcb lepton mc bss----------- 
  sprintf(simply,"(flavB==5) && lepYes==1");
  if(su ==1)
    signalsig = sighistounb(datavcboth, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  else
    signalsig = sighistounb(datamcoth, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  
  std::cout << "Fitting semileptonic events on oth mc5!!! :: " << fitResults << std::endl;
  double  oth5 = signalsig.X();                    double  erroth5 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};

  double othtot = 0;
  double errothtot = 0;

  if(MIXCORR==0){
    othtot = oth3 + oth4 +oth5;
    errothtot = sqrt(erroth3 * erroth3 + erroth4 * erroth4 + erroth5 * erroth5);
  } else {      
    othtot = oth3 + ((1-chid)/(1-2*chid)) * oth4 - (chid/(1-2*chid)) * oth5;
    errothtot = sqrt(erroth3 * erroth3 +
		     ((1-chid)/(1-2*chid)) * ((1-chid)/(1-2*chid)) * erroth4 * erroth4 +
		     (chid/(1-2*chid)) * (chid/(1-2*chid)) * erroth5 * erroth5);
  }
  if(su == 1){
    totmc = othtot;       // totmc is Vcb+Oth
    errtotmc = errothtot;
  } else {
    totmc += othtot;      // totmc was vcb only, here we sum other component
    errtotmc = sqrt(errothtot*errothtot + errtotmc * errtotmc);
  }
  cout<<"control:::::"<<" oth3 " << oth3 << " erroth3 " << erroth3 << " oth4 " << oth4 << " erroth4 " << erroth4 << " oth5 " << oth5 << " erroth5 " << erroth5 << endl;    
  cout<<"control:::::"<<"          othtot  "<<othtot<<"  errothtot "<<errothtot<<endl;    
  cout<<"control:::::"<<"           totmc  "<<totmc<<"  errtotmc  "<<errtotmc<<endl;    

  // ANTONIO 26/03/2007 Applying mixing correction AND correction ratio for fact calculation.
  
  if( su == 1 )
    signalsig = ApplyCorrFactors(TVector2(oth3,erroth3),TVector2(oth4,erroth4),TVector2(oth5,erroth5),true,"Vcb","lepYes == 1",correctionratiovcb);
  else {
    double tmp3 = vcb3+oth3; double errtmp3 = sqrt(errvcb3*errvcb3+erroth3*erroth3);
    double tmp4 = vcb4+oth4; double errtmp4 = sqrt(errvcb4*errvcb4+erroth4*erroth4);
    double tmp5 = vcb5+oth5; double errtmp5 = sqrt(errvcb5*errvcb5+erroth5*erroth5);
    signalsig = ApplyCorrFactors(TVector2(tmp3,errtmp3),TVector2(tmp4,errtmp4),TVector2(tmp5,errtmp5),true,"Vcb","lepYes == 1",correctionratiovcb);
  }
  
  totmc = signalsig.X();
  errtotmc = signalsig.Y();

  //--------------------------------------------------------------------------------------
  c1->cd(13); 
  //----------vubout lepton mc bch----------- 
  sprintf(simply,"(flavB==3) && lepYes==1");
  if(su == 1){
    signalsig = sighistounb(datavubout, Vmes, fitResults, mesvuboutMC, 6000, 1000, simply, USECB, 0, matchMC);
    //  }else{
    //    //check the mixing correction
    //    sprintf(simply,"lepYes==1");
    //    signalsig = sighistounb(datamcoth, Vmes, fitResults, mesvcbMC, 6000, 1000, simply, USECB);
  }
  std::cout << "Fitting semileptonic events on vubout mc3!!! :: " << fitResults << std::endl;
  double  vubout3 = signalsig.X();                    double  errvubout3 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};

  c1->cd(14); 
  //----------vubout lepton mc bos----------- 
  sprintf(simply,"(flavB==4) && lepYes==1");
  if(su == 1){
    signalsig = sighistounb(datavubout, Vmes, fitResults, mesvuboutMC, 6000, 1000, simply, USECB, 0, matchMC);
    //  }else{
    //    //check the mixing correction
    //    sprintf(simply,"lepYes==1");
    //    signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 30000, 7000, simply, USECB);
  }
  std::cout << "Fitting semileptonic events on vubout mc4!!! :: " << fitResults << std::endl;
  double  vubout4 = signalsig.X();                    double errvubout4 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};
  
  c1->cd(15);
  //----------vub lepton mc bss----------- 
  sprintf(simply,"(flavB==5) && lepYes==1");
  if(su == 1){
    signalsig = sighistounb(datavubout, Vmes, fitResults, mesvuboutMC, 6000, 1000, simply, USECB, 0, matchMC);
  }
  std::cout << "Fitting semileptonic events on vubout mc5!!! :: " << fitResults << std::endl;
  double  vubout5 = signalsig.X();                    double  errvubout5 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};
  
  // correctionratiovubout = vubout3/(vubout4+vubout5);
  // cout<<"correction Ratio VubOUT = "<<correctionratiovubout<<endl;

  if(su ==1) {
    if(MIXCORR==0){
      vuboutmc = vubout3 + vubout4 +vubout5;
      errvuboutmc = sqrt(errvubout3 * errvubout3 + errvubout4 * errvubout4 + errvubout5 * errvubout5);
    } else {      
      vuboutmc = vubout3 + ((1-chid)/(1-2*chid)) * vubout4 - (chid/(1-2*chid)) * vubout5;
      errvuboutmc = sqrt(errvubout3 * errvubout3 +
			 ((1-chid)/(1-2*chid)) * ((1-chid)/(1-2*chid)) * errvubout4 * errvubout4 +
			 (chid/(1-2*chid)) * (chid/(1-2*chid)) * errvubout5 * errvubout5);
      cout<<"control:::::"<<"vubout3  "<<vubout3<<"  errvubout3  "<<errvubout3<<" vubout4  "<<vubout4<<"  errvubout4  "<<errvubout4<<" vubout5  "<<vubout5<<"  errvubout5  "<<errvubout5<<endl;    
      cout<<"control:::::"<<"           vuboutmc  "<<vuboutmc<<"  errvuboutmc  "<<errvuboutmc<<endl;    
    
    }
    //  }else{
    //    cout << "Check mixing correction: vcbmc = " << vubout4 << " +/- " << errvubout4 << "  othmc = " << vubout3 << " +/- " << errvubout3 << endl;
    //    cout << "Check mixing correction: total = " << vubout4+vubout3 << " +/- " << sqrt(errvubout4*errvubout4+ errvubout3*errvubout3) << endl;
  }   
  //if(BINNED){}else{xframe->Draw();};
  
  // ANTONIO 26/03/2007 Applying mixing correction AND correction ratio for fact calculation.
  if(su == 1) {
    signalsig = ApplyCorrFactors(TVector2(vubout3,errvubout3),TVector2(vubout4,errvubout4),TVector2(vubout5,errvubout5),true,TString(datavubout->GetName()),"lepYes == 1",correctionratiovubout);
    vuboutmc = signalsig.X();
    errvuboutmc = signalsig.Y();
  } else 
    vuboutmc = errvuboutmc = 0;


  //----------------------------EPSILON U------------------------------------------------------------------------

  c1->cd(16); 
  //----------vub IN lepton mc bch----------- 
  if(comb)	
    sprintf(simply,"%s%.3f%s%.3f%s%.3f%s","(mx < ",MXBIN,") && (q2 > ",Q2BIN,") && (q2 < ",Q2HICUT, ") && (flavB==3) && lepYaSe");
  else{
    if (FITQ2 == 0) 
      sprintf(simply,"%s%.3f%s","(chop<",CHOPBIN,") && (flavB==3) && lepYaSe");
    else if (FITQ2 == 1) 
      sprintf(simply,"%s%.3f%s","(chop>",CHOPBIN,") && (flavB==3) && lepYaSe");
    else if (FITQ2 == 2) 
      sprintf(simply,"%s%.3f%s","(chop<",CHOPBIN,") && (flavB==3) && lepYaSe");
  }
  if(su == 1){
    signalsig = sighistounb(datavubin, Vmes, fitResults, mesvubcuts, 6000, 1000, simply, USECB, 0, matchMC);//Antonio: it was mesvubMC why?
    cout<<"entrati:::"<<endl;
  } else 
    signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubcuts, 6000, 1000, simply, USECB, 0, matchMC); //Antonio: it was mesvubMC why?
  
  std::cout << "Fitting semileptonic events on vub IN mc3!!! :: " << fitResults << std::endl;
  double  vubIN3 = signalsig.X();                    double  errvubIN3 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};
  
  
  c1->cd(17); 
  //----------vub IN lepton mc bos----------- 
  if(comb)
    sprintf(simply,"%s%.3f%s%.3f%s%.3f%s","(mx < ",MXBIN,") && (q2 > ",Q2BIN,") && (q2 < ",Q2HICUT, ") && (flavB == 4) && lepYaSe");
  else{
    if (FITQ2 == 0) 
      sprintf(simply,"%s%.3f%s","(chop<",CHOPBIN,") && (flavB==4) && lepYaSe");
    else if (FITQ2 == 1) 
      sprintf(simply,"%s%.3f%s","(chop>",CHOPBIN,") && (flavB==4) && lepYaSe");
    else if (FITQ2 == 2) 
      sprintf(simply,"%s%.3f%s","(chop<",CHOPBIN,") && (flavB==4) && lepYaSe");
  }
  
  if(su == 1)
    signalsig = sighistounb(datavubin, Vmes, fitResults, mesvubcuts, 6000, 1000, simply, USECB, 0, matchMC);
  else
    signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubcuts, 6000, 1000, simply, USECB, 0, matchMC);
  
  std::cout << "Fitting semileptonic events on vub IN  mc4!!! :: " << fitResults << std::endl;
  double  vubIN4 = signalsig.X();                    double errvubIN4 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};
  
  c1->cd(18);
  //----------vub IN lepton mc bss----------- 
  if(comb)
    sprintf(simply,"%s%.3f%s%.3f%s%.3f%s","(mx < ",MXBIN,") && (q2 > ",Q2BIN,") && (q2 < ",Q2HICUT, ") && (flavB == 5) && lepYaSe");
  else {
    if (FITQ2 == 0) 
      sprintf(simply,"%s%.3f%s","(chop<",CHOPBIN,") && (flavB==5) && lepYaSe");
    else if (FITQ2 == 1) 
      sprintf(simply,"%s%.3f%s","(chop>",CHOPBIN,") && (flavB==5) && lepYaSe");
    else if (FITQ2 == 2) 
      sprintf(simply,"%s%.3f%s","(chop<",CHOPBIN,") && (flavB==5) && lepYaSe");
  }
  
  if(su == 1)
    signalsig = sighistounb(datavubin, Vmes, fitResults, mesvubcuts, 6000, 1000, simply, USECB, 0, matchMC); //Antonio: it was mesvubMC why?
  else
    signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubcuts, 6000, 1000, simply, USECB, 0, matchMC); //Antonio: it was mesvubMC why?
  
  std::cout << "Fitting semileptonic events on vub IN mc5!!! :: " << fitResults << std::endl;
  double  vubIN5 = signalsig.X();                    double  errvubIN5 = signalsig.Y();       
  //if(BINNED){}else{xframe->Draw();};

  if(MIXCORR==0){
    vubmcSB = vubIN3 + vubIN4 +vubIN5;
    errvubmcSB = sqrt(errvubIN3 * errvubIN3 + errvubIN4 * errvubIN4 + errvubIN5 * errvubIN5);
  } else {      
    vubmcSB = vubIN3 + ((1-chid)/(1-2*chid)) * vubIN4 - (chid/(1-2*chid)) * vubIN5;
    errvubmcSB = sqrt(errvubIN3 * errvubIN3 +
		      ((1-chid)/(1-2*chid)) * ((1-chid)/(1-2*chid)) * errvubIN4 * errvubIN4 +
		      (chid/(1-2*chid)) * (chid/(1-2*chid)) * errvubIN5 * errvubIN5);
    
    cout<<"control:::::"<<"vubIN3  "<<vubIN3<<"  errvubIN3  "<<errvubIN3<<"vubIN4  "<<vubIN4<<"  errvubIN4  "<<errvubIN4<<"vubIN5  "<<vubIN5
	<<"  errvubIN5  "<<errvubIN5<<endl; 
    cout<<"control:::::"<<"           vubmcSB  "<<vubmcSB<<"  errvubmcSB  "<<errvubmcSB<<endl;    
  }
  signalsig = ApplyCorrFactors(TVector2(vubIN3,errvubIN3),TVector2(vubIN4,errvubIN4),TVector2(vubIN5,errvubIN5),true,"VubIN","lepYaSe == 1",correctionratiovub);

  vubmcSB = signalsig.X(); errvubmcSB = signalsig.Y();
  cout << vubmcSB <<" +- " << errvubmcSB <<endl;
  

  sprintf(line,"%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"mES_eff_misc.eps");
  gStyle->SetPaperSize(4.*20., 4.*26.);
  c1->Print(line);
  gStyle->SetPaperSize(20., 26.);
  delete c1; c1 = NULL;
  // //   ////////////////////////////////////////////////////////////////////////////////
}

void VirClass::mixingCorr(int comb, int mult, int su){    

  char name[200],line[200], pref[200];
  double tempbin, tempbinchb, tempbinb0os, tempbinb0ss;
  double temperr, temperrchb, temperrb0os, temperrb0ss;
  double chid = 0.188;
  fHistFile->cd();

  //CB 
  // int nQ2B = 9; //AP
  // Correction to have the right Bch/B0 ratio (as data)
  double correctionratio = 1.;

  //Call to charge correlation routine DEPRECATED! 
  //  chargeCorr(su, comb);
  
  //compute NSL and Efficiencies
  computeNSLandEfficiencies(su,comb);

  c1 = new TCanvas("c2"," ",200,10,1414,1000); 
  c1->Clear();
  c1->Divide(2, 2);

  for (int ii = 1; ii < 5; ii++){
    if(ii == 1) {
      sprintf(pref,"%s","data");
      correctionratio = 1.;
    } else if (ii == 2) {
      if(su == 1) {
        sprintf(pref,"%s","vcboth");
	correctionratio = correctionratiovcb;
      } else {
	sprintf(pref,"%s","vcb");
	correctionratio = correctionratiovcb;
      }
    }  else if (ii == 3) {
      if(su ==1) {
	sprintf(pref,"%s","vubout");
	correctionratio = correctionratiovubout;
      } else {
	sprintf(pref,"%s","other");
	correctionratio = correctionratiovcb;
      }
    }  else {
      if(su ==1) {
	sprintf(pref,"%s","vubin");
	correctionratio = correctionratiovub;
      } else {
	sprintf(pref,"%s","vub");
	correctionratio = correctionratiovub;
      }
    }
        
    // VOID ALL CORRECTIONRATIOS IN CASE OF CHARGE SEPARATION
    // Acutally not needed but just in case
    if (BTYPE != 2)
      correctionratio = 1.;
    
    if(!comb) {
      for (int i = 1; i < nB; i++){
        sprintf(name,"%s%s",pref,"3chop"); tempbinchb = ((TH1D*)gDirectory->Get(name))->GetBinContent(i) * correctionratio;
        sprintf(name,"%s%s",pref,"4chop"); tempbinb0os = ((TH1D*)gDirectory->Get(name))->GetBinContent(i);
        sprintf(name,"%s%s",pref,"5chop"); tempbinb0ss = ((TH1D*)gDirectory->Get(name))->GetBinContent(i);
        sprintf(name,"%s%s",pref,"3chop"); temperrchb = ((TH1D*)gDirectory->Get(name))->GetBinError(i) * correctionratio;
        sprintf(name,"%s%s",pref,"4chop"); temperrb0os = ((TH1D*)gDirectory->Get(name))->GetBinError(i);
        sprintf(name,"%s%s",pref,"5chop"); temperrb0ss = ((TH1D*)gDirectory->Get(name))->GetBinError(i);

        if(MIXCORR == 0 || BTYPE != 2) {
	  cout << " NOT APPLYING MIXING CORRECTION IN HISTOGRAMES ! (sep charge)" << endl;
          tempbin = tempbinchb + tempbinb0os;
          temperr = sqrt(temperrchb * temperrchb + temperrb0os * temperrb0os);
        } else {      
          tempbin = tempbinchb + ((1-chid)/(1-2*chid)) * tempbinb0os - (chid/(1-2*chid)) * tempbinb0ss;
          temperr = sqrt(temperrchb*temperrchb + ((1-chid)/(1-2*chid)) * ((1-chid)/(1-2*chid)) * temperrb0os * temperrb0os + (chid/(1-2*chid)) * (chid/(1-2*chid)) * temperrb0ss * temperrb0ss);
        }

        sprintf(name,"%s%s",pref,"chop"); 
        ((TH1D*)gDirectory->Get(name))->SetBinContent(i, tempbin);
        ((TH1D*)gDirectory->Get(name))->SetBinError(i, temperr); 
      }
      c1->cd(1);
      sprintf(name,"%s%s",pref,"3chop"); 
      ((TH1D*)gDirectory->Get(name))->Draw();
      c1->cd(2);
      sprintf(name,"%s%s",pref,"4chop"); 
      ((TH1D*)gDirectory->Get(name))->Draw();
      c1->cd(3);
      sprintf(name,"%s%s",pref,"5chop"); 
      ((TH1D*)gDirectory->Get(name))->Draw();
      c1->cd(4);
      sprintf(name,"%s%s",pref,"chop"); 
      ((TH1D*)gDirectory->Get(name))->Draw();
      gPad->Update();
      sprintf(line,"%s%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),pref,"chop_all.eps");
      c1->Print(line);
      
      if(mult)
        for(int j = 1; j < 6; j++)
          for (int i = 1; i < nB; i++){
            sprintf(name,"%s%s%d",pref,"3chop",j); tempbinchb = ((TH1D*)gDirectory->Get(name))->GetBinContent(i) * correctionratio;
            sprintf(name,"%s%s%d",pref,"4chop",j); tempbinb0os = ((TH1D*)gDirectory->Get(name))->GetBinContent(i);
            sprintf(name,"%s%s%d",pref,"5chop",j); tempbinb0ss = ((TH1D*)gDirectory->Get(name))->GetBinContent(i);
            sprintf(name,"%s%s%d",pref,"3chop",j); temperrchb = ((TH1D*)gDirectory->Get(name))->GetBinError(i) * correctionratio;
            sprintf(name,"%s%s%d",pref,"4chop",j); temperrb0os = ((TH1D*)gDirectory->Get(name))->GetBinError(i);
            sprintf(name,"%s%s%d",pref,"5chop",j); temperrb0ss = ((TH1D*)gDirectory->Get(name))->GetBinError(i);
            if(MIXCORR==0 || BTYPE != 2){
	      cout << " NOT APPLYING MIXING CORRECTION IN HISTOGRAMES ! (sep charge)" << endl;
              tempbin = tempbinchb + tempbinb0os;
              temperr = sqrt(temperrchb * temperrchb + temperrb0os * temperrb0os);
            } else {      
              tempbin = tempbinchb + ((1-chid)/(1-2*chid)) * tempbinb0os - (chid/(1-2*chid)) * tempbinb0ss;
              temperr = sqrt(temperrchb*temperrchb + ((1-chid)/(1-2*chid)) * ((1-chid)/(1-2*chid)) * temperrb0os * temperrb0os + (chid/(1-2*chid)) * (chid/(1-2*chid)) * temperrb0ss * temperrb0ss);
            }
            sprintf(name,"%s%s%d",pref,"chop",j); 
	    
            ((TH1D*)gDirectory->Get(name))->SetBinContent(i, tempbin);
            ((TH1D*)gDirectory->Get(name))->SetBinError(i, temperr); 
	    
	  }
    } else { // 2D ANALYSIS

      for (int i=1;i<nMxB;i++){ // NEED TO CHECK THE ACTUAL MX BINNING for MX/Q2 Analysis!!!
	//CB
	//        for (int k=1;k<5;k++){
        for (int k = 1; k < nQ2B; k++){
          sprintf(name,"%s%s",pref,"3comb"); tempbinchb = ((TH2D*)gDirectory->Get(name))->GetBinContent(i,k) * correctionratio;
          sprintf(name,"%s%s",pref,"4comb"); tempbinb0os = ((TH2D*)gDirectory->Get(name))->GetBinContent(i,k);
	  sprintf(name,"%s%s",pref,"5comb"); tempbinb0ss = ((TH2D*)gDirectory->Get(name))->GetBinContent(i,k);
	  sprintf(name,"%s%s",pref,"3comb"); temperrchb = ((TH2D*)gDirectory->Get(name))->GetBinError(i,k) * correctionratio;
	  sprintf(name,"%s%s",pref,"4comb"); temperrb0os = ((TH2D*)gDirectory->Get(name))->GetBinError(i,k);
	  sprintf(name,"%s%s",pref,"5comb"); temperrb0ss = ((TH2D*)gDirectory->Get(name))->GetBinError(i,k);

	  if(MIXCORR==0 || BTYPE != 2) { 
	    cout << " NOT APPLYING MIXING CORRECTION IN HISTOGRAMES ! (sep charge)" << endl;
	    tempbin = tempbinchb + tempbinb0os;
	    temperr = sqrt(temperrchb * temperrchb + temperrb0os * temperrb0os);
	  } else {      
	    tempbin = tempbinchb + ((1-chid)/(1-2*chid)) * tempbinb0os - (chid/(1-2*chid)) * tempbinb0ss;
	    temperr = sqrt(temperrchb*temperrchb + ((1-chid)/(1-2*chid)) * ((1-chid)/(1-2*chid)) * temperrb0os * temperrb0os + (chid/(1-2*chid)) * (chid/(1-2*chid)) * temperrb0ss * temperrb0ss);
	  }
	  sprintf(name,"%s%s",pref,"comb"); 
	  
	  if(TOYHISTOGRAMES)
	    {
	      double relerr, nutempbin, nutemperr;
	      relerr = tempbin != 0 ? temperr/tempbin : 0;
	      
	      nutempbin = randz->Gaus(tempbin,temperr);
	      nutemperr = tempbin < 1 ? temperr : relerr*nutempbin;
	      
	      cout << "TOYZ HISTOGRAMES: histo " << name << " bin (" << i << "," << k << ") old " << tempbin << " +- " << temperr 
		   << " new " << nutempbin << " +- " << nutemperr << endl;
	      
	      tempbin = nutempbin;
	      temperr = nutemperr;
	      
	    }

	  ((TH2D*)gDirectory->Get(name))->SetBinContent(i,k, tempbin);
	  ((TH2D*)gDirectory->Get(name))->SetBinError(i,k, temperr); 
	}
      }
      gStyle->SetOptStat(0);
      c1->cd(1);
      sprintf(name,"%s%s",pref,"3comb"); 
      ((TH1D*)gDirectory->Get(name))->Draw("colz");
      c1->cd(2);
      sprintf(name,"%s%s",pref,"4comb"); 
      ((TH1D*)gDirectory->Get(name))->Draw("colz");
      c1->cd(3);
      sprintf(name,"%s%s",pref,"5comb"); 
      ((TH1D*)gDirectory->Get(name))->Draw("colz");
      c1->cd(4);
      sprintf(name,"%s%s",pref,"comb"); 
      ((TH1D*)gDirectory->Get(name))->Draw("colz");
      gPad->Update();
      sprintf(line,"%s%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),pref,"comb_all.eps");
      c1->Print(line);
    }
  }
  delete c1; c1 = NULL;
}
// ---------------------------------------------------------------------

void chi2Hist(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag) {


  //value of 3rd parameter ("flag") tells if the fit is with 2 (abs(flag)>2) or 3 (otherwise) parameters
  //sign of 3rd parameter tells whether to add (<0.1) or not (otherwise) MC statistical error to chisq computation
  int ioth=TMath::Abs(par[3])>2 ? 1 : 2 ;
  Double_t chi2(0.);
  int nBin = vubHist->GetNbinsX();
  //CB bug fix
  //  for (int j=0;j<nBin;j++){
  for (int j=1;j<nBin+1;j++){

    double x=par[0]*vubHist->GetBinContent(j)+par[1]*vcbHist->GetBinContent(j)+par[ioth]*othHist->GetBinContent(j);
    if(x>0 && dataHist->GetBinContent(j)>0){
      double s2=pow(dataHist->GetBinError(j),2);
      if(par[3]<0.1) { 
	s2+= // add MC stat
	  (pow(par[0]*vubHist->GetBinError(j),2)+
	   pow(par[1]*vcbHist->GetBinError(j),2)+
	   //CB bug fix
	   //pow(par[1]*othHist->GetBinError(j),2));
	   //CB uncomment this to get it right
	   pow(par[ioth]*othHist->GetBinError(j),2));
      }
      chi2+=pow((x-dataHist->GetBinContent(j)),2)/s2;
    }
  }
  f=chi2;
}
// ---------------------------------------------------------------------

void chi2Histsu(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag) {

 int ioth=TMath::Abs(par[3])>2 ? 0 : 2 ; 
  Double_t chi2(0.);
  int nBin = vubHist->GetNbinsX();
  //CB bug fix
  //  for (int j=0;j<nBin;j++){
  for (int j=1;j<nBin+1;j++){

    double x=par[0]*vubHist->GetBinContent(j)+par[1]*vcbHist->GetBinContent(j)+par[ioth]*othHist->GetBinContent(j);
    if(x>0 && dataHist->GetBinContent(j)>0){
      double s2=pow(dataHist->GetBinError(j),2);
      if(par[3]<0.1) { 
	s2+= // add MC stat
	  (pow(par[0]*vubHist->GetBinError(j),2)+
	   pow(par[1]*vcbHist->GetBinError(j),2)+
	   pow(par[ioth]*othHist->GetBinError(j),2));
      }
      chi2+=pow((x-dataHist->GetBinContent(j)),2)/s2;
    }
  }
  f=chi2;
}
// ---------------------------------------------------------------------

void VirClass::fitWithErrors(int comb,int su, char * typ)
{
  TMinuit aMinuit(4);
  int ierflg;
 
  // initialize minuit
  if (comb == 0) {
    cout << "----> Now Perfoming fitWithErrors "<< endl;
    if (su) {
      aMinuit.SetFCN(chi2Histsu);
      aMinuit.mnparm(0, "vubincomp",   1.00, 0.001, 0., 10., ierflg); 
      aMinuit.mnparm(1, "vcbothcomp",  1.00, 0.001, 0., 10., ierflg); 
      aMinuit.mnparm(2, "vuboutcomp",  1.00, 0.001, 0., 10., ierflg); 
    } else {
      aMinuit.SetFCN(chi2Hist);
      aMinuit.mnparm(0, "vubcomp",  1.00, 0.001, 0., 10., ierflg); 
      aMinuit.mnparm(1, "vcbcomp",  1.00, 0.001, 0., 10., ierflg); 
      aMinuit.mnparm(2, "othcomp",  0.06, 0.001, 0.,  1., ierflg); 
    }  
  } else {
    if (su) {
      aMinuit.SetFCN(chi2Hist2Dsu);
      aMinuit.mnparm(0, "vubincomp",   1.00, 0.001, 0., 10., ierflg); 
      aMinuit.mnparm(1, "vcbothcomp",  1.00, 0.001, 0., 10., ierflg); 
      aMinuit.mnparm(2, "vuboutcomp",  1.00, 0.001, 0., 10., ierflg); 
    } else {
      aMinuit.SetFCN(chi2Hist2D);
      aMinuit.mnparm(0, "vubcomp",  1.00, 0.001, 0., 10., ierflg); 
      aMinuit.mnparm(1, "vcbcomp",  1.00, 0.001, 0., 10., ierflg); 
      aMinuit.mnparm(2, "othcomp",  0.06, 0.001, 0.,  1., ierflg); 
    }
  }
  //
  //FITOPT==0 means 2 parameters fit -- Vcb and other Lagrange multipliers fitted together
  //FITOPT==1 means 3 parameters fit
  //
  aMinuit.mnparm(3, "flag",  -2., 0., -100., 100., ierflg);        // 3 parameter fit 
  if(FITOPT==0){
    // changed 3 -> -3  to take MC error into account into the chisq fit... 
    aMinuit.mnparm(3, "flag",  -3., 0., -100., 100., ierflg);  // 2 parameter fit
    aMinuit.FixParameter(2); 
  }
  if(FITOPT==5){
    cout<<VCBCOMP<<" "<<OTHCOMP<<endl;
    aMinuit.mnparm(1, "vcbcomp", VCBCOMP, 0.001, 0., 10., ierflg);
    aMinuit.FixParameter(1);
    aMinuit.mnparm(2, "othcomp", OTHCOMP, 0.001, 0., 10., ierflg);
    aMinuit.FixParameter(2);
  }
  aMinuit.FixParameter(3); 

  // get histograms
  std::string name(comb ? "comb" : "chop");
  std::string name2;

  name2 = (su ? "vubin" : "vub" ) + name;
  if(comb) { 
    vub2Hist = (TH2D*)gDirectory->Get(name2.c_str());
    if(!FITTOTSHAPE) vub2Hist->Scale(BRRATIOVALUETAIL_U/BRRATIOVALUETAIL_C*vcbmc/vcbmc);
  } else {
    vubHist = (TH1D*)gDirectory->Get(name2.c_str());
    if(!FITTOTSHAPE) vubHist->Scale(BRRATIOVALUETAIL_U/BRRATIOVALUETAIL_C*vcbmc/vcbmc);
  }

  name2 = (su ? "vcboth" : "vcb" ) + name;
  if(comb) { 
    vcb2Hist = (TH2D*)gDirectory->Get(name2.c_str());
  } else {
    vcbHist = (TH1D*)gDirectory->Get(name2.c_str());
  }

  name2 = (su ? "vubout" : "other" ) + name;
  if(comb) { 
    oth2Hist = (TH2D*)gDirectory->Get(name2.c_str());
  } else {
    othHist = (TH1D*)gDirectory->Get(name2.c_str());
  }

  name2 = "data" + name;
  if(comb) {
    data2Hist = (TH2D*)gDirectory->Get(name2.c_str());
  } else {
    dataHist = (TH1D*)gDirectory->Get(name2.c_str());
  }

  // do the fit 
  //Change default to be 2 if you want PRL results
  int ioth=FITOPT==0 ? 1 : 2 ;
  Double_t arglis[10];
  arglis[0] = 10000; // maxcalls
  arglis[1] = 0.001;  // tolerance
  aMinuit.mnexcm("MINI", arglis, 2, ierflg);
  if (ierflg!=0) std::cout <<"Error: fit with MC truth: mini  error " << ierflg << std::endl;
  aMinuit.mnexcm("MINOS", arglis, 2, ierflg);
  if (ierflg!=0) std::cout <<"Error: fit with MC truth: minos error " << ierflg << std::endl;
  
  // get parameters out
  if(su){
    //CB SHOULD VERIFY THIS WHEN WE SWITCH AGAIN TO UNFOLDING MxQ2 FIT... 
    ioth=FITOPT==1 ? 2 : 0;
    aMinuit.GetParameter(0,vubincomp,errvubincomp);
    aMinuit.GetParameter(1,vcbothcomp,errvcbothcomp);  
    aMinuit.GetParameter(ioth,vuboutcomp,errvuboutcomp);
  } else{
    aMinuit.GetParameter(0,vubcomp,errvubcomp);
    aMinuit.GetParameter(1,vcbcomp,errvcbcomp);  
    aMinuit.GetParameter(ioth,othcomp,errothcomp);
  }

  // redo fit without errors from mc truth (negative parameter "flag")
  //
  //FITOPT==0 means 2 parameters fit -- Vcb and other Lagrange multipliers fitted together
  //FITOPT==1 means 3 parameters fit
  
  aMinuit.mnparm(3, "flag",  2., 0., 0., 100., ierflg);    // 3 parameter fit
  if(FITOPT==0){
    aMinuit.mnparm(3, "flag",  3., 0., 0., 100., ierflg);  // 2 parameter fit
    aMinuit.FixParameter(2);
  }
  if(FITOPT==5){
    cout<<VCBCOMP<<" "<<OTHCOMP<<endl;
    aMinuit.mnparm(1, "vcbcomp", VCBCOMP, 0.001, 0., 10., ierflg);
    aMinuit.FixParameter(1);
    aMinuit.mnparm(2, "othcomp", OTHCOMP, 0.001, 0., 10., ierflg);
    aMinuit.FixParameter(2);
  }
  aMinuit.FixParameter(3); 

  aMinuit.mnexcm("MINI", arglis, 2, ierflg);
  if (ierflg!=0) std::cout <<"Error: fit without MC truth: mini  error " << ierflg << std::endl;
  aMinuit.mnexcm("MINOS", arglis, 2, ierflg);
  if (ierflg!=0) std::cout <<"Error: fit without MC truth: minos error " << ierflg << std::endl;

  // get parameters out 
  if (su) {
    //CB SHOULD VERIFY THIS WHEN WE SWITCH AGAIN TO UNFOLDING MxQ2 FIT... 
    ioth=FITOPT==1 ? 2 : 0;
    aMinuit.GetParameter(0,vubincompNOMC,errvubincompNOMC);
    aMinuit.GetParameter(1,vcbothcompNOMC,errvcbothcompNOMC);
    aMinuit.GetParameter(ioth,vuboutcompNOMC,errvuboutcompNOMC);
    if (vubincompNOMC>vubcomp || vuboutcompNOMC>vuboutcomp || vcbothcompNOMC>vcbothcomp) {
      cout <<" removing MC truth improves error!!! "<<" vub "<<vubincompNOMC<<" "<<vubincomp
	   <<" vcb "<<vcbothcompNOMC<<" "<<vcbothcomp<<" oth "<<vuboutcompNOMC<<" "<<vuboutcomp<<endl;
      cout <<" removing MC truth improves error ::  "<<" vub "<<errvubincompNOMC<<" "<<errvubincomp
	   <<" vcb "<<errvcbothcompNOMC<<" "<<errvcbothcomp<<" oth "<<errvuboutcompNOMC<<" "<<errvuboutcomp<<endl;
    }
  } else {
    ioth=FITOPT==0 ? 1 : 2;
    aMinuit.GetParameter(0,vubcompNOMC,errvubcompNOMC);
    aMinuit.GetParameter(1,vcbcompNOMC,errvcbcompNOMC);
    aMinuit.GetParameter(ioth,othcompNOMC,errothcompNOMC);
    if (vubcompNOMC>vubcomp || vcbcompNOMC>vcbcomp || othcompNOMC>othcomp) {
      cout <<" removing MC truth improves error!!! "<<" vub "<<vubcompNOMC<<" "<<vubcomp
	   <<" vcb "<<vcbcompNOMC<<" "<<vcbcomp<<" oth "<<othcompNOMC<<" "<<othcomp<<endl;
      cout <<" removing MC truth improves error ::  "<<" vub "<<errvubcompNOMC<<" "<<errvubcomp
	   <<" vcb "<<errvcbcompNOMC<<" "<<errvcbcomp<<" oth "<<errothcompNOMC<<" "<<errothcomp<<endl;
    }
  }
  

  std::cout << "Make scan plots" << std::endl;

  if (comb==0) {
    if (su==0) {
      TCanvas *cla1 = new TCanvas(); 
      TGraph *g1 = scanParameter(0, 2, aMinuit, chi2Hist); 
      g1->SetTitle("scan b2u"); 
      g1->SetMarkerSize(0.5); 
      g1->Draw("ap"); 
      cla1->SaveAs(Form("%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"vub_scan.eps"));

      cla1->Clear(); 
      TGraph *g2 = scanParameter(1, 2, aMinuit, chi2Hist); 
      g2->SetTitle("scan b2c"); 
      g2->SetMarkerSize(0.5); 
      g2->Draw("ap"); 
      cla1->SaveAs(Form("%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"vcb_scan.eps"));

      cla1->Clear(); 
      TGraph *g3 = scanParameter(2, 2, aMinuit, chi2Hist); 
      g3->SetTitle("scan other"); 
      g3->SetMarkerSize(0.5); 
      g3->Draw("ap"); 
      cla1->SaveAs(Form("%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"oth_scan.eps"));
      delete g1; 
      delete g2; 
      delete g3; 
      delete cla1; 
    } else {
      TCanvas *cla1 = new TCanvas(); 
      TGraph *g1 = scanParameter(0, 2, aMinuit, chi2Histsu); 
      g1->SetTitle("scan b2u"); 
      g1->SetMarkerSize(0.5); 
      g1->Draw("ap"); 
      cla1->SaveAs(Form("%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"vubin_scan.eps"));

      cla1->Clear(); 
      TGraph *g2 = scanParameter(1, 2, aMinuit, chi2Histsu); 
      g2->SetTitle("scan b2c"); 
      g2->SetMarkerSize(0.5); 
      g2->Draw("ap"); 
      cla1->SaveAs(Form("%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"vcboth_scan.eps"));

      cla1->Clear(); 
      TGraph *g3 = scanParameter(2, 2, aMinuit, chi2Histsu); 
      g3->SetTitle("scan other"); 
      g3->SetMarkerSize(0.5); 
      g3->Draw("ap"); 
      cla1->SaveAs(Form("%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"vubout_scan.eps"));
      delete g1; 
      delete g2; 
      delete g3; 
      delete cla1; 
    }
  }

  return;
}

    
// ----------------------------------------------------------------------
TGraph* VirClass::scanParameter(int parnum, int nsig, TMinuit &a, void (*func)(int &, double *, double &, double *, int)) {

#define MAXPAR 100
#define NSTEP  400

  double par[MAXPAR], parE[MAXPAR];

  int npar = a.GetNumPars(); 

  for (int ipar = 0; ipar < npar; ++ipar) {
    a.GetParameter(ipar, par[ipar], parE[ipar]); 
  }

  int iflag; 
  double x[NSTEP], y[NSTEP], dummy[NSTEP]; 

  double min  = par[parnum] - nsig*parE[parnum]; 
  double max  = par[parnum] + nsig*parE[parnum]; 
  double step = (max - min)/NSTEP; 
  double val(0.); 

  for (int ix = 0; ix < NSTEP; ++ix) {
    par[parnum] = min + ix*step; 
    (*func)(iflag, dummy, val, par, iflag); 
    x[ix] = par[parnum]; 
    y[ix] = val; 
  }
    
  TGraph *tg = new TGraph(NSTEP, x, y); 
  tg->Draw("ap"); 

  return tg; 
}

void VirClass::calcPstarFact(const int comb, const int su, const int ck, const int runperiod)
{
  TStopwatch timer; // for timing purpose  

  std::vector<double> fitResults;

  char simply[100], line[200];
  double avubmc, aerrvubmc, avcbmc, aerrvcbmc,  atot, aerrtot, atotmc, aothermc;
  double avubmc3, aerrvubmc3, avubmc4, aerrvubmc4, avubmc5, aerrvubmc5;
  double avcbmc3, aerrvcbmc3, avcbmc4, aerrvcbmc4, avcbmc5, aerrvcbmc5;
  double avubout3, aerrvubout3, avubout4, aerrvubout4, avubout5, aerrvubout5;
  double avubout, aerrvubout;
  
  double chid=0.188;

  errcalcpstarfact = 1;
  calcpstarfact = PSTARFACT;

  TVector2 signal;

  // get efficiecny for unfolding
  TVector2 effDFN(1.,0.);

  if (su == 1) {
    std::cout << "Phase space acceptance for P*factor with " << (comb+1) << "D unfolding ";
    if (comb==1) 
      if (ck) {
	std::cout << " using DFN ..." << std::endl;
	effDFN = getEffFromDFN2D(MXBIN,Q2BIN);
      } else {
	std::cout << " using BLL ..." << std::endl;
 	effDFN = getEffFromBauer(MXBIN,Q2BIN);
      }
    else {
      std::cout << " using DFN ..." << std::endl;
      if (FITQ2 == 0) 
	effDFN = getEffFromDFN(MXBIN, VirClass::iVarMx);
      else if (FITQ2 == 1) 
	effDFN = getEffFromDFN(Q2BIN, VirClass::iVarQ2);
      else if (FITQ2 == 2) 
	effDFN = getEffFromDFN(PPLUSBIN, VirClass::iVarPplus);
    }
  } // if (su == 1)
  
  if (EFFDFN != -99) effDFN.Set(EFFDFN,0);
  
  std::cout << "effDFN  = " << effDFN.X() << " +/- " << effDFN.Y() << std::endl;

  std::cout << std::endl << "=========> starting P*Factor calculations" << std::endl << std::endl;

  //========================================= correct vubmcselected for MiXing AP 13-oct-2005  ================

  
  c1 = new TCanvas("canvas","vubmcselcted"); 
  c1->Clear();
  c1->Divide(1,3);
  c1->cd(1);

  int matchMC = countMC ? 2 : 0;

  sprintf(simply,"(flavB==3) && lepYaSe");
  
  if(su==1)
    signal= sighistounb(datavubin, Vmes, fitResults, mesvubMC, 2000, 200, simply, 0, 0, matchMC);
  else 
    signal= sighistounb(datamcvub, Vmes, fitResults, mesvubMC, 2000, 200, simply, 0, 0, matchMC);
  
  double flava3 = signal.X(); double errflava3 = signal.Y();
  //if(BINNED){} else {xframe->Draw();};
  
  c1->cd(2);
  
  sprintf(simply,"(flavB==4) && lepYaSe");
  if(su==1)
    signal= sighistounb(datavubin, Vmes, fitResults, mesvubMC, 2000, 200, simply, 0, 0, matchMC);
  else 
    signal= sighistounb(datamcvub, Vmes, fitResults, mesvubMC, 2000, 200, simply, 0, 0, matchMC);
  
  double flava4 = signal.X(); double errflava4 = signal.Y();
  //if(BINNED){} else {xframe->Draw();};
  
  c1->cd(3);
  sprintf(simply,"(flavB==5) && lepYaSe");
  if(su==1)
    signal= sighistounb(datavubin, Vmes, fitResults, mesvubMC, 2000, 200, simply, 0, 0, matchMC);
  else 
    signal= sighistounb(datamcvub, Vmes, fitResults, mesvubMC, 2000, 200, simply, 0, 0, matchMC);
  
  double flava5 = signal.X(); double errflava5 = signal.Y();
  //if(BINNED){} else {xframe->Draw();};
  
  if(MIXCORR==0){
    summ = flava3 + flava4 + flava5;
    errsumm = sqrt( errflava3*errflava3 + errflava4*errflava4 + errflava5*errflava5);
  } else {
    summ = flava3 +((1-chid)/(1-2*chid)) * flava4 - (chid/(1-2*chid)) * flava5;
    errsumm = sqrt(errflava3 * errflava3 +
                   ((1-chid)/(1-2*chid)) * ((1-chid)/(1-2*chid)) * errflava4 * errflava4 +
                   (chid/(1-2*chid)) * (chid/(1-2*chid)) * errflava5 * errflava5);}

  // ANTONIO 16/01/2009 Applying mixing correction AND correction ratio for efficiencies calculation (updated for charge separation).
  RooDataSet *datass = su == 1 ? datavubin : datamcvub;
  signal = ApplyCorrFactors(TVector2(flava3,errflava3),TVector2(flava4,errflava4),TVector2(flava5,errflava5),true,TString(datass->GetName()),"lepYaSe == 1",correctionratiovub);

  summ = signal.X();
  errsumm = signal.Y();

  vubmcallforeff_mixcorr = summ;

  sprintf(line,"%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"epsu_mixcorr.eps");
  c1->Print(line);

  cout << "SUMM= " << summ << endl;

  delete c1;
  c1 = NULL;

  //====================================================================

  c1 = new TCanvas("c1"," ",200,10,1414,1000);
  c1->Clear();
  c1->Divide(3, 3);

  //  sprintf(simply," lepYes==1 ");
  //   if(su == 1){
  //     signal = sighistounb(datavcboth, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB);
  //   } else{
  //     signal = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB);
  //   }
  //   vcbmc = signal.X();  totmc = vcbmc;    errvcbmc = signal.Y();
  //   //if(BINNED){}else{xframe->Draw();};
  // -------------------


  // ANTONIO 26/03/2007 FOR PSTAR FACTOR CALCULATION Loop over flavours, apply mixingcorrection and chargecorrection.
  // Also, add vubout to vcb.
  
  c1->cd(1); 
  sprintf(simply, "lepVcb && flavB == 3");
  signal = sighistounb(pstarsample, Vmes, fitResults, mespstarMC, 100000, 25000, simply, USECB, 0, matchMC);
  avcbmc3 = signal.X();    aerrvcbmc3 = signal.Y();   
  cout <<"Fitting PStarsample lepVcb flav 3!"<<endl;

  c1->cd(2);
  sprintf(simply, "lepVcb && flavB == 4");
  signal = sighistounb(pstarsample, Vmes, fitResults, mespstarMC, 100000, 25000, simply, USECB, 0, matchMC);
  avcbmc4 = signal.X();    aerrvcbmc4 = signal.Y();   
  cout <<"Fitting PStarsample lepVcb flav 4!"<<endl;
  
  c1->cd(3);
  sprintf(simply, "lepVcb && flavB == 5");
  signal = sighistounb(pstarsample, Vmes, fitResults, mespstarMC, 100000, 25000, simply, USECB, 0, matchMC);
  avcbmc5 = signal.X();    aerrvcbmc5 = signal.Y();   
  cout <<"Fitting PStarsample lepVcb flav 5!"<<endl;

  signal = ApplyCorrFactors(TVector2(avcbmc3,aerrvcbmc3),TVector2(avcbmc4,aerrvcbmc4),TVector2(avcbmc5,aerrvcbmc5),true,TString(pstarsample->GetName()),"lepYes == 1",correctionratiovcb);
  avcbmc = signal.X();
  aerrvcbmc = signal.Y();
  cout << "P*FACT: avcbmc = " << avcbmc << "    error = " << aerrvcbmc <<endl;

  // -------------------
  //vub lepton mc SB

  char tmpsimply[20];
  if (comb==1) {
    std::cout << "Calculating N_u for MC in 2D analysis..." << std::endl;
    if(su == 1){
      std::cout << "...with unfolding...";
      sprintf(tmpsimply," lepVubSB ");
    } else {
      std::cout << "...without unfolding..." << std::endl;
      sprintf(tmpsimply," lepVub ");
    }
  } else{
    std::cout << "Calculating N_u for MC in 1D analysis..." << std::endl;
    if(su == 1){
      std::cout << "...with unfolding using DFN ..." << std::endl;
      sprintf(tmpsimply," lepVubSB ");    
    } else {    
      std::cout << "...without unfolding..." << std::endl;
      sprintf(tmpsimply," lepVub ");
    }
  }

  c1->cd(4);
  cout <<"Fitting PStarsample Vub flav 3!"<<endl;
  sprintf(simply,"%s && flavB == 3",tmpsimply);
  signal = sighistounb(pstarsample, Vmes, fitResults, mespstarMC, 6000, 1000, simply, USECB, 0, matchMC); // o mesvubMC
  //
  //CONCEZIO  sprintf(simply," lepYes && flavB == 3");
  //CONCEZIO  if(su==1) 
  //CONCEZIO    signal = sighistounb(datavubin, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  //CONCEZIO  else 
  //CONCEZIO    signal = sighistounb(datamcvub, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  //
  avubmc3 = signal.X();  aerrvubmc3 = signal.Y();   


  c1->cd(5);
  cout <<"Fitting PStarsample Vub flav 4!"<<endl;
  sprintf(simply,"%s && flavB == 4",tmpsimply);
  signal = sighistounb(pstarsample, Vmes, fitResults, mespstarMC, 6000, 1000, simply, USECB, 0, matchMC);  // o mesvubMC
  //
  //CONCEZIO  sprintf(simply," lepYes && flavB == 4");
  //CONCEZIO  if(su==1) 
  //CONCEZIO    signal = sighistounb(datavubin, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  //CONCEZIO  else 
  //CONCEZIO    signal = sighistounb(datamcvub, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  //CONCEZIO  //
  avubmc4 = signal.X();  aerrvubmc4 = signal.Y();   


  c1->cd(6);
  cout <<"Fitting PStarsample Vub flav 5!"<<endl;
  sprintf(simply,"%s && flavB == 5",tmpsimply);
  signal = sighistounb(pstarsample, Vmes, fitResults, mespstarMC, 6000, 1000, simply, USECB, 0, matchMC); // o mesvubMC
  //
  //CONCEZIO  sprintf(simply," lepYes && flavB == 5");
  //CONCEZIO  if(su==1) 
  //CONCEZIO    signal = sighistounb(datavubin, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  //CONCEZIO  else 
  //CONCEZIO    signal = sighistounb(datamcvub, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  //CONCEZIO  //
  avubmc5 = signal.X();  aerrvubmc5 = signal.Y();   


  signal = ApplyCorrFactors(TVector2(avubmc3,aerrvubmc3),TVector2(avubmc4,aerrvubmc4),TVector2(avubmc5,aerrvubmc5),true,TString(pstarsample->GetName()),"lepYes == 1",correctionratiovub);
  avubmc = signal.X();
  aerrvubmc = signal.Y();
  //CONCEZIO  avubmc = signal.X()*LUMI_GENERIC/LUMI_SIGNAL;
  //CONCEZIO  aerrvubmc = signal.Y()*LUMI_GENERIC/LUMI_SIGNAL;
  cout << "P*FACT: avubmc = " << avubmc << "    error = " << aerrvubmc << endl;

  // -------------------
  //vub lepton mc OUT
  
  c1->cd(7);
  cout << "Fitting PStarsample Vub OUT flav 3!" << endl;
  sprintf(simply, " lepVub == 1 && lepVubSB == 0 && flavB == 3");
  signal = sighistounb(pstarsample, Vmes, fitResults, mespstarMC, 6000, 1000, simply, USECB, 0, matchMC);  // o mesvubMC
  //
  //CONCEZIO  sprintf(simply," lepYes && flavB == 3");
  //CONCEZIO  if(su==1) 
  //CONCEZIO    signal = sighistounb(datavubout, Vmes, fitResults, mesvuboutMC, 6000, 1000, simply, USECB, 0, matchMC);
  //CONCEZIO  else 
  //CONCEZIO    signal = sighistounb(datamcoth, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  //CONCEZIO
  avubout3 = signal.X();  aerrvubout3 = signal.Y();   


  c1->cd(8);
  cout << "Fitting PStarsample Vub OUT flav 4!" << endl;
  sprintf(simply, " lepVub == 1 && lepVubSB == 0 && flavB == 4");
  signal = sighistounb(pstarsample, Vmes, fitResults, mespstarMC, 6000, 1000, simply, USECB, 0, matchMC); // o mesvubMC
  //
  //CONCEZIO  sprintf(simply," lepYes && flavB == 4");
  //CONCEZIO  if(su==1) 
  //CONCEZIO    signal = sighistounb(datavubout, Vmes, fitResults, mesvuboutMC, 6000, 1000, simply, USECB, 0, matchMC);
  //CONCEZIO  else 
  //CONCEZIO    signal = sighistounb(datamcoth, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  //CONCEZIO
  avubout4 = signal.X();  aerrvubout4 = signal.Y();   


  c1->cd(9);
  cout <<"Fitting PStarsample Vub OUT flav 5!"<<endl;  
  sprintf(simply, " lepVub == 1 && lepVubSB == 0 && flavB == 5");
  signal = sighistounb(pstarsample, Vmes, fitResults, mespstarMC, 6000, 1000, simply, USECB, 0, matchMC); // o mesvubMC
  //
  //CONCEZIO  sprintf(simply," lepYes && flavB == 5");
  //CONCEZIO  if(su==1) 
  //CONCEZIO    signal = sighistounb(datavubout, Vmes, fitResults, mesvuboutMC, 6000, 1000, simply, USECB, 0, matchMC);
  //CONCEZIO  else 
  //CONCEZIO    signal = sighistounb(datamcoth, Vmes, fitResults, mesvubMC, 6000, 1000, simply, USECB, 0, matchMC);
  //CONCEZIO
  avubout5 = signal.X();  aerrvubout5 = signal.Y();   

  signal = ApplyCorrFactors(TVector2(avubout3,aerrvubout3),TVector2(avubout4,aerrvubout4),TVector2(avubout5,aerrvubout5),true,TString(pstarsample->GetName()),"lepYes == 1",correctionratiovubout);
  avubout = signal.X();
  aerrvubout = signal.Y();

  //CONCEZIO  avubout = signal.X()*LUMI_GENERIC/LUMI_SIGNAL;
  //CONCEZIO  aerrvubout = signal.Y()*LUMI_GENERIC/LUMI_SIGNAL;
  cout << "P*FACT: avubout = " << avubout << "    error = " << aerrvubout << endl;
  
  sprintf(line,"%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"mES_PStar.eps");
  c1->SaveAs(line);

  delete c1; c1=NULL;

  //======== WHAT IS DOING THIS STUFF HERE?????? PROBABLY VERY OLD STUFF ========================================================
  sprintf(line,"%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"mES_Aeff.eps");
  openEpsFile(line);

  c1 = new TCanvas("c1"," ",200,10,1200,1200);
  c1->Divide(2,3);

  c1->cd(1); 

  sprintf(simply," lepYaSe == 1 && flavB == 3 ");
  if(su == 1)
    signal = sighistounb(datavcboth, Vmes, fitResults, mesvcbcuts, 4000, 1000, simply, 0, 0, matchMC); 
  else
    signal = sighistounb(datamcvcb, Vmes, fitResults, mesvcbcuts, 4000, 1000, simply, 0, 0, matchMC); 
  flava3 = signal.X(); errflava3 = signal.Y();

  c1->cd(2);

  sprintf(simply," lepYaSe == 1 && flavB == 4 ");
  if(su == 1)
    signal = sighistounb(datavcboth, Vmes, fitResults, mesvcbcuts, 4000, 1000, simply, 0, 0, matchMC);
  else
    signal = sighistounb(datamcvcb, Vmes, fitResults, mesvcbcuts, 4000, 1000, simply, 0, 0, matchMC); 
  flava4 = signal.X(); errflava4 = signal.Y();

  c1->cd(3);
  sprintf(simply," lepYaSe == 1 && flavB == 5 ");
  if(su == 1)
    signal = sighistounb(datavcboth, Vmes, fitResults, mesvcbcuts, 4000, 1000, simply, 0, 0, matchMC);
  else 
    signal = sighistounb(datamcvcb, Vmes, fitResults, mesvcbcuts, 4000, 1000, simply, 0, 0, matchMC); 
  flava5 = signal.X(); errflava5 = signal.Y();
  
  datass = su == 1 ? datavcboth : datamcvcb;
  signal = ApplyCorrFactors(TVector2(flava3,errflava3),TVector2(flava4,errflava4),TVector2(flava5,errflava5),true,TString(datass->GetName()),"lepYaSe == 1",correctionratiovcb);
  vcbmcselected = signal.X();  
    
  c1->cd(4); 
  sprintf(simply," lepYaSe == 1 && flavB == 3");
  if(su == 1)
    signal= sighistounb(datavubin, Vmes, fitResults, mesvcbcuts, 2000, 200, simply, 0, 0, matchMC); 
  else
    signal= sighistounb(datamcvub, Vmes, fitResults, mesvcbcuts, 2000, 200, simply, 0, 0, matchMC); 
  flava3 = signal.X(); errflava3 = signal.Y();
  
  c1->cd(5); 
  sprintf(simply," lepYaSe == 1 && flavB == 4");
  if(su == 1)
    signal= sighistounb(datavubin, Vmes, fitResults, mesvcbcuts, 2000, 200, simply, 0, 0, matchMC);  
  else
    signal= sighistounb(datamcvub, Vmes, fitResults, mesvcbcuts, 2000, 200, simply, 0, 0, matchMC);  
  flava4 = signal.X(); errflava4 = signal.Y();  

  c1->cd(4); 
  sprintf(simply," lepYaSe == 1 && flavB == 5");
  if(su == 1)
    signal= sighistounb(datavubin, Vmes, fitResults, mesvcbcuts, 2000, 200, simply, 0, 0, matchMC);  
  else
    signal= sighistounb(datamcvub, Vmes, fitResults, mesvcbcuts, 2000, 200, simply, 0, 0, matchMC);  
  flava5 = signal.X(); errflava5 = signal.Y();

  datass = su == 1 ? datavubin : datamcvub;
  signal = ApplyCorrFactors(TVector2(flava3,errflava3),TVector2(flava4,errflava4),TVector2(flava5,errflava5),true,TString(datass->GetName()),"lepYaSe == 1",correctionratiovub);
  vubmcselected = signal.X();  

  //Print out the mES fits
  closeEpsFile();
  delete c1; c1 = NULL;
  // c2->Print(line);
  gStyle->SetPaperSize(20., 26.);

  //Fitting MC on MC
  //    //true number of vcb MC  ----vcbmcnocutdata
  //vcbmcorig = signal.X();
  //    //true number of vub MC -----vubmcnocutdata
  //vubmcorig = signal.X();
  //    //true number of other MC ----othmcnocutdata
  //othermcorig = signal.X();

  //   Commented out p* factor calculation.
  //   calcpstarfact  = (vubmc/vubmcnocut)/(vcbmc/vcbmcnocut);
  //   errcalcpstarfact = TMath::Sqrt((errvubmc/vubmc)*(errvubmc/vubmc) +  (errvcbmc/vcbmc)*(errvcbmc/vcbmc)); // approximately

  // 0.1061 = BR(B->Xclnu), 0.0020975 = BR(B->Xulnu) w/o taus!

  if (this->IsCM2()) {
    std::cout << "eff  = " << effDFN.X() << " +/- " << effDFN.Y() << std::endl;

    std::cout << "P*factor for semileptonic: " << (avubmc/(avcbmc+avubmc))*((0.1061+0.00224)/0.00224)/effDFN.X() << std::endl;
    std::cout << "P*factor for vcb:          " << (avubmc/avcbmc)*(0.1061/0.00224)/effDFN.X() << std::endl;
    
    // calcpstarfact = (avubmc/avcbmc)*(0.1061/0.0020975)/effDFN.X();
    // errcalcpstarfact = calcpstarfact*sqrt((aerrvubmc/avubmc)*(aerrvubmc/avubmc)+(aerrvcbmc/avcbmc)*(aerrvcbmc/avcbmc));    

    // calcpstarfact = (avubmc/(avcbmc+avubmc+avubout))*((0.1061+0.00224)/0.00224)/effDFN.X(); //CORRECT THESE HARD CODED NUMBERS

    //CB the MC fit does not apply any reweighting, compute standard vub correction
    if(BTYPE == 0){
      BRRATIOVALUETAIL_C = BRRATIOVALUETAIL_CNEUT;
      BRRATIOVALUETAIL_U = BRRATIOVALUETAIL_UNEUT;
    } else if(BTYPE == 1) {
      BRRATIOVALUETAIL_C = BRRATIOVALUETAIL_CCHAR;
      BRRATIOVALUETAIL_U = BRRATIOVALUETAIL_UCHAR;
    }
      
    calcpstarfact = (avubmc/(avcbmc+avubmc+avubout))*((BRRATIOVALUETAIL_C+BRRATIOVALUETAIL_U)/BRRATIOVALUETAIL_U)/effDFN.X();
    //statistical error only???
    if (su ==1 )   {
      if(avubout > 1)
	errcalcpstarfact = calcpstarfact * sqrt(aerrvubmc*aerrvubmc/(avubmc*avubmc) + aerrvcbmc*aerrvcbmc/(avcbmc*avcbmc) + aerrvubout*aerrvubout/(avubout*avubout));
      else
	{
	  cout << "CalcPstarFact:: WARNING avubout < 1! avubout " << avubout << " Taking out of the errcalcpstarfact formula!!!! " << endl;
	  errcalcpstarfact = calcpstarfact * sqrt(aerrvubmc*aerrvubmc/(avubmc*avubmc) + aerrvcbmc*aerrvcbmc/(avcbmc*avcbmc) );
	}
    }
    else errcalcpstarfact = calcpstarfact * sqrt(aerrvubmc*aerrvubmc/(avubmc*avubmc) + aerrvcbmc*aerrvcbmc/(avcbmc*avcbmc));
  
  
    //std::sqrt( __gnu_cxx::power(avcbmc/avubmc/(avubmc+avcbmc)*aerrvubmc,2)+__gnu_cxx::power(1./(avubmc+avcbmc)*aerrvcbmc,2) );
  }

  std::cout << "calcpstarfact = " << calcpstarfact << " +- " << errcalcpstarfact << std::endl;
  std::cout << std::endl << "=========> ending P*Factor calculations" << std::endl << std::endl;

  //  if(PSTARFACT>0){calcpstarfact = getPstarFactor(LEPTONPCUT);}

  // print out timer
  std::cout << "Timer for calcPstarFact: "; timer.Print();
  
  return;
}

void VirClass::compChisq(int cmb, int su){    

  // Chisq calculation :: histogram names shoud be updated
  double tempchisq = 0;
  //CB 
  //  int nQ2B = 9; //AP
  char name[100];
  cout << "CHISQ CALCULATION:: " <<vubcomp<<" "<<vcbcomp<<" "<<othcomp<<endl;
  double tempbin,temperr,tempbinvub,tempbinerrvub;
  double tempbinvcb,tempbinerrvcb,tempbinoth,tempbinerroth;
  NDOF = 0;
  chisq = 0;
  fHistFile->cd();
  if(!cmb) {
    for(int i=1;i<nB;i++){ //KT
      tempchisq = 0;
      sprintf(name, "%s","datachop");	         
      if(((TH1D*)gDirectory->Get(name))->GetBinContent(i)) {
	tempbin = ((TH1D*)gDirectory->Get(name))->GetBinContent(i);
	temperr = ((TH1D*)gDirectory->Get(name))->GetBinError(i);

	if(su){
	  sprintf(name, "%s","vubinchop");	         
	  tempbinvub = ((TH1D*)gDirectory->Get(name))->GetBinContent(i) * vubincomp;
	  tempbinerrvub = ((TH1D*)gDirectory->Get(name))->GetBinError(i) * vubincomp;
	} else{
	  sprintf(name, "%s","vubchop");	         
	  tempbinvub = ((TH1D*)gDirectory->Get(name))->GetBinContent(i) * vubcomp;
	  tempbinerrvub = ((TH1D*)gDirectory->Get(name))->GetBinError(i) * vubcomp;
	}
	if(su){
	  sprintf(name, "%s","vcbothchop");	         
	  tempbinvcb = ((TH1D*)gDirectory->Get(name))->GetBinContent(i) * vcbothcomp;
	  tempbinerrvcb = ((TH1D*)gDirectory->Get(name))->GetBinError(i) * vcbothcomp;
	} else{
	  sprintf(name, "%s","vcbchop");	         
	  tempbinvcb = ((TH1D*)gDirectory->Get(name))->GetBinContent(i) * vcbcomp;
	  tempbinerrvcb = ((TH1D*)gDirectory->Get(name))->GetBinError(i) * vcbcomp;
	}
	if(su){
	  sprintf(name, "%s","vuboutchop");
	  tempbinoth = ((TH1D*)gDirectory->Get(name))->GetBinContent(i) * vuboutcomp;
	  tempbinerroth = ((TH1D*)gDirectory->Get(name))->GetBinError(i) * vuboutcomp;
	} else{
	  sprintf(name, "%s","otherchop");	     
	  tempbinoth = ((TH1D*)gDirectory->Get(name))->GetBinContent(i) * othcomp;
	  tempbinerroth = ((TH1D*)gDirectory->Get(name))->GetBinError(i) * othcomp;
	  temperr = sqrt(temperr*temperr + tempbinerrvub*tempbinerrvub + tempbinerrvcb * tempbinerrvcb + tempbinerroth*tempbinerroth);
	}
	if(temperr<1) temperr = 1; 
	sprintf(name, "%s","datachop");	
	tempchisq = (tempbinvub + tempbinvcb + tempbinoth - ((TH1D*)gDirectory->Get(name))->GetBinContent(i))/temperr;     
	cout<<"Break of chi2 chop contrib:: "<<tempchisq<<" " <<NDOF<<" "<<((TH1D*)gDirectory->Get("datachop"))->GetBinContent(i)<<endl;
	NDOF++;
      }   
      chisq += tempchisq*tempchisq;
    }
  } else {
    for(int i=1;i<nMxB;i++){ 
      //CB      for(int ii=1;ii<5;ii++){ 
      for (int ii=1;ii<nQ2B;ii++){
	tempchisq = 0;
	sprintf(name,"datacomb");	         
	if(((TH1D*)gDirectory->Get(name))->GetBinContent(i,ii)) {
	  tempbin = ((TH1D*)gDirectory->Get(name))->GetBinContent(i,ii);
	  temperr = ((TH1D*)gDirectory->Get(name))->GetBinError(i,ii);

	  if(su){
	    sprintf(name,"vubincomb");	         
	    tempbinvub = ((TH1D*)gDirectory->Get(name))->GetBinContent(i,ii) * vubincomp;
	    tempbinerrvub = ((TH1D*)gDirectory->Get(name))->GetBinError(i,ii) * vubincomp;
	  } else{
	    sprintf(name,"vubcomb");	         
	    tempbinvub = ((TH1D*)gDirectory->Get(name))->GetBinContent(i,ii) * vubcomp;
	    tempbinerrvub = ((TH1D*)gDirectory->Get(name))->GetBinError(i,ii) * vubcomp;
	  }
	  if(su){
	    sprintf(name,"vcbothcomb");	         
	    tempbinvcb = ((TH1D*)gDirectory->Get(name))->GetBinContent(i,ii) * vcbothcomp;
	    tempbinerrvcb = ((TH1D*)gDirectory->Get(name))->GetBinError(i,ii) * vcbothcomp;
	  } else{
	    sprintf(name,"vcbcomb");	         
	    tempbinvcb = ((TH1D*)gDirectory->Get(name))->GetBinContent(i,ii) * vcbcomp;
	    tempbinerrvcb = ((TH1D*)gDirectory->Get(name))->GetBinError(i,ii) * vcbcomp;
	  }
	  if(su){
	    sprintf(name,"vuboutcomb");
	    tempbinoth = ((TH1D*)gDirectory->Get(name))->GetBinContent(i,ii) * vuboutcomp;
	    tempbinerroth = ((TH1D*)gDirectory->Get(name))->GetBinError(i,ii) * vuboutcomp;
	  } else{	  
	    sprintf(name,"othercomb");
	  	     
	    tempbinoth = ((TH1D*)gDirectory->Get(name))->GetBinContent(i,ii) * othcomp;
	    tempbinerroth = ((TH1D*)gDirectory->Get(name))->GetBinError(i,ii) * othcomp;
	  }
          temperr = sqrt(temperr*temperr + tempbinerrvub*tempbinerrvub + tempbinerrvcb * tempbinerrvcb + tempbinerroth*tempbinerroth);
	  if(temperr<1) temperr = 1; 
	  sprintf(name,"datacomb");
	  cout<<"Break of chi2 comb contrib:: "<<tempbinvub<<"  "<<tempbinvcb<<"  "<<tempbinoth<<"  "<<temperr<<"   "<< ((TH1D*)gDirectory->Get(name))->GetBinContent(i,ii)<<endl;
	  tempchisq = (tempbinvub + tempbinvcb + tempbinoth - ((TH1D*)gDirectory->Get(name))->GetBinContent(i,ii))/temperr;     
	  cout<<"Break of chi2 comb contrib:: "<<tempchisq<<" " <<NDOF<<" "<<((TH1D*)gDirectory->Get("datacomb"))->GetBinContent(i,ii)<<endl;
	  NDOF++;
	}   
	chisq += tempchisq*tempchisq;
      }
    }
  }

  
  if (FITOPT==0) {        // 2 parameters fit
    NDOF -= 2;
  } else if (FITOPT==1) { // 3 parameters fit
    NDOF -= 3;
  } else if (FITOPT==5) {
    NDOF -= 1;
  }
  if (NDOF !=0) {
    chisq = chisq / NDOF;
  } 
  std::cout << " Chi Square / NDoF of the Fit :" << chisq << std::endl;
  std::cout << " NDOF " << NDOF << std::endl;

  return;
}

void VirClass::makeBkgSubPlot(int su)
{
  gROOT->SetStyle("Plain");
  char name[200];
  double themax, themin;
  gStyle->SetOptStat(0); gStyle->SetOptTitle(0); gStyle->SetFillStyle(1001); 

  // get title for spectrum
  std::string xtitle("dummy(GeV)");
  if (FITQ2 == 0) xtitle = "M_{x} (GeV)";
  if (FITQ2 == 1) xtitle = "q^2 (GeV^2)";
  if (FITQ2 == 2) xtitle = "P_{+} (GeV)";

  TCanvas *c1 = new TCanvas("c1"," ",200,10,1300,520); 
  
  sprintf(name, "%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"fitresults.eps");
   
  openEpsFile(name);
  c1->Clear(); 
  c1->Divide(2,1);  c1->cd(1);
  sprintf(name, "%s","datachop");
  TH1 *datH = new TH1D(*(TH1D*)gDirectory->Get(name));
  datH->SetXTitle(xtitle.c_str());
  themax = datH->GetMaximum() * 1.2; 
  std::cout << "Maximum for data plot is " << themax << std::endl;
  datH->SetMaximum(themax); 
  datH->SetMarkerSize(1.); datH->SetMarkerColor(kBlack); 
  datH->SetMarkerStyle(20);
  datH->SetLineColor(kBlack);
  datH->GetXaxis()->SetTitleSize(0.08);
  datH->GetYaxis()->SetTitleSize(0.08);
  datH->Draw("pe");
    
  sprintf(name, "%s","allmcchop");
  TH1 *amcH = new TH1D(*(TH1D*)gDirectory->Get(name));
  amcH->SetLineColor(kBlack);
  amcH->SetFillColor(38);
  amcH->Draw("samehisto");  
    
  sprintf(name, "%s","allbkgchop");
  TH1 *abkH = new TH1D(*(TH1D*)gDirectory->Get(name));
  abkH->SetLineColor(kBlack);
  abkH->SetFillColor(kYellow);
  abkH->Draw("samehisto");
    
  if(!su){ sprintf(name,"SCotherchop");
  }else{ sprintf(name,"SCvuboutchop");}

  TH1 *othH = new TH1D(*(TH1D*)gDirectory->Get(name));
  if(su){
    othH->SetFillColor(kMagenta);
  } else {
    othH->SetFillColor(13);
  }
  othH->SetLineColor(kBlack);
  othH->Draw("samehisto");
   
  //Adding MC error
  sprintf(name, "%s","allmcchop");
  TH1 *boxerr = new TH1D(*(TH1D*)gDirectory->Get(name));
  boxerr->SetFillColor(33);
  boxerr->SetFillStyle(3003);
  boxerr->Draw("samee2");

  //  //Redraw Data for cleaning pourposes
  //   datH->Draw("same");
  
  //Redraw MC for cleaning pourposes
  sprintf(name, "%s","allmcchop");
  TH1 *proallmc = new TH1D(*(TH1D*)gDirectory->Get(name));
  proallmc->SetLineColor(38);
  proallmc->SetFillStyle(4000);
  proallmc->Draw("samehisto");

  sprintf(name, "%s","allbkgchop");
  TH1 *proabk = new TH1D(*(TH1D*)gDirectory->Get(name));
  proabk->SetLineColor(kYellow);
  proabk->SetFillStyle(4000);
  proabk->Draw("samehisto");

  //THStack *d = new THStack("d","MC and data");
  //datachop.SetLineColor(kBlack);
  //datachop.SetMarkerStyle(20);
  //d->Add(datachop);
  //TH1F *proallmc = (TH1F*)allmcchop->Clone();
  //proallmc.SetLineColor(kBlack);
  //proallmc.SetFillStyle(4000);
  //d->Add(proallmc);
  //d->Draw("sameh""nostack");
 
  //Redraw Data for cleaning pourposes
  datH->Draw("same");
    
  TLegendEntry *legge; 
  TLegend *leg;
  leg = new TLegend(0.6,0.6,0.88,0.89);
  leg->SetBorderSize(0); leg->SetTextSize(0.06);
  //make text size 0.08 to improve reading 
  leg->SetFillStyle(4000);  leg->SetFillColor(0); 
  if(su){
    legge = leg->AddEntry(amcH, "b #rightarrow ul#nu IN", "f"); 
    legge = leg->AddEntry(abkH, "b #rightarrow cl#nu + oth", "f"); 
    legge = leg->AddEntry(othH, "b #rightarrow ul#nu OUT", "f"); 
  } else{
    legge = leg->AddEntry(amcH, "b #rigtharrow ul#nu", "f"); 
    legge = leg->AddEntry(abkH, "b #rightarrow cl#nu", "f"); 
    legge = leg->AddEntry(othH, "other", "f"); 
  }
  legge = leg->AddEntry(datH, "data", "p"); 
  leg->Draw();
  shrinkPad(0.18,0.07,0.02,0.02);
  gPad->Update();
    
  c1->cd(2);
    
  sprintf(name, "%s","subdatachop");
  TH1 *sdaH = new TH1D(*(TH1D*)gDirectory->Get(name));
    
  if(!su){ sprintf(name,"SCvubchop");
  }else{ sprintf(name,"SCvubinchop");}
  TH1 *svuH = new TH1D(*(TH1D*)gDirectory->Get(name));
    
  themax = 1.2*sdaH->GetMaximum();
  if(1.2*svuH->GetMaximum() > themax) themax = 1.2*svuH->GetMaximum();
  sdaH->SetMaximum(themax);
    
  if(sdaH->GetMinimum() < 0) {
    themin = 1.2*sdaH->GetMinimum();
    sdaH->SetMinimum(themin);
  }
  sdaH->SetMarkerStyle(20);
  sdaH->SetStats(0);
  sdaH->SetXTitle(xtitle.c_str());
  sdaH->GetXaxis()->SetTitleSize(0.08);
  sdaH->GetYaxis()->SetTitleSize(0.08);
  sdaH->Draw();
    
  svuH->SetLineColor(kBlack);
  svuH->SetFillColor(38);
  svuH->DrawCopy("sameh");  
  sdaH->DrawCopy("same");
  TLegendEntry *legge2; 
  TLegend* leg2(0);
  if (FITQ2 == 0) {
    leg2 = new TLegend(0.5,0.6,0.88,0.89);
  } else if (FITQ2 == 1){
    leg2 = new TLegend(0.1,0.6,0.48,0.89);
  } else if (FITQ2 == 2) {
    leg2 = new TLegend(0.5,0.6,0.88,0.89);
  }
  leg2->SetBorderSize(0); //leg2->SetTextSize(0.08); 
  //restore 0.08 size to improve reading
  leg2->SetTextSize(0.06); 
  leg2->SetFillStyle(4000); 
  legge2 = leg2->AddEntry(svuH, "scaled MC", "f"); 
  legge2 = leg2->AddEntry(sdaH, "data subtr.", "p"); 
  leg2->Draw();
  TLine line(choplowB,0.,chophighB,0.);
  line.SetLineColor(kRed); line.SetLineWidth(2); line.SetLineStyle(2); line.Draw();
  shrinkPad(0.18,0.07,0.02,0.02);
  gPad->Update();
  closeEpsFile();

  delete c1;
    
  c1 = new TCanvas("c1"," ",200,10,800,520); 
  if (FITQ2 ==0){
    sprintf(name, "%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"mxspectrum.eps");
  } else if (FITQ2 == 1) {
    sprintf(name, "%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"q2spectrum.eps");
  } else if (FITQ2 == 2) {
    sprintf(name, "%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"pplusspectrum.eps");
  }
    
  openEpsFile(name);
 
  c1->Clear(); 
  c1->Divide(1);
  c1->cd(1);

  sdaH->Draw("h");
  svuH->DrawCopy("sameh");  
  sdaH->DrawCopy("sameh");
  line.SetLineColor(kRed); line.SetLineWidth(2); line.SetLineStyle(2); line.Draw();   
  leg2->Draw();

  closeEpsFile();
}


// calculate ratio of BR
void VirClass::ruslExtr(int comb, int su, int ck)
{
  // apply blinding factor
  blindfactor = 1.;
  if(BLINDING){ 
    blindfactor = getblindfact();
    vubSB *=  blindfactor;
    errvubSB *=  blindfactor;
    MCerrvubSB  *=  blindfactor;
  }

  S = vubSB;
  errS = errvubSB;
  
  // Various eff. calculations

  //  epsu = vubmcallforeff/vubmcleptforeff;
  epsu = vubmcallforeff_mixcorr/vubmcleptforeff;
  errepsu = sqrt(epsu*(1 - epsu)/vubmcleptforeff);
  // epsu_mixcorr= vubmcallforeff_mixcorr/vubmcleptforeff;
  // errepsu_mixcorr = sqrt(epsu_mixcorr*(1 - epsu_mixcorr)/vubmcleptforeff);

  std::cout << (comb+1) << "D::.....................epsu      " << epsu << " errepsu:   " << errepsu << std::endl;

  epschop    = 1.;
  errepschop = 0.;

  epsphsp    = 1.;
  errepsphsp = 0.;

  if (comb == 0) { // 1d case
    if (su) {    
      epschop = vubmcSB/vubmcallforeff_mixcorr;
      errepschop = sqrt(epschop*(1 - epschop)/vubmcallforeff_mixcorr);

      //   here we implement Bauer's correction for the geometrical acceptance
      //                 allow to compute BRBR with DFN only
    
      TVector2 effDFN(1., 0.);
      if(ck){
	if (FITQ2 == 0) {
	  effDFN = getEffFromDFN(MXBIN, VirClass::iVarMx);
	} else if (FITQ2 == 1) {
	  effDFN = getEffFromDFN(Q2BIN, VirClass::iVarQ2);
	} else if (FITQ2 == 2) {
	  effDFN = getEffFromDFN(PPLUSBIN, VirClass::iVarPplus);
	}
      } else {
	std::cout << "Error: option ck = " << ck << " not available for 1D fit! Exiting!" << std::endl;
	exit(EXIT_FAILURE);
      }
      epsphsp    = effDFN.X();
      errepsphsp = effDFN.Y();  //this is actually negligible

    } else {

      if (vubmcSB > vubmcallforeff_mixcorr) {
	epschop = 1;
	errepschop = 0;
      } else {
	epschop = vubmcSB/vubmcallforeff_mixcorr;
	errepschop = sqrt(epschop*(1 - epschop)/vubmcallforeff_mixcorr);
      }

    } // if (su)

  } else { // 2d case

    if (su) {
      epschop    = vubmcSB/vubmcallforeff_mixcorr;
      errepschop = sqrt(epschop*(1 - epschop)/vubmcallforeff_mixcorr);
      //CB here we implement Bauer's correction for the geometrical acceptance
      //allow to compute BRBR with DFN only
    
      if(ck){
	TVector2 tempeffDFN = getEffFromDFN2D(MXBIN,Q2BIN);
	epsphsp = tempeffDFN.X();
	errepsphsp = tempeffDFN.Y();  //this is actually negligible
     
	//?!? What was that for ?!?
	//      epsphsp = vubmc/(vubmc+vuboutmc);
	//      errepsphsp = sqrt(epsphsp*(1-epsphsp)/(vubmc+vuboutmc));
      } else { 
 	TVector2 tempeffBauer= getEffFromBauer(MXBIN,Q2BIN);
      
	//      epsphsp = tempeffBauer.X();
	//      errepsphsp = tempeffBauer.Y(); //this is actually part of the systematics!
      
	//CB geometrical acceptance from Bauer
	epsphsp = tempeffBauer.X();
	errepsphsp = 0.;          //the error is actually part of the systematics!
      }
    }
  }

  std::cout << "Normalization/eff:: vubmcSB  " << vubmcSB << "avubmcSB " << avubmcSB 
	    << " vubmcallforeff_mixcorr " << vubmcallforeff_mixcorr << " vubmcleptforeff " << vubmcleptforeff << std::endl;
  std::cout << (comb+1) << "D::" << (su ? "unfolding!!!   " : "               ") << (ck? "DFN" : "BLL") << "........." << std::endl;
  std::cout << (comb+1) << "D::.....................epschop   " << epschop << " errepschop:" << errepschop << std::endl;
  std::cout << (comb+1) << "D::.....................epsphsp   " << epsphsp << " errepsphsp: " << errepsphsp << std::endl;

  //CB  if(!comb){
  //CB    vubmcSB = avubmcSB;
  //CB  }

  // total efficiency for full branching fraction
  if(vubmcSB > vubmcallforeff_mixcorr){
    epstot = vubmcSB/vubmcleptforeff*epsphsp;
    errepstot = sqrt(epstot*(1 - epstot)/vubmcleptforeff); // xxx error on phsp is missing
  } else{
    epstot = epsu * epschop * epsphsp;
    errepstot = epstot*sqrt(errepsu*errepsu/epsu/epsu + 
			    errepschop*errepschop/epschop/epschop + 
			    errepsphsp*errepsphsp/epsphsp/epsphsp);
  }

  // and now total efficiency for partial branching fraction
  if(vubmcSB > vubmcallforeff_mixcorr){
    Pepstot = vubmcSB/vubmcleptforeff;
    errPepstot = sqrt(Pepstot*(1 - Pepstot)/vubmcleptforeff);
  } else{
    Pepstot = epsu * epschop;
    errPepstot = sqrt(epsu*epsu*errepschop*errepschop + epschop*epschop*errepsu*errepsu);
  }

  //factor to take into account the vub cont. into all events after lept cut
  //BRRATIOVALUETAIL for BR(b->ulnu) is assumed

  /* ANTONIO 26/03/2007 This is fact computation. To take into account mixing correction and correctionratio
     I recompute each member
  
  fact = vcbmc * (1 + BRRATIOVALUETAIL_U/BRRATIOVALUETAIL_C) / (totmc + vcbmc * BRRATIOVALUETAIL_U/BRRATIOVALUETAIL_C); 
  std::cout << "...fact = " << fact << std::endl;
  std::cout << "...vub correction in fact = " << 
    (1 + BRRATIOVALUETAIL_U/BRRATIOVALUETAIL_C) / (1 + vcbmc/totmc * BRRATIOVALUETAIL_U/BRRATIOVALUETAIL_C) << std::endl;

  */

  std::cout <<" Purity Factor (fact) for NSL Calculation: we take into account aslo Vub events from VUB file and rescale by LUMI "<<std::endl;
  fact = ( vcbmc + LUMI_GENERIC/LUMI_SIGNAL*(vubmc + vuboutmc) )/ (totmc + LUMI_GENERIC/LUMI_SIGNAL * (vubmc + vuboutmc)); 
  std::cout << "...fact = " << fact << std::endl;

  if(su){
    if(ck){ 
      // calcpstarfactor correction 
      
      //     calcpstarfact = 1.21925;       //    requiring an  acceptance window mx < 1.55 ----- DATA
      //      errcalcpstarfact = 0.0145597; 

//       calcpstarfact = 1.13744;       //    requiring an  acceptance window mx < 1.55 ----- MC
//       errcalcpstarfact = 0.0323338; 

      //calcpstarfact = 1.11895;     // no requiring an  acceptance window 
      //errcalcpstarfact = 0.026668; //

    } else{
//       TVector2 unfolpst = unfolPstarFact(MXBIN,Q2BIN);
//       calcpstarfact = unfolpst.X();
//       errcalcpstarfact = unfolpst.Y();
    }
    cout<<"WWW:::calcpstarfact........."<<calcpstarfact<<" errcalcpstarfact:  "<<errcalcpstarfact<<endl;
  }

  std::cout << "efficiencies........." << " epstot  " << epstot << "  Pepstot:  " << Pepstot << std::endl;
  std::cout << "...calcpstarfact = "<< calcpstarfact << " +- "<< errcalcpstarfact << std::endl;
  std::cout << "... vcbmc = " << vcbmc << "  totmc = " << totmc << "  tot = " << tot << "  S = " << S << std::endl;

  //Extract the BRBR with pstarfact calculated in the fit	 
  BRBR = S * (1/(tot*fact*calcpstarfact)) / (epstot);
  errBRBR = errS * (1/(tot*fact*calcpstarfact)) / (epstot);
  errBRBRMCstat=BRBR*sqrt(pow(MCerrvubSB/S,2)+pow(errepstot/epstot,2));

  PBRBR = S * (1/(tot*fact*calcpstarfact)) / (Pepstot);
  errPBRBR = errS * (1/(tot*fact*calcpstarfact)) / (Pepstot);
  errPBRBRMCstat = PBRBR*sqrt(pow(MCerrvubSB/S,2)+pow(errPepstot/Pepstot,2));

  return;
}


void VirClass::resultDumping(int cmb, int su) {

  //Dump results on file
  char name[200];
  fHistFile->cd();
  sprintf(name,"%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"results.dat");  
  ofstream outfile(name);
   
  outfile << "#NUMBERS FOR THE SCANS" << endl;
  outfile << endl;
  outfile << endl;
  outfile << " mxCut               "  << MXBIN       << endl;
  outfile << " pstarfact           "  << PSTARFACT   <<  endl; 
  outfile << " chopCut             "  << CHOPCUT   <<  endl;  
  outfile << " csiloCut            "  << CSILOCUT   <<  endl;  
  outfile << " csihiCut            "  << CSIHICUT   <<  endl;  
  outfile << " xloCut              "  << XLOCUT   <<  endl;  
  outfile << " xhiCut              "  << XHICUT   <<  endl;  
  outfile << " wloCut              "  << WLOCUT   <<  endl;  
  outfile << " whiCut              "  << WHICUT   <<  endl;  
  outfile << " q2loCut             "  << Q2LOCUT   <<  endl;  
  outfile << " q2hiCut             "  << Q2HICUT   <<  endl;  
  outfile << " ewpwloCut           "  << EWPWLOCUT   <<  endl;  
  outfile << " ewpwhiCut           "  << EWPWHICUT   <<  endl;  
  outfile << " leptonPCut          "  << LEPTONPCUT   <<  endl;
  outfile << " prmm1cut            "  << PRMM1CUT   <<  endl;
  outfile << " prmm2cut            "  << PRMM2CUT   <<  endl;
  outfile << " prmm3cut            "  << PRMM3CUT   <<  endl;  
  outfile << " pmissCutlo          "  << PMISSCUTLO <<  endl;
  outfile << " costmissCutlo       "  << COSTMISSCUTLO <<  endl;
  outfile << " costmissCuthi       "  << COSTMISSCUTHI <<  endl;
  outfile << " pcmsTrkloCut        "  << PCMSTRKLOCUT <<  endl;
  outfile << " mnuSqLow            "  << MNUSQLOW   <<  endl;  
  outfile << " mnuSqHigh           "  << MNUSQHIGH   <<  endl;  
  outfile << " chLow               "  << CHLOW   <<  endl;  
  outfile << " chHigh              "  << CHHIGH   <<  endl;  
  outfile << " depl                "  << DEPL   <<  endl;  
  outfile << " Btype               "  << BTYPE   <<  endl;  
  outfile << " lepttype            "  << LEPTTYPE   <<  endl;  
  outfile << " minintpur           "  << MININTPUR    <<  endl;
  outfile << " maxintpur           "  << MAXINTPUR    <<  endl;
  outfile << " nnpi0               "  << CUTNNPI0  <<  endl;
  outfile << " fact                "  << fact << endl;
  outfile << " pstarfact           "  << calcpstarfact << " +- " << errcalcpstarfact << endl;
  outfile << " BRBR                "  << BRBR << "  " << errBRBR << "  " << errBRBRMCstat << endl;
  outfile << endl;
  outfile << "PartialBRBR          "  << PBRBR << " +- " << errPBRBR << " +-  " << errPBRBRMCstat << endl;


  outfile << endl;
  outfile << endl;
  outfile << "Before Chi2 fit" << endl;
  outfile << endl;
  outfile << endl;
  if(su){
    outfile << "Vub IN  tot area = " << areavubmcSB << endl;
    outfile << "Vub OUT tot area = " << areaothSB << endl;
    outfile << "Vcb Oth tot area = " << areavcbSB << endl;
  } else{
    outfile << "Vub tot area = " << areavubmcSB << endl;
    outfile << "Vcb tot area = " << areavcbSB << endl;
    outfile << "oth tot area = " << areaothSB << endl;
  }
  outfile << endl;
  outfile << "Data 1' bin = "  << dataFirstBin << " +- " << dataErrFirstBin << endl;
  if(su){
    outfile << "Vub IN 1' bin = " << vubmcSB << " +- " <<errvubmcSB << endl;
    if(cmb){
      outfile << "Vub IN 1' bin old computation = " << avubmcSB << " +- " << aerrvubmcSB << endl;
    }
    outfile << "Vub OUT 1' bin = " << othFirstBin << " +- " << othErrFirstBin << endl;
    outfile << "Vcb Oth 1' bin = " << vcbFirstBin << " +- " << vcbErrFirstBin << endl;
  } else { 
    outfile << "Vub 1' bin = " << vubmcSB << " +- " << errvubmcSB << endl;
    if(cmb){
      outfile << "Vub IN 1' bin old computation = " << avubmcSB << " +- " << aerrvubmcSB << endl;
    }
    outfile << "Vcb 1' bin = " << vcbFirstBin << " +- " << vcbErrFirstBin << endl;
    outfile << "Oth 1' bin = " << othFirstBin << " +- " << othErrFirstBin << endl;
  }
  outfile << endl;
  outfile << endl;
  if(!cmb){
    if (FITQ2 == 0) {
      outfile << "MX FIT" << endl;
    } else if (FITQ2 == 1) {
      outfile << "Q2 FIT" << endl;
    } else if (FITQ2 == 2) {
      outfile << "P+ FIT" << endl;
    }
  }else{
    outfile << "COMBINED FIT" << endl;
  }
  outfile << endl;
  if(su){
    outfile << "Vub IN  comp = " << vubincomp << " +- " << errvubincomp << endl;
    outfile << "Vub OUT comp = " << vuboutcomp << " +- " << errvuboutcomp << endl;
    outfile << "Vcb Oth comp = " << vcbothcomp << " +- " << errvcbothcomp << endl;
  }else{
    outfile << "Vub comp = " << vubcomp << " +- " << errvubcomp << endl;
    outfile << "Vcb comp = " << vcbcomp << " +- " << errvcbcomp << endl;
    outfile << "Oth comp = " << othcomp << " +- " << errothcomp << endl;
  }
  outfile << endl;
  outfile << endl;
  if(su){
  if (cmb)  outfile << "Vub IN  fitted 1' bin = " << S/blindfactor << " +- " <<aerrvubmcSB*vubincomp/blindfactor << "(stat MC) +- " << errS/blindfactor << "(err fit)" << endl;
  else      outfile << "Vub IN  fitted 1' bin = " << S/blindfactor << " +- " <<errvubmcSB*vubincomp/blindfactor << "(stat MC) +- " << errS/blindfactor << "(err fit)" << endl;
  outfile << "Vub OUT fitted 1' bin = " << othSB << " +- " << errothSB << "(stat MC) +- " << errvuboutcomp*othFirstBin << "(err fit)"  << endl;
  outfile << "Vcb+Oth fitted 1' bin = " << vcbSB << " +- " << errvcbSB << "(stat MC) +- " << errvcbothcomp*vcbFirstBin << "(err fit)" << endl;
    
  //  outfile << "Vub OUT fitted 1' bin = " << othSB << " +- " << errothSB << "(stat MC) +- " << errfitothSB << "(err fit)"  << endl;
  //  outfile << "Vcb+Oth fitted 1' bin = " << vcbSB << " +- " << errvcbSB << "(stat MC) +- " << errfitvcbSB << "(err fit)" << endl;
  }else{
    outfile << "Vub fitted 1' bin = " << S/blindfactor << " +- " <<aerrvubmcSB*vubcomp/blindfactor << "(stat MC) +- " << errS/blindfactor << "(err fit)" << endl;
    outfile << "Vcb fitted 1' bin = " << vcbSB << " +- " << errvcbSB << "(stat MC) +- " << errvcbcomp*vcbFirstBin<< "(err fit)" << endl;
    outfile << "oth fitted 1' bin = " << othSB << " +- " << errothSB << "(stat MC) +- " << errothcomp*othFirstBin << "(err fit)"  << endl;
    
    
 //   outfile << "Vcb fitted 1' bin = " << vcbSB << " +- " << errvcbSB << "(stat MC) +- " << errfitvcbSB << "(err fit)" << endl;
 //   outfile << "oth fitted 1' bin = " << othSB << " +- " << errothSB << "(stat MC) +- " << errfitothSB << "(err fit)"  << endl;
  }
  outfile << endl;

  outfile << "Vub 1' true (mxhadgenwoph < MXBIN) = " << vubmcselected << endl;
  outfile << "Vcb 1' true = " << vcbmcselected << endl; 
 //  outfile << "oth 1' true = " << othermcselected << endl;
  outfile << endl;
  outfile << "EFFICIENCY Vub" << endl;
  outfile << endl;
  outfile << "Vub total MC (lepton cut) = " << vubmc << endl;
  outfile << "Vub MC (all cuts) = " << vubmcaftercuts << endl;
  outfile << "Vub MC (all cuts & Chop cut) = " << vubmcSB << endl;
  outfile << "Vub gene total MC (lepton cut) = " << vubmcleptforeff << endl;
  outfile << "Vub gene MC (all cuts) = " << vubmcallforeff_mixcorr << endl;
  outfile << "Eps_u =  " << epsu << " +- " << errepsu << endl;
  outfile << "Eps_Cut = " << epschop << " +- " << errepschop << endl;
  if(su){
    outfile << "Eps_PhSp = " << epsphsp << " +- " << errepsphsp << endl;
  }
  outfile << "Eps_tot = " << epstot << " +- " << errepstot << endl;
  outfile << endl; 
  outfile << endl;
  outfile << "NSL NUMBERS" << endl;
  outfile << endl;
  outfile << "Nsl = " << tot << endl;
  outfile << endl;
  outfile << "Nsl MC = " << totmc << endl;
  outfile << "Nsl - BG = " << vcbmc << endl;
  outfile << "(Nsl - BG)/Nsl (vub corrected) = " << fact << endl;
  outfile << endl;
  outfile << "Pstar fact = " << PSTARFACT << endl;
  outfile << endl;
  outfile << endl; 
  if(su){
    outfile << "Eff on Vcb Oth (Nvcb/(Nsl-BGsl)) = " << areavcbSB* vcbothcomp / (tot * fact) << " +- " <<areavcbSB* errvcbothcomp / (tot * fact) << endl;  
    outfile << "Eff on Vub OUT (other/(Nsl-BGsl)) = " << areaothSB * vuboutcomp / (tot * fact) << " +- " << areaothSB * errvuboutcomp / (tot * fact)  << endl;  
  }else{
    outfile << "Eff on Vcb (Nvcb/(Nsl-BGsl)) = " << areavcbSB* vcbcomp / (tot * fact) << " +- " <<areavcbSB* errvcbcomp / (tot * fact) << endl;  
    outfile << "Eff on other (other/(Nsl-BGsl)) = " << areaothSB * othcomp / (tot * fact) << " +- " << areaothSB * errothcomp / (tot * fact)  << endl;  
  }
  outfile << endl; 
  outfile << endl;
  outfile << "Nsig = " << S/epstot  << " +- " <<  errS/epstot   << endl;
  // ANTONIO 11/5/2007
  outfile << "Vub IN fitted 1' bin/LUMI_DATA = "<< S/epstot/LUMI_DATA  << " +- " <<  errS/epstot/LUMI_DATA  << endl;
  outfile << "Vub OUT fitted 1' bin/LUMI_DATA = " << othSB/LUMI_DATA << " +- " << errothSB/LUMI_DATA << "(stat MC) +- " << errfitothSB/LUMI_DATA << "(err fit)"  << endl;
  outfile << "Vcb fitted 1' bin/LUMI_DATA = "<< vcbSB/LUMI_DATA << " +- " << errvcbSB/LUMI_DATA << "(stat MC) +- " << errfitvcbSB/LUMI_DATA << "(err fit)" << endl;  
  outfile << "DATA 1'bin/LUMI_DATA = "<< dataFirstBin/LUMI_DATA << " +- " << dataErrFirstBin/LUMI_DATA << endl;
  outfile << "NSL/LUMI_DATA = "<<tot*fact/LUMI_DATA <<" +- " <<errtot*fact/LUMI_DATA<<endl;

  outfile << endl;
  outfile << endl; 
  outfile << "PartialBRBR = " << PBRBR << " +- " << errPBRBR << "(stat) +- " << errPBRBRMCstat << "(MC stat)" << endl;
  outfile << endl;
  outfile << endl; 
  outfile << "BRBR = " << BRBR << " +- " << errBRBR << "(stat) +- " << errBRBRMCstat << "(MC stat)" << endl;
  outfile << endl;
  outfile << "Chi Square of the Fit = " << chisq << endl;
  outfile << "NDOF = " << NDOF << endl;
  outfile << endl;
  outfile << endl;
  double Vub = 0.00445 * sqrt((BRBR * .104 * 1.55) / (0.002 * 1.622));
  outfile << "Vub(*10-3) = " << Vub*1000 << " +- " << Vub*1000*(errBRBR/(2*BRBR)) << "(stat) +- " << Vub*1000*errBRBRMCstat/(2*BRBR) << "(MC stat)" << endl;
  outfile << endl;
  outfile << endl;
  outfile << endl;
  outfile << endl;         
  outfile.close();

  sprintf(name, "%s%s%s.tex",DIRNAME.Data(),PREFIXOUT.Data(),texPrefix.Data());        
  cout << "**********************************************************************" << endl;
  cout << "DUMPING TEXFILE 3 " << name << endl;
  cout << "**********************************************************************" << endl;
  ofstream texfile(name);
  char texline[200];
  sprintf(texline, "\\def\\%ssemil{%7.0f \\pm %6.0f} ", texPrefix.Data(), tot, errtot); 
  texfile << texline << endl;
  sprintf(texline, "\\def\\%sbgsl{%5.0f \\pm %4.0f} ", texPrefix.Data(), (1.-fact)*tot, (1.-fact)*errtot); 
  texfile << texline << endl;
  sprintf(texline, "\\def\\%sslsub{%5.0f \\pm %4.0f} ", texPrefix.Data(), tot - (1.-fact)*tot, fact*errtot); 
  texfile << texline << endl;
  sprintf(texline, "\\def\\%sepssl{%5.4f \\pm %4.4f} ", texPrefix.Data(), calcpstarfact, errcalcpstarfact); 
  texfile << texline << endl;
  sprintf(texline, "\\def\\%snu{%5.0f \\pm %4.0f} ", texPrefix.Data(), S, errS); 
  texfile << texline << endl;
  if (su) {sprintf(texline, "\\def\\%sbgc{%5.0f \\pm %4.0f} ", texPrefix.Data(), vcbSB, errvcbothcomp*vcbFirstBin); 
  texfile << texline << endl;
  } else {   sprintf(texline, "\\def\\%sbgc{%5.0f \\pm %4.0f} ", texPrefix.Data(), vcbSB, errvcbcomp*vcbFirstBin);
  texfile << texline << endl;}
  if (su) {sprintf(texline, "\\def\\%sbgo{%5.0f \\pm %4.0f} ", texPrefix.Data(), othSB, errvuboutcomp*othFirstBin); 
  texfile << texline << endl;
  }else   { sprintf(texline, "\\def\\%sbgo{%5.0f \\pm %4.0f} ", texPrefix.Data(), othSB, errothcomp*othFirstBin);
  texfile << texline << endl;}
  sprintf(texline, "\\def\\%sepsu{%4.3f} ", texPrefix.Data(), epsu); 
  texfile << texline << endl;
  if (FITQ2 == 0) {  sprintf(texline, "\\def\\%sepsmx{%4.3f} ", texPrefix.Data(), epschop); 
  texfile << texline << endl;
  } else if (FITQ2 == 1) {  sprintf(texline, "\\def\\%sepsq2{%4.3f} ", texPrefix.Data(), epschop); 
  texfile << texline << endl;
  } else if (FITQ2 == 2) { sprintf(texline, "\\def\\%sepspplus{%4.3f} ", texPrefix.Data(), epschop); 
  texfile << texline << endl;
  }
  sprintf(texline, "\\def\\%sbrbr{%6.4f \\pm %5.4f} ", texPrefix.Data(), BRBR, errBRBR); 
  texfile << texline << endl;
  sprintf(texline, "\\def\\%sbrbrerrmc{%5.4f} ", texPrefix.Data(), errBRBRMCstat); 
  texfile << texline << endl;
  sprintf(texline, "\\def\\%spbrbr{%5.0f \\pm %4.0f} ", texPrefix.Data(), PBRBR*1E4, errPBRBR*1E4);
  texfile << texline << endl;
  sprintf(texline, "\\def\\%sBRBR{%5.0f \\pm %4.0f \\pm %4.0f} ", texPrefix.Data(), BRBR*1E4, errBRBR*1E4, errBRBRMCstat*1E4);
  texfile << texline << endl;
  sprintf(texline, "\\def\\%sPBRBR{%5.0f \\pm %4.0f \\pm %4.0f} ", texPrefix.Data(), PBRBR*1E4, errPBRBR*1E4, errPBRBRMCstat*1E4);
  texfile << texline << endl;
  sprintf(texline, "\\def\\%schi{%.1f /%i} ", texPrefix.Data(), chisq*NDOF, NDOF);
  texfile << texline << endl;
  //  sprintf(texline, "\\def\\%spsf{%5.4f \\pm %5.4f} ", texPrefix.Data(), calcpstarfact, errcalcpstarfact);
  //  texfile << texline << endl;
  sprintf(texline, "\\def\\%sPBR{%5.0f \\pm %4.0f} ", texPrefix.Data(), PBRBR*1E4, errPBRBR*1E4);
  // texfile << texline << endl;

  texfile.close(); 

} 
//Functions for graphics management
// ----------------------------------------------------------------------
void VirClass::shrinkPad(double b, double l, double r, double t) {
  gPad->SetBottomMargin(b); 
  gPad->SetLeftMargin(l);
  gPad->SetRightMargin(r);
  gPad->SetTopMargin(t);
}


// ----------------------------------------------------------------------
void VirClass::openEpsFile(TString name, Int_t style) {
  gROOT->SetStyle("Plain");
  fPostScriptFile = new TPostScript(name.Data(),style);
  //  cout << "Opened " << fPostScriptFile->GetName() << endl;
}


// --------------------------------------------------------------------
void VirClass::closeEpsFile() {
  //  cout << "Writing " << fPostScriptFile->GetName() << endl;
  fPostScriptFile->Close();
  delete fPostScriptFile;

}

//Routines needed for reweighting calculations
// ----------------------------------------------------------------------
double VirClass::getBsysweight(int decType, int thevub)
{
  double theweight = 1.;
  if(thevub)
    return theweight;
  
  if (DOBDECWEIGHT) theweight *= Bsem->weight(decType); 

  return theweight;
}

// ---------------------------------------------------------------------- 
double VirClass::getFFXulnuWeight(const int decType)
{
  
  double theweight = 1.;

  double mB= 5.279; //Maybe update to the newest measurement? 
  
  TLorentzVector p4l_lab(pxleptgen, pyleptgen, pzleptgen, elabgen);
  TLorentzVector p4B_lab(pxBlab, pyBlab, pzBlab, pEBlab);
  TLorentzVector p4X_lab(Xulabpx, Xulabpy, Xulabpz, XulabpE);
  
  if (TMath::Abs(decType)==11){ // FF reweighting for pilnu/pi0lnu  
    if (decType==11) {
      XSLBall04_pilnu* S3 = new XSLBall04_pilnu(p4B_lab, p4l_lab, p4X_lab,  "pilnu");
      theweight = S3->FromSP7ToThisModel();
      delete S3;
    } else if (decType==-11) {
      XSLBall04_pilnu* S3 = new XSLBall04_pilnu(p4B_lab, p4l_lab, p4X_lab,  "pi0lnu");
      theweight = S3->FromSP7ToThisModel();
      delete S3;
    }
    ((TH1D*)gDirectory->Get("pilnuweight"))->Fill(theweight);
  }

  if (TMath::Abs(decType)==13){ // FF reweighting for rholnu
    TLorentzVector p4Xdau_lab(Xudaulabpx, Xudaulabpy, Xudaulabpz, XudaulabpE);
    if (decType==13) {
      XSLBall05* S3 = new XSLBall05(p4B_lab, p4l_lab, p4X_lab, p4Xdau_lab, "rhoClnu", "NoError");
      theweight = S3->FromSP7ToThisModel();
      delete S3;
    } else if (decType==-13) {
      XSLBall05* S3 = new XSLBall05(p4B_lab, p4l_lab, p4X_lab, p4Xdau_lab, "rho0lnu", "NoError");
      theweight = S3->FromSP7ToThisModel();
      delete S3;
    }
    //    cout << "****** Test: Gvxbtyp = " << decType << "  theweight = " << theweight << endl;   
    ((TH1D*)gDirectory->Get("rholnuweight"))->Fill(theweight);
    ((TH2D*)gDirectory->Get("rholnuweightvsq2"))->Fill(q2Gen,theweight);
  }

  if (TMath::Abs(decType)==14){ // FF reweighting for omegalnu   
    TLorentzVector p4Xdau_lab(Xudaulabpx, Xudaulabpy, Xudaulabpz, XudaulabpE);
    XSLBall05* S3 = new XSLBall05(p4B_lab, p4l_lab, p4X_lab, p4Xdau_lab, "omegalnu", "NoError");
    theweight = S3->FromSP7ToThisModel();
    delete S3;
    //    cout << "****** Test: Gvxbtyp = " << decType << "  theweight = " << theweight << endl;    
    ((TH1D*)gDirectory->Get("omegalnuweight"))->Fill(theweight);
  }
  
  if (TMath::Abs(decType)==12){ // FF reweighting for etalnu
    XSLBall04_etalnu* S3 = new XSLBall04_etalnu(p4B_lab, p4l_lab, p4X_lab, "etalnu");
    theweight = S3->FromSP7ToThisModel();
    delete S3;
    //    cout << "****** Test: Gvxbtyp = " << decType << "  theweight = " << theweight << endl; 
    ((TH1D*)gDirectory->Get("etalnuweight"))->Fill(theweight);
  }

  if (TMath::Abs(decType)==15){ // FF reweighting for etaplnu   
    XSLBall04_etalnu* S3 = new XSLBall04_etalnu(p4B_lab, p4l_lab, p4X_lab, "etaplnu");
    theweight = S3->FromSP7ToThisModel();
    delete S3;
    //    cout << "****** Test: Gvxbtyp = " << decType << "  theweight = " << theweight << endl;
    ((TH1D*)gDirectory->Get("etaplnuweight"))->Fill(theweight);
  }
  
  
  //  cout << "**** FF check! theweight = " << theweight << endl; 
  if(theweight > 5) cout<<"PILNUWEIGHT>5! "<<theweight<<endl;
  return theweight;
  
}


// ----------------------------------------------------------------------
double VirClass::getFFDstarlnuWeight(const int decType)
{
  double theweight = 1.;
  
  
  if (DOFFWEIGHT>0 && decType==2 && TMath::Abs(ctvgen)<2.) { // B0 -> D*lnu FF
    static std::vector<double> sigma;
    static bool first = true;
    static double cor12(-0.84), cor13(+0.70), cor23(-0.83);
    
    sigma.resize(3);
    if (DOFFWEIGHT == 1) { sigma[0] =  0.; sigma[1] =  0.; sigma[2] =  0.; }
    if (DOFFWEIGHT == 2) { sigma[0] = +1.; sigma[1] =  0.; sigma[2] =  0.; }
    if (DOFFWEIGHT == 3) { sigma[0] = -1.; sigma[1] =  0.; sigma[2] =  0.; }
    if (DOFFWEIGHT == 4) { sigma[0] =  0.; sigma[1] = +1.; sigma[2] =  0.; }
    if (DOFFWEIGHT == 5) { sigma[0] =  0.; sigma[1] = -1.; sigma[2] =  0.; }
    if (DOFFWEIGHT == 6) { sigma[0] =  0.; sigma[1] =  0.; sigma[2] = +1.; }
    if (DOFFWEIGHT == 7) { sigma[0] =  0.; sigma[1] =  0.; sigma[2] = -1.; }

    if (DOFFWEIGHT > 10) {
      TRandom random(DOFFWEIGHT*1000+(1000-DOFFWEIGHT));
      
      // prepare correlation matrix
      TMatrixD cov(3,3);
      
      cov(0,0) =  1.;   cov(0,1) = cor12; cov(0,2) = cor13;
      cov(1,0) = cor12; cov(1,1) =  1.;   cov(1,2) = cor23;
      cov(2,0) = cor13; cov(2,1) = cor23; cov(2,2) =  1.;
  
      // do a Cholesky RtR decomposition and use Rt
      TDecompChol L2(cov); L2.Decompose(); L2.Print();
      TMatrixD *Lt= new TMatrixD(TMatrixD::kTransposed, L2.GetU());

      // create a vector of unit Gaussian variables
      TVectorD g(cov.GetNcols());
      
      for(Int_t k(0); k<g.GetNrows(); ++k) {
	g(k) = random.Gaus(0.,1.);
      }
      g*= (*Lt);
      
      sigma[0] = g(0);
      sigma[1] = g(1);
      sigma[2] = g(2);
    }
    //std::cout << "Systematics: Doing D*lnu FF reweighting in mode (" << DOFFWEIGHT << "): " << std::endl;
    
    
    // CLEO numbers as in SP5/SP6
    double def1,def2(-999); 
    if(REL!=18&&REL!=22){
      cout<<" USING D*lv FF reweighting for SP5/SP6 "<<endl;
      def1 = dstlnuFF(1.18,0.72,0.92);       
      
      //BaBar numbers with systematics variation
      double R1   = 1.396 + sigma[0]*0.075;
      double R2   = 0.885 + sigma[1]*0.048;
      double rho2 = 1.145 + sigma[2]*0.075;
      double def2 = dstlnuFF(R1, R2, rho2);
      //      std::cout << "Control: " << R1 << " " << R2 << " " << rho2 << std::endl;
    
      if (def1 <= 0.) {
	std::cout << "Warning: form factor for CLEO is negative: " << def1 << " Setting to 1!" << std::endl;
	def1 = 1.;
      }
      if (def2 <= 0.) {
	std::cout << "Warning: form factor for BaBar is negative: " << def2 << " Setting to 1!" << std::endl;
	def2 = 1.;
      }

      double def = 1.; if (def1>0. && def2>0.) def = def2/def1;

      if (def>100.) {
	std::cout << "Warning: D*lnu form factor weight too high " << def << " = " << def2 << "/" << def1
		  << " Setting to 10!" << std::endl;
	//      cout <<" kin "<<ctvgen<<" "<<ctlgen<<" " <<chigen<<" "<<q2Gen<<endl;
	def = 10.;
      }
    
      theweight *= def;    
      //      cout<<"DSTARLNUFF:: weight "<<theweight<<endl;

    } else {  // RELEASE 18
  
      // cout<<"USING D*lv FF reweighting for SP8 "<<endl;
      // BaBar numbers with systematics variation - Average of Art/Mandeep + Trieste analyses BAD1395v17

      double R1   = 1.417 + sigma[0]*TMath::Sqrt(0.061*0.061+0.044*0.044);
      double R2   = 0.836 + sigma[1]*TMath::Sqrt(0.037*0.037+0.022*0.022);
      double rho2 = 1.179 + sigma[2]*TMath::Sqrt(0.048*0.048+0.028*0.028);
  
      //This function reweights SP8 to new model in BAD 1395. v17
      theweight = dstlnuFFSP8(R1,R2,rho2);
      //      std::cout << "Control: R1 " << R1 << " R2 " << R2 << " rho2 " << rho2 <<" weight newmod/SP8 "<< theweight << std::endl;
      //      cout<<"DSTARLNUFF:: weight "<<theweight<<endl;
    }
  }

  if(theweight > 5) cout<<"DSTARLNUWEIGHT>5! "<<theweight<<endl;
  return theweight;
  
}


double VirClass::dstlnuFFSP8(double R1,double R2, double rho2){

  double mB= 5.279; //Maybe update to the newest measurement?
  double mDStar=2.01 ;  //Maybe update to the newest measurement?
  
  double cchi=cos(chigen);
  double weightDstarlnu=1.;

  XSLBToDstrlnu_DstrToDpi_CLN* S2 = new XSLBToDstrlnu_DstrToDpi_CLN(mB,mDStar,q2Gen,ctlgen,ctvgen,cchi,R1,R2,rho2);
  weightDstarlnu = S2->FromSP7ToThisModel();
  delete S2;

  ((TH1D*)gDirectory->Get("ffweight"))->Fill(weightDstarlnu);
  return weightDstarlnu;
}

// ----------------------------------------------------------------------
double VirClass::getDsysweight(int decDpi,int decDk,int decDks,int decDpiz,int decDlep,int decImode,int thevub) {

  double theweight = 1.;

  if(thevub) 
    return 1.;
 
  int bla(1);
  if(DODDECWEIGHT)
    theweight = Dvar->weight(decDpi,decDk,decDks,decDpiz,decDlep,decImode,bla);    

  return theweight;
  
}
// ----------------------------------------------------------------------
double VirClass::getGenericSPWeight()
{
  /*
    calculates weight factor Nevents/luminosity by run period and
    charged and neutral Bs.

    returns the inverse of this weight factor.
  */

  double weight(1.);

  std::string filename;
  if (fChain!=0 && fChain->GetCurrentFile()!=0) filename = fChain->GetCurrentFile()->GetName();

  if (this->IsCM2()&&REL==14) {

    if (filename.find("genbch") != std::string::npos || filename.find("SP-1235") != std::string::npos) {
      if (filename.find("Run1") != std::string::npos) weight = 3./( 24246000/19458963.);
      if (filename.find("Run2") != std::string::npos) weight = 3./(119356000/60266741.);
      if (filename.find("Run3") != std::string::npos) weight = 3./( 67974000/31061051.);
      if (filename.find("Run4") != std::string::npos) weight = 3./(332944433/99762620.);
    } else if (filename.find("genbnu") != std::string::npos || filename.find("SP-1237") != std::string::npos) {
      if (filename.find("Run1") != std::string::npos) weight = 3./( 28762000/19458963.);
      if (filename.find("Run2") != std::string::npos) weight = 3./(120299826/60266741.);
      if (filename.find("Run3") != std::string::npos) weight = 3./( 61310000/31061051.);
      if (filename.find("Run4") != std::string::npos) weight = 3./(336130399/99762620.);
    }

  } // if (this->IsCM2())

  // std::cout << "Debug: found filename " << filename << " with weight " << weight << std::endl;

  return weight;
}

// ----------------------------------------------------------------------
double VirClass::getSignalSPWeight()
{
  /*
    correct ratio of SP5/SP6 signal MC to reflect ratio of Run1-3/Run4 = 1.105 in data
    do this by reweighting the SP5 events
  */

  double weight(1.);

  if (! (this->IsCM2()&&REL==14)) return weight;

  std::string filename;
  if (fChain!=0 && fChain->GetCurrentFile()!=0) filename = fChain->GetCurrentFile()->GetName();

  if (this->IsCM2()) {
  
    if (filename.find("nre") != std::string::npos || filename.find("SP-2575") != std::string::npos) {
      if (filename.find("Run1") != std::string::npos || 
	  filename.find("Run2") != std::string::npos ||
	  filename.find("Run3") != std::string::npos ||
	  filename.find("SP5") != std::string::npos) weight = 1.128;
    } else if (filename.find("mix") != std::string::npos || filename.find("SP-3618") != std::string::npos) {
      if (filename.find("Run1") != std::string::npos ||
	  filename.find("Run2") != std::string::npos ||
	  filename.find("Run3") != std::string::npos ||
	  filename.find("SP5") != std::string::npos) weight = 0.908;
    }

  } // if (this->IsCM2())

  // std::cout << "Debug: found filename " << filename << " with weight " << weight << std::endl;

  return weight;
}

// ----------------------------------------------------------------------
double VirClass::getTrackingWeight() {
  double theweight = 1;
  if(DOTRKWEIGHT){theweight = totweightTrkMult;}
  return theweight;
}

// ----------------------------------------------------------------------
double VirClass::getNeutralWeight() {
  double theweight = 1;
  if(DONEUWEIGHT){theweight = totweightNutMult;}
  return theweight;
}


// ----------------------------------------------------------------------
double VirClass::getBrecoWeight(double theintpur) {
  int thebin =(int)(theintpur/(1./20));
  if (theintpur>1.)thebin = 19; 
  if (theintpur<0.)thebin = 0; 
  return BrecoWeight[thebin];
}

// ----------------------------------------------------------------------
double VirClass::getCascadeDecWeight() {
  return THECASCADEWEIGHT;
}

// ----------------------------------------------------------------------
double VirClass::FermiWeight(double kp, double deltamb, double deltaa){

  Double_t BMASS, BQMASS, A0;
  BMASS   = 5.2792;
  BQMASS  = 4.800;
  A0      = 1.29;
  
  double mb1 = BQMASS + deltamb;
  double a1 = A0 + deltaa ;
  
  double w81;

  Int_t nIntegral = 10000;
  const double kmin = -5.;
  const double kmax =  1.;
  double Nold = 0;
  double Nnew1(0);

  // -- Compute reweighting ratios
  for (int i = 0; i < nIntegral; ++i) {
    double kplus = (i+0.5)/((double)nIntegral)*(kmax-kmin)+kmin;
    Nold += (kmax-kmin)/((double)nIntegral)*fermi(kplus, BQMASS, A0);
    Nnew1 += (kmax-kmin)/((double)nIntegral)*fermi(kplus, mb1, a1);
  }
  double kpold = kp; 
  double kpnew1 = 5.279 - mb1 - (5.279 - BQMASS - kp);
  
  double fold = fermi(kpold, BQMASS, A0)/Nold; 
  double fnew1 = fermi(kpnew1, mb1, a1)/Nnew1;
  w81 = fnew1/fold; 
  
  return w81;
}
// ----------------------------------------------------------------------
// Shape function
double VirClass::fermi(double kp, double m, double a) {
  double BMASS   = 5.2792;
  double x = kp/(BMASS - m);
  if ((kp>-m) && (x <= 1.)) {
    return TMath::Power((1-x), a) * TMath::Exp((1+a)*x); 
  } 
  return 0.;
}

// ----------------------------------------------------------------------
int VirClass::rHistmx(double cmx){
  double   histRbA[14] = {0.0, 1.2,  1.341, 1.414, 1.549, 1.612,  1.732, 1.843,  1.949,  2.5, 3.0, 3.5, 4.0, 4.5};	  
  // Mx categories
  if(cmx<=histRbA[0]) return 0;
  for(int i =0; i <13; i++) { 
    if(cmx>histRbA[i] && cmx<=histRbA[i+1]) return i;
  }

  return 13;
    
}

// ----------------------------------------------------------------------
//! mx binning for generic BB MC (SP5/SP6)
int VirClass::genericHistmx(double cmx)
{
  double histRbA[20] = 
    { 0.30, 1.20, 1.26, 1.34, 1.41, 1.48, 1.55, 1.61, 1.67, 1.73, 
      1.79, 1.84, 1.90, 1.95, 2.00, 2.50, 3.00, 3.50, 4.00, 4.50 };

  // Mx categories
  if (cmx <= histRbA[0]) {
    std::cout << "Warning: Generic non-resonat b->ulv shouldn't starts before 0.3 GeV! mx = " << cmx << " rounding to 0.3 GeV!" <<std::endl;
    return 0;
  }

  for (int i = 0; i<20; i++) {
    if (cmx>histRbA[i] && cmx<=histRbA[i+1]) return i;
  }

  return 20;
}

// ----------------------------------------------------------------------
int VirClass::newrHistmx(double cmx){

  double   histRbA[8] = {0.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.5, 3.5};	  
  // Mx categories
  for(int i =0; i <8; i++)   if(cmx<histRbA[i]) return i-1;
  
  return 7;
  
}


// ----------------------------------------------------------------------
int VirClass::newbinrHistmx(double cmx){

  double   histRbA[8] = {0.0, 1.4, 1.6, 1.8, 2.0, 2.5, 3.0, 3.5};	  
  // Mx categories
  for(int i =0; i <8; i++)   if(cmx<histRbA[i]) return i-1;
  
  return 7;
  
}


// ----------------------------------------------------------------------
int VirClass::rHistel(double bmx){
  double   histREl[8]= { 0.0,0.5,1.,1.25,1.5,1.75,2.0,2.25};                                                               
  // El
  if(bmx<=histREl[0]) return 0;
  for(int i =0; i <7; i++) { 
    if(bmx>histREl[i] && bmx<=histREl[i+1]) return i; 
  }
  return 7;
  
}


// ----------------------------------------------------------------------
int VirClass::rHistq2(double amx){
  double   histRQ2[8] = { 0.0,2.5,5.,7.5,10.,12.5,15.,20};
  // Q2
  if(amx<=histRQ2[0]) return 0;
  for(int i =0; i <7; i++) {
    if(amx>histRQ2[i] && amx<=histRQ2[i+1]) return i;
  }
  return 7;
  
}

// ----------------------------------------------------------------------
void VirClass::readWeights(double wsys, const int runFlag) {
  char buffer[200];
  float pmax, thefactor;
  int i;
  if(DOBRECOWEIGHT){
    ifstream is3("tablebreco.dat");
    i = 0;  
    while (is3.getline(buffer, 200, '\n')) {
      if (buffer[0] == '#') {continue;}
      sscanf(buffer, "%f %f", &pmax, &thefactor);
      BrecoWeight[i] = thefactor; 
      i++;
    }
  }else{
    for(int j=0; j<20 ; j++){
      BrecoWeight[j] = 1;  
    }
  }    
  // read hybrid weights
  //----------------------------------------------
  int mxbin, q2bin, elbin; double WVal; char buffer2[200];
  char label[20];
  char binName[100];
  sprintf(buffer2, "%s", fWeightFile.Data());
  ifstream is3(buffer2);

  if (!is3) {
    std::cout << "Error: weight file " << buffer2 << " not found! Exiting!" << std::endl;
    exit(EXIT_FAILURE);
  } else {
    std::cout << "Reading fermi weights from file " << buffer2 << std::endl;
  }

  if(fprlRew==1){
    cout <<" 1D reweighting "<<endl;
    for (int y=0;y<42;y++){
      is3.getline(buffer2, 200, '\n');
      sscanf(buffer2, "%s %lf", binName, &WVal);
      TrueMxWeight[y] = wsys*WVal;
      cout << "mx bin weight" << y << " " << TrueMxWeight[y] << endl;
    }
  } else if(fprlRew==3) {
    cout <<" 3D reweighting "<<endl;
    for (int ys=0;ys<896;ys++){
      is3.getline(buffer2, 200, '\n');
      sscanf(buffer2, "%d %d %d %lf", &mxbin, &q2bin, &elbin, &WVal);
      if(WVal<0) {WVal =0;}
      MatrixW[ys] = wsys*WVal;
      //cout<<"MatrixW[ys]:: "<<MatrixW[ys]<<" "<<ys<<endl;
    }
  } else if(fprlRew==10) {
    cout <<"  reweighting 'a la Fortin "<<endl;
    for (int ys=0;ys<1024;ys++){
      is3.getline(buffer2, 200, '\n');
      sscanf(buffer2, "%s%lf", label,&WVal);
      if(WVal<0) {WVal =0;}
      newMatrixW[ys] = wsys*WVal;
      //cout<<"newMatrixW[ys]:: "<<newMatrixW[ys]<<" "<<ys<<endl;
      //cout<<"wsys_3  "<<wsys<<"  WVAl  " <<WVal<<endl;
    }
  } else if(fprlRew==11) {
    cout <<"  reweighting 'a la Fortin with the latest mx binning"<<endl;
    for (int ys=0;ys<1024;ys++){
      is3.getline(buffer2, 200, '\n');
      sscanf(buffer2, "%s%lf", label,&WVal);
      if(WVal<0) {WVal =0;}
      newMatrixW[ys] = wsys*WVal;
      //cout<<"newMatrixW[ys]:: "<<newMatrixW[ys]<<" "<<ys<<endl;
      //cout<<"wsys_3  "<<wsys<<"  WVAl  " <<WVal<<endl;
    }
  } else if(fprlRew==12) {
    std::cout << "  reweighting 'a la Fortin with the latest mx binning" << std::endl;

    fprlRew=11; // to apply the weights as assumed

    //Set SP8 Generic weights
    //SetGenericHybWeights();

    std::vector<double> inputs, bf(13);

    std::string buffer;
    while (getline(is3, buffer, '\n')) {
      if (buffer[0] == '#') continue;
      if (buffer.empty()) continue;
      
      std::istringstream bufferstream(buffer.c_str());
      int ok(0);
      std::string tag;
      
      if (bufferstream >> tag) {
	// read the rest of line
	std::string equal; 
	bufferstream >> equal;

	// check for consitency
	if (equal != "=") {
	  std::string input; bufferstream >> input;
	  std::cout << "Error: input of file " << fWeightFile << " inconsistend "
		    << "(" << tag << " " << equal << " " << input << " )! Exiting!" << std::endl;
	  exit(EXIT_FAILURE);
	}

	if (tag.find("weight") != std::string::npos) {
	  double d; if (bufferstream >> d) { inputs.push_back(d); ok = 1; }
	} else {
	  if (tag == "pi+")    { double d; if (bufferstream >> d) { bf[ 0] = d; ok = 1; }}
	  if (tag == "pi0")    { double d; if (bufferstream >> d) { bf[ 1] = d; ok = 1; }}
	  if (tag == "eta0")   { double d; if (bufferstream >> d) { bf[ 2] = d; ok = 1; }}
	  if (tag == "rho+")   { double d; if (bufferstream >> d) { bf[ 3] = d; ok = 1; }}
	  if (tag == "rho0")   { double d; if (bufferstream >> d) { bf[ 4] = d; ok = 1; }}
	  if (tag == "omega0") { double d; if (bufferstream >> d) { bf[ 5] = d; ok = 1; }}
	  if (tag == "etap0")  { double d; if (bufferstream >> d) { bf[ 6] = d; ok = 1; }}
	  if (tag == "Xu+")    { double d; if (bufferstream >> d) { bf[ 7] = d; bf[ 8] = d; ok = 1; }}
	  if (tag == "Xu0")    { double d; if (bufferstream >> d) { bf[ 9] = d; bf[10] = d; ok = 1; }}
	  if (tag == "tot+")   { double d; if (bufferstream >> d) { bf[11] = d; ok = 1; }}
	  if (tag == "tot0")   { double d; if (bufferstream >> d) { bf[12] = d; ok = 1; }}

	  if (tag == "form")   { ok = 1; }
	  if (tag == "mb")     { ok = 1; }
	  if (tag == "a")      { ok = 1; }

	  if (tag == "tag") {
	    std::string input; bufferstream >> input;
	    if (input == "HFAGComb06") { _shapeFunction = VirClass::eHFAGComb06; ok = 1; }
	    if (input == "babar05")    { _shapeFunction = VirClass::eBabar05;    ok = 1; }
	    if (input == "belle04")    { _shapeFunction = VirClass::eBelle04;    ok = 1; }
	  }
	}

	if (ok == 0) std::cout << "Warning: Don't know about variable " << tag 
			       << " in file " << fWeightFile << std::endl;
      
      }
    } // while (getline(is, buffer, '\n'))

    // check if enought weights read
    if (inputs.size() != 1024) {
      std::cout << "Error: file " << fWeightFile << " has only " << inputs.size() << " / 1024 weights! Exiting!" << std::endl;
      exit(EXIT_FAILURE);
    }
    
    // copy over and apply corrections
    for (int i(0); i<inputs.size(); ++i) {
      if (inputs[i] < 0.) inputs[i] = 0.;
      newMatrixW[i] = wsys * inputs[i];
    }

    if(REL==14){
    // calculate wfermi weights for SP5/SP6 for CM2 in 10^-4
      const double bfSP5[] = { 0.18, 0.09, 0.03, 0.26, 0.13, 0.13, 0.06, 0.616, 0.616, 0.616, 0.616, 1.351, 1.346 };
      const int nonr[] = { 5546000, 6255888, 5660000 }; // SP5, effective SP5, SP6
      const int res[]  = { 2772000, 2516976, 2278000 }; // SP5, effective SP5, SP6

      double ratio = 1.;
      if (runFlag == 1 || runFlag ==2 || runFlag == 3 || runFlag == 12) {
	ratio = double(res[1])/double(nonr[1]);
      } else if (runFlag == 4) {
	ratio = double(res[2])/double(nonr[2]);
      } else if (runFlag == 14) {
	ratio = double(res[1]+res[2])/double(nonr[1]+nonr[2]);
      }
      
      compmod.wfermivec.resize(11);
      for (int i(0); i < 7; ++i) compmod.wfermivec[i] = bf[i]/bfSP5[i];
      compmod.wfermivec[ 7] = ratio * bf[7]/(bfSP5[11]-bfSP5[7]) * 0.8512;
      compmod.wfermivec[ 8] = 0.; // this number is for CM1 -> use wfermifile.dat instead
      compmod.wfermivec[ 9] = ratio * bf[9]/(bfSP5[12]-bfSP5[9]) * 0.81247;
      compmod.wfermivec[10] = 0.; // this number is for CM1 -> use wfermifile.dat instead
    } else if(REL == 18 || REL == 22){

      // calculate wfermi weights for SP8 for CM2 in 10^-4
      const double bfSP8[] = { 0.133, 0.072, 0.084, 0.269, 0.145, 0.145, 0.084, 0.697, 0., 0.820};//the last two neq 0. here are the sum over all exclusive modes produced
      //      const double bfSP8[] = { 0.133, 0.072, 0.084, 0.269, 0.145, 0.145, 0.084, 0.402, 0., 0.530};  //Used only resonant modes that are in Generic MC.
      //Resonant and non resonant number of events calculated in GetGeneratedEvents(Int_t runperiod);
      //      const int nonr = 11512000; // SP8
      //      const int res  = 11512000; // SP8
      
      double ratio = 1.;
      ratio = double(Vub_excl_gene)/double(Vub_incl_gene);
      
      compmod.wfermivec.resize(11);
      for (int i(0); i < 7; ++i) compmod.wfermivec[i] = bf[i]/bfSP8[i];
      compmod.wfermivec[ 7] = ratio * bf[7]/(bfSP8[7])* 0.8443; //rescaled for taus and resonances not used in GENERIC MC
      compmod.wfermivec[ 8] = 0.; // this number is for CM1 -> use wfermifile.dat instead
      compmod.wfermivec[ 9] = ratio * bf[9]/(bfSP8[9])* 0.8295; //rescaled for taus and resonances not used in GENERIC MC
      compmod.wfermivec[10] = 0.; // this number is for CM1 -> use wfermifile.dat instead
    }
  } else 
    cout <<" No known reweighting applied "<<fprlRew<<endl;
  
  
  // prepare weights for generic MC (SP5/SP6)
  
  if(REL==14){

    double temp[20] = 
      { 0.55, 0.61, 0.85, 1.08, 1.21, 1.30, 1.30, 1.33, 1.36, 1.39,
	1.33, 1.42, 1.39, 1.39, 1.37, 1.30, 0.74, 0.99, 1.09, 1.00 };
    
    genericMatrixW.resize(20);
    for (int i(0); i<genericMatrixW.size(); ++i) {
      if (temp[i] == 0.) {
	std::cout << "Warning: generic weight for bin " << i << " is zero. Setting to 1!" << std::endl;
	temp[i] = 1.;
      }
      genericMatrixW[i] = wsys * temp[i];
    }
  } 
  if(REL==18){
    genericMatrixW.resize(1024);
    for (Int_t i=0; i<genericMatrixW.size(); ++i) 
      genericMatrixW[i] = wsys * 1;  //genericWeightsB[i];//THIS IS USELESS.
  }
  return;
}

// ----------------------------------------------------------------------
void VirClass::readpstarfactor()
{
  std::cout << "Reading pstarfactors from file" << std::endl;
  
  char buffer[200];
  float pmax, thefactor;
  int i;
  char name[100];
  if(LEPTTYPE==2) sprintf(name,"filepstar.dat");
  if(LEPTTYPE==0) sprintf(name,"filepstarele.dat"); 
  if(LEPTTYPE==1) sprintf(name,"filepstarmu.dat"); 
  ifstream is3(name);
  i = 15;  
  while (is3.getline(buffer, 200, '\n')) {
    if (buffer[0] == '#') {continue;}
    sscanf(buffer, "%f %f", &pmax, &thefactor);
    pstarfactor[i] = thefactor; 
    i--;
  }    
}


void VirClass::Debug(){

  for (int i=0; i<datamcvcb->numEntries(); i++){
    datamcvcb->get(i);
    if(  datamcvcb->weight() != 1)   cout<<"weight data"<< datamcvcb->weight()<<endl ;
  }
  //   for (int i=0; i<datamcvub->numEntries(); i++){
  //       datamcvub->get(i);
  //     cout<<"weight vub"<< datamcvub->weight()<<endl ;
  //   }
  //   for (int i=0; i<datamcvcb->numEntries(); i++){
  //       datamcvcb->get(i);
  //     cout<<"weight vcb"<< datamcvcb->weight()<<endl ;
  //   }
  //   for (int i=0; i<datamcoth->numEntries(); i++){
  //     datamcoth->get(i);
  //     cout<<"weight oth"<< datamcoth->weight()<<endl ;
  //   }
}

////////
//Tmp Debug old PRL rew
////////

// ----------------------------------------------------------------------
double VirClass::getTrueMxWeight(double thetrumx, int index) {
  //  cout<<"Entered function: "<<thetrumx<<endl;
  int thebin = TrueHist(thetrumx);
  if(index < 0) thebin = thebin + 21;
  return TrueMxWeight[thebin];
}

int VirClass::TrueHist(double mxt){
  double truehistbins[21] = {0.0, 1.2, 1.264, 1.341, 1.414, 1.483, 1.549, 1.612, 1.673, 1.732, 1.788, 1.843, 1.897, 1.949, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0};
  if(mxt<=truehistbins[0]) return 0;
  for(int ih =0; ih<20; ih++) {
    if(mxt>truehistbins[ih] && mxt<=truehistbins[ih+1]) return ih+1;
  }
  return 21;
}

void VirClass::doBkgSub(int mult,  int su){

  char name[100];
  //Background subtraction
  double  tempbin,temperr,tempbinvcb,tempbinerrvcb,temperrvcb;
  double  tempbinoth,tempbinerroth,temperroth;

  fHistFile->cd();

  if(UNFBINNING){
    cout << "vubcomp " << vubcomp << endl;
    cout << "vcbcomp " << vcbcomp << endl;
    cout << "errvcbcomp " << errvcbcomp << endl;
    cout << "othcomp " << othcomp << endl;
    cout << "errothcomp " << errothcomp << endl;
  }

  for(int ik=1;ik<nB;ik++){
    sprintf(name, "%s","datachop");	         
    tempbin = ((TH1D*)gDirectory->Get(name))->GetBinContent(ik);
    temperr = ((TH1D*)gDirectory->Get(name))->GetBinError(ik);

    if(su ==1){
      sprintf(name, "%s","vcbothchop");
      tempbinvcb = ((TH1D*)gDirectory->Get(name))->GetBinContent(ik) * vcbothcomp;
      tempbinerrvcb = ((TH1D*)gDirectory->Get(name))->GetBinError(ik) * vcbothcomp;
      temperrvcb = tempbinvcb * errvcbothcomp / vcbothcomp;
    } else{
      sprintf(name, "%s","vcbchop");
      tempbinvcb = ((TH1D*)gDirectory->Get(name))->GetBinContent(ik) * vcbcomp;
      tempbinerrvcb = ((TH1D*)gDirectory->Get(name))->GetBinError(ik) * vcbcomp;
      temperrvcb = tempbinvcb * errvcbcomp / vcbcomp;
      //temperrvcb = sqrt(temperrvcb * temperrvcb + tempbinerrvcb * tempbinerrvcb);     //THE MC STAT IS NOT INCLUDED 
    }
    if(su ==1){
      sprintf(name, "%s","vuboutchop");	         
      tempbinoth = ((TH1D*)gDirectory->Get(name))->GetBinContent(ik) * vuboutcomp;
      tempbinerroth = ((TH1D*)gDirectory->Get(name))->GetBinError(ik) * vuboutcomp;
      temperroth = tempbinoth * errvuboutcomp / vuboutcomp;     
      //temperroth = sqrt(temperroth * temperroth + tempbinerroth * tempbinerroth);     //THE MC STAT IS NOT INCLUDED 
    } else{
      sprintf(name, "%s","otherchop");	         
      tempbinoth = ((TH1D*)gDirectory->Get(name))->GetBinContent(ik) * othcomp;
      tempbinerroth = ((TH1D*)gDirectory->Get(name))->GetBinError(ik) * othcomp;
      temperroth = tempbinoth * errothcomp / othcomp;     
      //temperroth = sqrt(temperroth * temperroth + tempbinerroth * tempbinerroth);     //THE MC STAT IS NOT INCLUDED 
    }
    tempbin = tempbin - tempbinvcb - tempbinoth;
    temperr = sqrt(temperr*temperr + tempbinerrvcb*tempbinerrvcb + tempbinerroth*tempbinerroth);

    sprintf(name, "%s","subdatachop");	 
    ((TH1D*)gDirectory->Get(name))->SetBinContent(ik, tempbin);
    ((TH1D*)gDirectory->Get(name))->SetBinError(ik, temperr); 
  }	
  if(mult){
    for(int jk=1; jk<6; jk++){
      cout << "The " << jk << "s mult cat subtraction" << endl;
      for(int ik=1;ik<nB;ik++){
        sprintf(name, "%s%d","datachop",jk);	         
        tempbin = ((TH1D*)gDirectory->Get(name))->GetBinContent(ik);
        temperr = ((TH1D*)gDirectory->Get(name))->GetBinError(ik);
        sprintf(name, "%s%d","vcbchop",jk);	         
        tempbinvcb = ((TH1D*)gDirectory->Get(name))->GetBinContent(ik) * vcbcompcat[jk-1];
        tempbinerrvcb = ((TH1D*)gDirectory->Get(name))->GetBinError(ik) * vcbcompcat[jk-1];
        temperrvcb = tempbinvcb * errvcbcompcat[jk-1] / vcbcompcat[jk-1];
        //temperrvcb = sqrt(temperrvcb * temperrvcb + tempbinerrvcb * tempbinerrvcb);     //THE MC STAT IS NOT INCLUDED 
        sprintf(name, "%s%d","otherchop",jk);	         
        tempbinoth = ((TH1D*)gDirectory->Get(name))->GetBinContent(ik) * othcompcat[jk-1];
        tempbinerroth = ((TH1D*)gDirectory->Get(name))->GetBinError(ik) * othcompcat[jk-1];
        temperroth = tempbinoth * errothcompcat[jk-1] / othcompcat[jk-1];     
        //temperroth = sqrt(temperroth * temperroth + tempbinerroth * tempbinerroth);     //THE MC STAT IS NOT INCLUDED 
        tempbin = tempbin - tempbinvcb - tempbinoth;
        temperr = sqrt(temperr*temperr + tempbinerrvcb*tempbinerrvcb + tempbinerroth*tempbinerroth);
        sprintf(name, "%s%d","subdatachop",jk);	 
        ((TH1D*)gDirectory->Get(name))->SetBinContent(ik, tempbin);
        ((TH1D*)gDirectory->Get(name))->SetBinError(ik, temperr); 
      }	
    }
  }

  //Computes component in first bin with errors
  //  int sigB = 1 ;
  int sigB, firstB, lastB;
  vcbSB = errvcbSB = errfitvcbSB = vcbFirstBin = vcbErrFirstBin = 0;
  othSB = errothSB = errfitothSB = othFirstBin = othErrFirstBin = 0;
  vcbothSB = vuboutSB = evcbothSB2 = evuboutSB2 = efitvcbothSB2 = efitvuboutSB2 = 0;
  
  errvcbSBtemp = errvcbSB2 = errfitvcbSBtemp = errfitvcbSB2 = 0;
  errothSBtemp = errothSB2 = errfitothSBtemp = errfitothSB2 = 0;
  errvubmcSBtemp = aerrvubmcSB2 = 0;
  errvubSBtemp = errvubSB2 = errvubSBNOFITtemp = errvubSBNOFIT2 = 0;
  dataErrFirstBintemp = dataErrFirstBin2 = 0;
  vcbErrFirstBintemp = vcbErrFirstBin2 = othErrFirstBintemp = othErrFirstBin2 = 0;

//  vubmcSB = errvubmcSB = 0; not here otherwise we will reset in the 2D case...
  avubmcSB = aerrvubmcSB = 0;
  double vubSBFIT, errvubSBFIT, MCerrvubSBFIT;
  double vubSBNOFIT, errvubSBNOFIT, MCerrvubSBNOFIT; 
  vubSBFIT   = errvubSBFIT   = MCerrvubSBFIT = 0;
  vubSBNOFIT = errvubSBNOFIT = MCerrvubSBNOFIT = 0;
  vubSB = errvubSB = MCerrvubSB = 0;
  dataFirstBin = dataErrFirstBin = 0;

  firstB = 0; lastB = 1;
  // for(int d=0; d<nB; d++){
  //   if (mxB1[d]==MXBIN) {lastB = d;}
  // }

  if (FITQ2 == 0) {
    for(int d=0; d<nB; d++){
      if (mxB1[d]==MXBIN) {lastB = d;}
    }
  } else if (FITQ2 == 1) { 
    firstB = ((TH1D*)gDirectory->Get("vubchop"))->FindBin(CHOPBIN)- 1 ; lastB = nB - 1;
  } else if (FITQ2 == 2) {
    for(int d=0; d<nB; d++){
      if (pplusB1[d]==PPLUSBIN) {lastB = d;}
    }
  }

  if(UNFBINNING){ firstB = 0; lastB = ((TH1D*)gDirectory->Get("vubchop"))->FindBin(CHOPBIN);}
  for(int p = firstB; p < lastB; p++){
    sigB = p + 1;
    if(su){
      // vir
      sprintf(name, "%s","vcbothchop");	         
      vcbSB += ((TH1D*)gDirectory->Get(name))->GetBinContent(sigB) * vcbothcomp;
      errvcbSB2 += pow(((TH1D*)gDirectory->Get(name))->GetBinError(sigB) * vcbothcomp,2);
      errfitvcbSB2 += pow(((TH1D*)gDirectory->Get(name))->GetBinContent(sigB) * errvcbothcomp,2);

      sprintf(name, "%s","vuboutchop");	         
      othSB += ((TH1D*)gDirectory->Get(name))->GetBinContent(sigB) * vuboutcomp;
      errothSB2 += pow(((TH1D*)gDirectory->Get(name))->GetBinError(sigB) * vuboutcomp,2);
      errfitothSB2 += pow(((TH1D*)gDirectory->Get(name))->GetBinContent(sigB) * errvuboutcomp,2);

      sprintf(name, "%s","vubinchop");
      avubmcSB += ((TH1D*)gDirectory->Get(name))->GetBinContent(sigB);
      aerrvubmcSB2 += pow(((TH1D*)gDirectory->Get(name))->GetBinError(sigB),2);

    } else {   

      sprintf(name, "%s","vcbchop");	         
      vcbSB += ((TH1D*)gDirectory->Get(name))->GetBinContent(sigB) * vcbcomp;
      errvcbSB2 += pow(((TH1D*)gDirectory->Get(name))->GetBinError(sigB) * vcbcomp,2);
      errfitvcbSB2 += pow(((TH1D*)gDirectory->Get(name))->GetBinContent(sigB) * errvcbcomp,2);

      sprintf(name, "%s","otherchop");	         
      othSB += ((TH1D*)gDirectory->Get(name))->GetBinContent(sigB) * othcomp;
      errothSB2 += pow(((TH1D*)gDirectory->Get(name))->GetBinError(sigB) * othcomp,2);
      errfitothSB2 += pow(((TH1D*)gDirectory->Get(name))->GetBinContent(sigB) * errothcomp,2);
   
      sprintf(name, "%s","vubchop");
      avubmcSB += ((TH1D*)gDirectory->Get(name))->GetBinContent(sigB);
      aerrvubmcSB2 += pow(((TH1D*)gDirectory->Get(name))->GetBinError(sigB),2);
    }
    sprintf(name, "%s","subdatachop");  
    vubSBNOFIT += ((TH1D*)gDirectory->Get(name))->GetBinContent(sigB);
    errvubSBNOFIT2 += pow(((TH1D*)gDirectory->Get(name))->GetBinError(sigB),2);

    if(FITTOTSHAPE){
      sprintf(name, "%s","datachop");
      dataFirstBin += ((TH1D*)gDirectory->Get(name))->GetBinContent(sigB);
      dataErrFirstBin2 += pow(((TH1D*)gDirectory->Get(name))->GetBinError(sigB),2);
      if(su){
	sprintf(name, "%s","vcbothchop");
      } else{
	sprintf(name, "%s","vcbchop");
      }
      vcbFirstBin += ((TH1D*)gDirectory->Get(name))->GetBinContent(sigB);
      vcbErrFirstBin2 += pow(((TH1D*)gDirectory->Get(name))->GetBinError(sigB),2);
      if(su){
	sprintf(name, "%s","vuboutchop");
      }else{
	sprintf(name, "%s","otherchop");
      }
      othFirstBin += ((TH1D*)gDirectory->Get(name))->GetBinContent(sigB);
      othErrFirstBin2 += pow(((TH1D*)gDirectory->Get(name))->GetBinError(sigB),2);
    }
  }

  errvcbSB = sqrt(errvcbSB2);  errfitvcbSB = sqrt(errfitvcbSB2);
  errothSB = sqrt(errothSB2);  errfitothSB = sqrt(errfitothSB2);
//vubmcSB is computed somewhere else (chargeCorr) in the comb case...
//but this method is called in the no-comb case (1D) only! 


  /* ANTONIO 17-Dec-2008: why is that?
  vubmcSB = avubmcSB;	
  errvubmcSB = sqrt(aerrvubmcSB2);  
  */

  errvubSBNOFIT = sqrt(errvubSBNOFIT2);

  dataErrFirstBin = sqrt(dataErrFirstBin2); 
  vcbErrFirstBin = sqrt(vcbErrFirstBin2);
  othErrFirstBin = sqrt(othErrFirstBin2);
 
  cout << "control::: avubmcSB = " << avubmcSB << " error = " << errvubmcSB  << endl;

  if(su){
    vubSBFIT = dataFirstBin-vcbFirstBin*vcbothcomp-othFirstBin*vuboutcomp;
    MCerrvubSBFIT = errvubmcSB*vubincomp;
  
  } else{
    vubSBFIT = dataFirstBin-vcbFirstBin*vcbcomp-othFirstBin*othcomp;
    MCerrvubSBFIT = errvubmcSB*vubcomp;
  }

//  if(FITTOTSHAPE==2) {
    if(su){
      errvubSBFIT = errvubincomp*avubmcSB;
     /*
      MCerrvubSBFIT = sqrt(pow(MCerrvubSBFIT,2)
			   +pow(vcbFirstBin*errvcbothcomp,2)
			   +pow(othFirstBin*errvuboutcomp,2)
			   -pow(vcbFirstBin*errvcbothcompNOMC,2)
			   -pow(othFirstBin*errvuboutcompNOMC,2));
    */
    } else{
      errvubSBFIT = errvubcomp*avubmcSB;

	/*
      MCerrvubSBFIT = sqrt(pow(MCerrvubSBFIT,2)
			   +pow(vcbFirstBin*errvcbcomp,2)
			   +pow(othFirstBin*errothcomp,2)
			   -pow(vcbFirstBin*errvcbcompNOMC,2)
			   -pow(othFirstBin*errothcompNOMC,2));
	*/
    }
  /*
  }else{
    if(su){
      errvubSBFIT = sqrt(pow(dataErrFirstBin,2)
			 +pow(vcbFirstBin*errvcbothcomp,2)
			 +pow(othFirstBin*errvuboutcomp,2));
    }else{
      errvubSBFIT = sqrt(pow(dataErrFirstBin,2)
			 +pow(vcbFirstBin*errvcbcomp,2)
			 +pow(othFirstBin*errothcomp,2));
    }
  }
  */
  if(su){
    sprintf(name, "%s","vubinchop");
    areavubmcSB = ((TH1D*)gDirectory->Get(name))->Integral();
    sprintf(name, "%s","vcbothchop");
    areavcbSB = ((TH1D*)gDirectory->Get(name))->Integral();
    sprintf(name, "%s","vuboutchop");
    areaothSB = ((TH1D*)gDirectory->Get(name))->Integral();
  } else{
    sprintf(name, "%s","vubchop");
    areavubmcSB = ((TH1D*)gDirectory->Get(name))->Integral();
    sprintf(name, "%s","vcbchop");
    areavcbSB = ((TH1D*)gDirectory->Get(name))->Integral();
    sprintf(name, "%s","otherchop");
    areaothSB = ((TH1D*)gDirectory->Get(name))->Integral();
  }
  vubSB = vubSBNOFIT;
  errvubSB = errvubSBNOFIT;
  MCerrvubSB = MCerrvubSBNOFIT;
  if(FITTOTSHAPE){
    vubSB = vubSBFIT;
    errvubSB = errvubSBFIT;
    MCerrvubSB = MCerrvubSBFIT;
    cout<<"WWW:::1Do:: "<<"vubSB:   "<<vubSB<<endl;
  }

  //Rescaling of mX or q2 histograms
  //cb take care of pathological fits (e.g. depleted sample) 
  double vubcoef=vubcomp;
  double vubincoef=vubincomp;
  double vuboutcoef=vuboutcomp;
  if(su){
    if(vubincomp < 0.0001) {
      vubincoef = vubincompNOMC;
      vuboutcoef = vuboutcompNOMC;
    }
  }else{
    if(vubcomp<0.0001) vubcoef=vubcompNOMC;
  }
  if(su){
    ((TH1D*)gDirectory->Get("SCvuboutchop"))->Add(((TH1D*)gDirectory->Get("vuboutchop")),vuboutcoef);
    ((TH1D*)gDirectory->Get("SCvcbothchop"))->Add(((TH1D*)gDirectory->Get("vcbothchop")),vcbothcomp);
    ((TH1D*)gDirectory->Get("SCvubinchop"))->Add(((TH1D*)gDirectory->Get("vubinchop")),vubincoef);
  } else{
    ((TH1D*)gDirectory->Get("SCotherchop"))->Add(((TH1D*)gDirectory->Get("otherchop")),othcomp);
    ((TH1D*)gDirectory->Get("SCvcbchop"))->Add(((TH1D*)gDirectory->Get("vcbchop")),vcbcomp);
    ((TH1D*)gDirectory->Get("SCvubchop"))->Add(((TH1D*)gDirectory->Get("vubchop")),vubcoef);
  }

  //Making allBkg and allMC histos
  if(su){
    ((TH1D*)gDirectory->Get("allbkgchop"))->Add(((TH1D*)gDirectory->Get("vcbothchop")),((TH1D*)gDirectory->Get("vuboutchop")),vcbothcomp,vuboutcoef);
    ((TH1D*)gDirectory->Get("allmcchop"))->Add(((TH1D*)gDirectory->Get("allbkgchop")),((TH1D*)gDirectory->Get("vubinchop")),1,vubincoef);
  } else{
    ((TH1D*)gDirectory->Get("allbkgchop"))->Add(((TH1D*)gDirectory->Get("vcbchop")),((TH1D*)gDirectory->Get("otherchop")),vcbcomp,othcomp);
    ((TH1D*)gDirectory->Get("allmcchop"))->Add(((TH1D*)gDirectory->Get("allbkgchop")),((TH1D*)gDirectory->Get("vubchop")),1,vubcoef);
  }  
}

// ----------------------------------------------------------------------

void chi2vec(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag) {
  double chi2, tempchi, tempsig2;
  chi2 = tempchi = tempsig2 = 0;
  for(int i=0; i<5; i++){
    for(int j=0; j<5; j++){
      tempchi += multmatrix[i][j] * par[j];
      tempsig2 += pow(par[j]+datmult[i],2) * multmatrix[i][j];
      for(int k=0; k<5; k++)
	if(k!=i)
	  tempsig2 += pow(datmult[i],2) * multmatrix[k][j];
      if(j!=i)
	tempsig2 += pow(datmult[i]*vubsum*datmulterr[j]/datsum,2);
    }
    tempsig2 += pow((vubsum/datsum - datmult[i]*vubsum/datsum) * datmulterr[i],2);
    chi2 += pow(tempchi - datmult[i]*vubsum,2)/tempsig2;
    tempchi = 0;
    tempsig2 = 0;
  }
  f=chi2;
}

void VirClass::UnfHistos(int mult){

  // The m_X distributions
  TH1D* mxgenwoph_20 = new TH1D("mxhadgenwoph_20","mxhadgen wo photons",nB-1,0.,chophighB);
  TH1D* mxgenwoph_20_fit = new TH1D("mxhadgenwoph_20_fit","mxhadgen wo photons - fitted mult cat",nB-1,0.,chophighB);
  TH1D* mxhadfit_11 = new TH1D("mxhadfit_11","mxhadfit",nB-1,0.,chophighB);
  TH2D* detmat = new TH2D("detmat_4000","detector response",nB-1,0.,chophighB,nB-1,0.,chophighB);
  mxgenwoph_20->Sumw2();
  mxgenwoph_20_fit->Sumw2();
  mxhadfit_11->Sumw2();
  detmat->Sumw2();

  // Multiplicity category distributions
  TH1D* h_multgen = new TH1D("h_multgen","multiplicity category generated",6,0.,6.);
  TH1D* h_mult = new TH1D("h_mult","multiplicity category",6,0.,6.);
  TH2D* multmat = new TH2D("multmat","multiplicity categories matrix",6,0.,6.,6,0.,6.);
  TH2D* multmatpiz = new TH2D("multmatpiz","multiplicity categories matrix pi0",6,0.,6.,6,0.,6.);
  TH2D* multmatpic = new TH2D("multmatpic","multiplicity categories matrix charged pi",6,0.,6.,6,0.,6.);
  TH2D* multmatrhoz = new TH2D("multmatrhoz","multiplicity categories matrix rho0",6,0.,6.,6,0.,6.);
  TH2D* multmatrhoc = new TH2D("multmatrhoc","multiplicity categories matrix charged rho",6,0.,6.,6,0.,6.);
  TH2D* multprobmat = new TH2D("multprobmat","multiplicity categories probability matrix",6,0.,6.,6,0.,6.);
  h_multgen->Sumw2();
  h_mult->Sumw2();
  multmat->Sumw2();
  multmatpiz->Sumw2();
  multmatpic->Sumw2();
  multmatrhoz->Sumw2();
  multmatrhoc->Sumw2();
  multprobmat->Sumw2();
  
  // The m_ES distributions
  TH1D* mES = new TH1D("mES","mES after cuts",60,5.18,5.30);
  TH1D* mESqual = new TH1D("mESqual","mES after cuts and truth matching",60,5.18,5.30);
  TH1D* mES1 = new TH1D("mES1","mES after cuts",60,5.18,5.30);
  TH1D* mESqual1 = new TH1D("mESqual1","mES after cuts and truth matching",60,5.18,5.30);
  TH1D* mES2 = new TH1D("mES2","mES after cuts",60,5.18,5.30);
  TH1D* mESqual2 = new TH1D("mESqual2","mES after cuts and truth matching",60,5.18,5.30);
  TH1D* mES3 = new TH1D("mES3","mES after cuts",60,5.18,5.30);
  TH1D* mESqual3 = new TH1D("mESqual3","mES after cuts and truth matching",60,5.18,5.30);
  TH1D* mES4 = new TH1D("mES4","mES after cuts",60,5.18,5.30);
  TH1D* mESqual4 = new TH1D("mESqual4","mES after cuts and truth matching",60,5.18,5.30);


  char unfcuts[100];

  if(mult){
    // Get the factors to apply to the different multiplicity categories.
    double recweights[5], genweights[5], recweightserr[5];
    TMatrix recmat(5,5), mult2d(5,5), tempmat(5,5), genmat(5,5);
    double genmult[5], genmultrew[5], recmult[5], recmulterr[5];

    // Initializations
    for(int i=0; i<5; i++){
      recweights[i] = genweights[i] = recweightserr[i] = 0.;
      genmult[i] = genmultrew[i] = recmult[i] = recmulterr[i] = 0.;
      for(int j=0; j<5; j++){
	recmat(i,j) = 0.;      mult2d(i,j) = 0.;
	tempmat(i,j) = 0.;     genmat(i,j) = 0.;
	multmatrix[i][j] = 0.;
      }
    }

    sprintf(unfcuts,"%s%f","elmom>",TRUELEPTONPCUT);
    unftmcvub->fillHistogram(h_multgen,RooArgList(*Vmultcatgen),unfcuts);
    sprintf(unfcuts,"%s","lepYaSe && trumtch==2");
    unfmcvub->fillHistogram(h_mult,RooArgList(*Vmultcat),unfcuts);
    sprintf(unfcuts,"%s%f","lepYaSe && trumtch==2 && allmes>5.27&&elmom>",TRUELEPTONPCUT);
    unfmcvub->fillHistogram(multmat,RooArgList(*Vmultcat,*Vmultcatgen),unfcuts);

    sprintf(unfcuts,"%s%f","lepYaSe && trumtch==2 &&allmes>5.27&&vxbtyp==-11&&elmom>",TRUELEPTONPCUT);
    unfmcvub->fillHistogram(multmatpiz,RooArgList(*Vmultcat,*Vmultcatgen),unfcuts);
    sprintf(unfcuts,"%s%f","lepYaSe && trumtch==2 &&allmes>5.27&&vxbtyp==11&&elmom>",TRUELEPTONPCUT);
    unfmcvub->fillHistogram(multmatpic,RooArgList(*Vmultcat,*Vmultcatgen),unfcuts);
    sprintf(unfcuts,"%s%f","lepYaSe && trumtch==2 &&allmes>5.27&&vxbtyp==-13&&elmom>",TRUELEPTONPCUT);
    unfmcvub->fillHistogram(multmatrhoz,RooArgList(*Vmultcat,*Vmultcatgen),unfcuts);
    sprintf(unfcuts,"%s%f","lepYaSe && trumtch==2 &&allmes>5.27&&vxbtyp==13&&elmom>",TRUELEPTONPCUT);
    unfmcvub->fillHistogram(multmatrhoc,RooArgList(*Vmultcat,*Vmultcatgen),unfcuts);


    cout << "2d matrix probability version" << endl;

    double tempval;

    // Move to probability matrix (not for the fit)
    for(int i=1; i<7; i++){
      if(i<6) genmult[i-1] = h_multgen->GetBinContent(i+1);
      if(i<6) recmult[i-1] = h_mult->GetBinContent(i+1);
      if(i<6) vubmult[i-1] = recmult[i-1];
      for(int j=1; j<7; j++){
	multprobmat->SetBinContent(i,j,multmat->GetBinContent(i,j)/h_multgen->GetBinContent(j));
	cout <<  multmat->GetBinContent(i,j)/h_multgen->GetBinContent(j) << "  " << multprobmat->GetBinContent(i,j) << endl;
      }
    }

    for(int i=1; i<6; i++){
      for(int j=1; j<6; j++){
	tempval = multprobmat->GetBinContent(i+1,j+1);
	mult2d(i-1,j-1) = tempval;
	tempval = multmat->GetBinContent(i+1,j+1);
	multmatrix[i-1][j-1] = tempval;
	cout << i-1 << " " << j-1 << "  " << mult2d(i-1,j-1) << endl;
      }
    }

    // Get inverse
    Double_t *det = new Double_t;
    TMatrix invmult2d(mult2d);
    invmult2d.Invert(det);

    // Inversion ok?
    if(*det==0) cout << "Matrix inversion failed..." << endl;

    // Weights for reco
    cout << "Weights for reco " << endl;

    vubsum = 0;
    for(int i=0; i<5; i++)
      vubsum += vubmult[i];
    for(int i=0; i<5; i++){
      cout << "vubmult" << vubmult[i] << endl;
      vubmult[i] = vubmult[i]/vubsum;
      cout << "vubmult weight" << vubmult[i] << endl;
    }

    for(int i=0; i<5; i++){
      recweights[i] = datmult[i]/vubmult[i];
      recmat(i,i) = recweights[i];
      recweightserr[i] = pow((1/vubmult[i]/datsum - datmult[i]/datsum/vubmult[i])*datmulterr[i],2);
      cout << i << " " << recweightserr[i] << endl;
      recweightserr[i] +=  pow((datmult[i]/vubmult[i]/vubsum - datmult[i]/vubmult[i]/vubmult[i]/vubsum),2)*vubmult[i]*vubsum;
      cout << i << " " << recweightserr[i] << endl;
      for(int j=0; j<5; j++)
        if(j!=i){
          recweightserr[i] += pow((datmult[i]/datsum/vubmult[i])*datmulterr[j],2); 
          cout << i << " " << recweightserr[i] << endl;
          recweightserr[i] += pow(datmult[i]/vubmult[i]/vubsum,2)*vubmult[j]*vubsum;
          cout << i << " " << recweightserr[i] << endl;
        }

      recweightserr[i] = sqrt(recweightserr[i]);
      cout << i << " " << recweightserr[i] << endl;
      cout << i << " " << recweights[i] <<"+-" << recweightserr[i] << "  " << recmat(i,i) << endl;
    }
    
    tempmat.Mult(recmat, mult2d);
    genmat.Mult(invmult2d,tempmat);

    // Calculation of xtilde
    for(int i=0; i<5; i++)
      for(int j=0; j<5; j++)
	genmultrew[i] += genmat(i,j) * genmult[j];

    // xtilde via minimization
    double wtilde0, wtilde1, wtilde2, wtilde3, wtilde4, errwtilde[5], wtilde[5];
    wtilde0 = wtilde1 = wtilde2 = wtilde3 = wtilde4 = 0;
    TMinuit xMinuit(5);
    int ierflg;
    // initialize minuit
    xMinuit.SetFCN(chi2vec);

    xMinuit.mnparm(0, "wtilde0",  1., 0.001, 0., 10., ierflg);
    xMinuit.mnparm(1, "wtilde1",  1., 0.001, 0., 10., ierflg);
    xMinuit.mnparm(2, "wtilde2",  1., 0.001, 0., 10., ierflg);
    xMinuit.mnparm(3, "wtilde3",  1., 0.001, 0., 10., ierflg);
    xMinuit.mnparm(4, "wtilde4",  1., 0.001, 0., 10., ierflg);

    Double_t arglis[10];
    arglis[0] = 10000; // maxcalls
    arglis[1] = 0.001;  // tolerance
    xMinuit.mnexcm("HESSE", arglis, 0, ierflg);
    xMinuit.mnexcm("MIGRAD", arglis, 2, ierflg);
    xMinuit.mnexcm("HESSE", arglis, 0, ierflg);
    for(int i=0; i<5; i++)
      xMinuit.GetParameter(i,wtilde[i],errwtilde[i]);

    cout << "The test" << endl;
    double thetest[5], xtest[5];
    for(int i=0; i<5; i++){
      thetest[i] = xtest[i] = 0;
      cout << "btilde " << recmult[i]*recweights[i] << endl;
      cout << "check chi2 " << datmult[i]*vubsum << endl;
      for(int j=0; j<5; j++)
	thetest[i] += mult2d(i,j) * genmultrew[j];
      cout << "Axtilde   " << i << "  " << thetest[i] << endl;
      thetest[i] = 0;
      for(int j=0; j<5; j++)
	thetest[i] += multmatrix[i][j] * wtilde[j];
      cout << "AEwtilde fit " << i << "  " << thetest[i] << endl;
    }

    cout << "The reweighted gen vector and weights" << endl;

    for(int i=0; i<5; i++){
      cout << i << "  " << genmultrew[i] << endl;
      genmultrew[i] = genmultrew[i]/genmult[i];
      cout << i << "  " << genmultrew[i] << endl;
      cout << i << " wtilde  " << wtilde[i] << endl;
      cout << i << " errwtilde  " << errwtilde[i] << endl;
    }

    char name[100];
    TH1 *h;  TH2 *h2;
    for(int i=1; i<6; i++){
      sprintf(name,"%s%d", "mxhadgenwoph",i); h = new TH1D(name, name, nB - 1, 0., chophighB);  h->Sumw2();
      sprintf(name,"%s%d", "mxhadfit",i); h = new TH1D(name, name, nB - 1, 0., chophighB);  h->Sumw2();
      sprintf(name,"%s%d", "detmat",i); h2 = new TH2D(name, name, nB - 1, 0., chophighB, nB-1, 0., chophighB);  h2->Sumw2();
    }

    for(int i=1; i<6; i++){
      sprintf(name,"%s%d", "mxhadgenwoph",i);
      sprintf(unfcuts,"%s%d%s%f","multcatgen==",i,"&&elmom>",TRUELEPTONPCUT);
      unftmcvub->fillHistogram(((TH1D*)gDirectory->Get(name)),RooArgList(*Vmxgenwoph),unfcuts);
      sprintf(name,"%s%d", "mxhadfit",i);
      sprintf(unfcuts,"%s%d","lepYaSe && trumtch==2 &&allmes>5.27 && multcat==",i);
      unfmcvub->fillHistogram(((TH1D*)gDirectory->Get(name)),RooArgList(*Vchop),unfcuts);
      sprintf(name,"%s%d", "detmat",i);
      sprintf(unfcuts,"%s%d%s%f","lepYaSe && trumtch==2 &&allmes>5.27 && multcat==",i,"&&elmom>",TRUELEPTONPCUT);
      unfmcvub->fillHistogram(((TH2D*)gDirectory->Get(name)),RooArgList(*Vchop,*Vmxgenwoph),unfcuts);
    }

    // Now sum them up with weights
    mxgenwoph_20->Add(((TH1D*)gDirectory->Get("mxhadgenwoph1")),((TH1D*)gDirectory->Get("mxhadgenwoph2")),genmultrew[0],genmultrew[1]);
    mxgenwoph_20->Add(((TH1D*)gDirectory->Get("mxhadgenwoph3")),genmultrew[2]);
    mxgenwoph_20->Add(((TH1D*)gDirectory->Get("mxhadgenwoph4")),genmultrew[3]);
    mxgenwoph_20->Add(((TH1D*)gDirectory->Get("mxhadgenwoph5")),genmultrew[4]);

    mxgenwoph_20_fit->Add(((TH1D*)gDirectory->Get("mxhadgenwoph1")),((TH1D*)gDirectory->Get("mxhadgenwoph2")),wtilde[0],wtilde[1]);
    mxgenwoph_20_fit->Add(((TH1D*)gDirectory->Get("mxhadgenwoph3")),wtilde[2]);
    mxgenwoph_20_fit->Add(((TH1D*)gDirectory->Get("mxhadgenwoph4")),wtilde[3]);
    mxgenwoph_20_fit->Add(((TH1D*)gDirectory->Get("mxhadgenwoph5")),wtilde[4]);

    mxhadfit_11->Add(((TH1D*)gDirectory->Get("mxhadfit1")),((TH1D*)gDirectory->Get("mxhadfit2")),recweights[0],recweights[1]);
    mxhadfit_11->Add(((TH1D*)gDirectory->Get("mxhadfit3")),recweights[2]);
    mxhadfit_11->Add(((TH1D*)gDirectory->Get("mxhadfit4")),recweights[3]);
    mxhadfit_11->Add(((TH1D*)gDirectory->Get("mxhadfit5")),recweights[4]);

    detmat->Add(((TH1D*)gDirectory->Get("detmat1")),((TH1D*)gDirectory->Get("detmat2")),recweights[0],recweights[1]);
    detmat->Add(((TH1D*)gDirectory->Get("detmat3")),recweights[2]);
    detmat->Add(((TH1D*)gDirectory->Get("detmat4")),recweights[3]);
    detmat->Add(((TH1D*)gDirectory->Get("detmat5")),recweights[4]);

  }
  else{
    if(MU){
      sprintf(unfcuts,"%s%d%s%f","multcatgen==",MU,"&&elmom>",TRUELEPTONPCUT);
      unftmcvub->fillHistogram(mxgenwoph_20,RooArgList(*Vmxgenwoph),unfcuts);
    } else {
      sprintf(unfcuts,"%s%f","elmom>",TRUELEPTONPCUT);
      unftmcvub->fillHistogram(mxgenwoph_20,RooArgList(*Vmxgenwoph),unfcuts);


    }
    if(MU){
      sprintf(unfcuts,"%s%d","lepYaSe && trumtch==2 &&allmes>5.27&&multcatgen==",MU);
      unfmcvub->fillHistogram(mxhadfit_11,RooArgList(*Vchop),unfcuts);
      sprintf(unfcuts,"%s%d%s%f","lepYaSe && trumtch==2 &&allmes>5.27&&multcatgen==",MU,"&&elmom>",TRUELEPTONPCUT);
      unfmcvub->fillHistogram(detmat,RooArgList(*Vchop,*Vmxgenwoph),unfcuts);
    } else {
         sprintf(unfcuts,"%s","lepYaSe && trumtch==2 &&allmes>5.27");
	 unfmcvub->fillHistogram(mxhadfit_11,RooArgList(*Vchop),unfcuts);
	 sprintf(unfcuts,"%s%f","lepYaSe && trumtch==2 &&allmes>5.27&&elmom>",TRUELEPTONPCUT);
	 unfmcvub->fillHistogram(detmat,RooArgList(*Vchop,*Vmxgenwoph),unfcuts);
    }

    //The plots to check the truth matching
    sprintf(unfcuts,"%s","lepYaSe && trumtch==2");   
    unfmcvub->fillHistogram(mESqual,RooArgList(*Vallmes),unfcuts);
    sprintf(unfcuts,"%s","lepYaSe");
    unfmcvub->fillHistogram(mES,RooArgList(*Vallmes),unfcuts);
    
    //Plots to check the brecoqual for separate regions of mX
    sprintf(unfcuts,"%s","lepYaSe && trumtch==2 &&chop<0.5");   
    unfmcvub->fillHistogram(mESqual1,RooArgList(*Vallmes),unfcuts);
    sprintf(unfcuts,"%s","lepYaSe&&chop<0.5");
    unfmcvub->fillHistogram(mES1,RooArgList(*Vallmes),unfcuts);

    sprintf(unfcuts,"%s","lepYaSe && trumtch==2 &&chop<1.5&&chop>0.5");   
    unfmcvub->fillHistogram(mESqual2,RooArgList(*Vallmes),unfcuts);
    sprintf(unfcuts,"%s","lepYaSe&&chop<1.5&&chop>0.5");
    unfmcvub->fillHistogram(mES2,RooArgList(*Vallmes),unfcuts);

    sprintf(unfcuts,"%s","lepYaSe && trumtch==2 &&chop<2.5&&chop>1.5");   
    unfmcvub->fillHistogram(mESqual3,RooArgList(*Vallmes),unfcuts);
    sprintf(unfcuts,"%s","lepYaSe&&chop<2.5&&chop>1.5");
    unfmcvub->fillHistogram(mES3,RooArgList(*Vallmes),unfcuts);

    sprintf(unfcuts,"%s","lepYaSe && trumtch==2 &&chop>2.5");   
    unfmcvub->fillHistogram(mESqual4,RooArgList(*Vallmes),unfcuts);
    sprintf(unfcuts,"%s","lepYaSe&&chop>2.5");
    unfmcvub->fillHistogram(mES4,RooArgList(*Vallmes),unfcuts);


  }

  mxgenwoph_20->Write();
  mxhadfit_11->Write();
  detmat->Write();

  h_multgen->Write();
  h_mult->Write();
  multmat->Write();
  multprobmat->Write();

  cout << "---> WROTE THE UNFOLDING HISTOS" << endl;

  return;
}


// ----------------------------------------------------------------------
//Find the relative amount of different multiplicity categories in data and signal MC, used for unfolding histos
void VirClass::MultCorr(){
  cout << "The multiplicity corrections" << endl;
  char name[100];
  char comp[15];
  datmult[0]=datmult[1]=datmult[2]=datmult[3]=datmult[4]=datsum=0;
  datmulterr[0]=datmulterr[1]=datmulterr[2]=datmulterr[3]=datmulterr[4]=0;
  vubmult[0]=vubmult[1]=vubmult[2]=vubmult[3]=vubmult[4]=vubsum=0;

  for(int k=1;k<6;k++){
    sprintf(comp,"%s","subdatachop");
    sprintf(name,"%s%d",comp,k);
    datmult[k-1] = ((TH1D*)gDirectory->Get(name))->Integral();
    datsum += ((TH1D*)gDirectory->Get(name))->Integral();
    for(int i=1; i<nB; i++)
      datmulterr[k-1] += pow(((TH1D*)gDirectory->Get(name))->GetBinError(i),2);
    datmulterr[k-1] = sqrt(datmulterr[k-1]);
  }

  cout << "RELATIVE FRACTIONS MULTIPLICITY CATEGORIES" << endl;

  for(int k=1;k<6;k++){
    cout << "data cat " << k << "  " << datmult[k-1] << endl;
    datmult[k-1] = datmult[k-1]/datsum;
    cout << "data cat weight" << k << "  " << datmult[k-1] << endl;
  }

  return;
}

double  VirClass::dstlnuFF(double r1,double r2,double rho2){
  // now calculate the 4D pdf
  float mb(5.279),mdst(2.01);
  float hp,h0,hm,a1,v,a2,ha1;
  float cchi=cos(chigen);

  a2=(mb+mdst)/2/sqrt(mb*mdst);
  a1=a2*(1-q2Gen/pow((mb+mdst),2));
  v=a2*r1;
  a2=a2*r2;
  // h_a1(w) has ben factorized in front of everything
  ha1=1-rho2*((mb*mb+mdst*mdst-q2Gen)/2/mb/mdst-1);

  hp=(mb+mdst)*a1-2*mb*pxhadgen*v/(mb+mdst);
  hm=(mb+mdst)*a1+2*mb*pxhadgen*v/(mb+mdst);
  h0=(mb*mb-mdst*mdst-q2Gen)*(mb+mdst)*a1-pow((2*mb*pxhadgen),2)*a2/(mb+mdst);
  h0=h0/2/mdst/sqrt(q2Gen);

  return ha1*ha1*pxhadgen*q2Gen*(
				 (pow((1+ctlgen)*hp,2)+pow((1-ctlgen)*hm,2))*(1-ctvgen*ctvgen)+
				 (1-ctlgen*ctlgen)*pow((2*h0*ctvgen),2)-
				 2*(1-ctlgen*ctlgen)*(1-ctvgen*ctvgen)*(2*cchi*cchi-1)*hp*hm+
				 4*sqrt((1-ctlgen*ctlgen)*(1-ctvgen*ctvgen))*ctvgen*cchi*h0*
				 (-ctlgen*(hp+hm)+(hm-hp))
				 );

}
void ReadwFermiFile(const TString & file,vector<float>& vettore,int runs)
{
  ifstream fin;
  fin.open(file.Data());
  char buff[250];
  float tmp;
  int row=0;	
  while(fin.getline(buff,250,'\n')){
    if(buff[0]!='#'){
      row++;
      if(row==8||row==10){
	switch(runs){
	case 0:  sscanf(buff,"%f %*f %*f %*f %*s", &tmp); break; //CM1 case, not important
	case 12: sscanf(buff,"%f %*f %*f %*f %*s", &tmp); break; //Run1-2 
	case 3:  sscanf(buff,"%*f %f %*f %*f %*s", &tmp); break; //Run3 only
	case 4:  sscanf(buff,"%*f %*f %f %*f %*s", &tmp); break; //Run4 only
	case 14: sscanf(buff,"%*f %*f %*f %f %*s", &tmp); break; //Run1-4
	case 15: sscanf(buff,"%*f %*f %*f %f %*s", &tmp); break; //Run1-5
	default: sscanf(buff,"%f %*f %*f %*f %*s", &tmp); //runs flag invalid, default Run1-2
	}
      }else{
	sscanf(buff,"%f %*s",&tmp);
      }
      vettore.push_back(tmp);
    }
  }
  fin.close();
}

TVector2 VirClass::getEffFromDFN(const Double_t var, const int iType)
{
  //21 Jun 2007 Antonio: hack to provide EffDFN from command line
  if (EFFDFN != -99) return TVector2(EFFDFN,0);

  if (iType == VirClass::iVarMx)    return getEffFromDFN2D(var, 0.);
  if (iType == VirClass::iVarQ2)    return getEffFromDFN_Q2(var);
  if (iType == VirClass::iVarPplus) return getEffFromDFN_Pp(var);

  std::cout << "Error: unknown variable type " << iType << std::endl;

  return TVector2();
}

TVector2 VirClass::getEffFromDFN_Q2(const Double_t q2)
{
  TVector2 temp;

  //take numbers from GeneratorsQA of DFN

  if(1==1) {
    double tempeff = 0.15; temp.Set(tempeff, tempeff*0.2);
    std::cout << "====================================================================================" << std::endl;
    std::cout << "                                 W A R N I N G                                      " << std::endl;
    std::cout << "                                     DFN_Q2                                         " << std::endl;
    std::cout << " I am returning placeholders : " << temp.X() << " +/- " << temp.Y() << std::endl;
    std::cout << "====================================================================================" << std::endl;
  }

  return temp;  
}

TVector2 VirClass::getEffFromDFN_Pp(const Double_t Pp)
{
  TVector2 temp;

  //take numbers from GeneratorsQA of DFN
  if (_shapeFunction == VirClass::eHFAGComb06) 
    temp.Set(0.492116, 0.000819);
  else if (_shapeFunction == VirClass::eBabar05) 
    temp.Set(0.647241, 0.001030);
  else if (_shapeFunction == VirClass::eBelle04) 
    temp.Set(0.455654, 0.000755);
  else if ( _shapeFunction == VirClass::summer07) 
    temp.Set(0.553301,0.00131947);
  else
    temp.Set(0.646858, 0.001029);
  
  if(isfitMC()) {
    //    temp.Set(0.646858, 0.001029);    //    ANTONIO 11-Apr-2007
    //temp.Set(0.601127, 0.00140851); // Antonio 11-Apr-2007 SP8 EffDFN.
    //temp.Set(0.494769,0.000838); //Antonio 20-Apr-2007 SP8: calculated with pplusnog
    temp.Set(0.553301,0.00131947); //ANTONIO 11 Jun 2007 SP8: calculated with pplusnog and mb and a from HENNING AND OLIVER
  }

  if(temp.X() == 0. && temp.Y() == 0.) {
    double tempeff = 0.15; temp.Set(tempeff, tempeff*0.2);
    std::cout << "====================================================================================" << std::endl;
    std::cout << "                                 W A R N I N G                                      " << std::endl;
    std::cout << "                                     DFN_Pp                                         " << std::endl;
    std::cout << " I am returning placeholders : " << temp.X() << " +/- " << temp.Y() << std::endl;
    std::cout << "====================================================================================" << std::endl;
  }

  return temp;  
}

int VirClass::readDataFile(RooDataSet** dataset,TString datasetname) {
  
  char fname[200];
  sprintf(fname,"%s",DSETDIRNAME.Data());


  (*dataset)=NULL;

  if(fDatasetRootFile==NULL)
    fDatasetRootFile=new TFile(fname,"READ");
  
  (*dataset)=(RooDataSet*)fDatasetRootFile->Get(datasetname.Data());
  if((*dataset)!=NULL){
    cout<<"Successfully read dataset "<<(*dataset)->GetName()<<" from dataset.root file"<<endl;
    (*dataset)->Print();
    return 1;
  }  else {
    cout<<"Failed to read dataset "<<datasetname.Data()<<" from " << fname << " file"<<endl;
    return 0;
  }
}

void VirClass::writeDataFile(const vector<RooDataSet*>& idataset) {
  
  char fname[200];
  sprintf(fname,"%s",DSETDIRNAME.Data());
  TString filename(fname);
  
  openDataSetFile(filename);
  for(UInt_t i = 0; i < idataset.size(); i++){
    if(idataset[i] != NULL){
      if( !THECOMPARISON || ( THECOMPARISON && !strcmp( idataset[i]->GetName(),"PStar" ) || THECOMPARISON && !strcmp( idataset[i]->GetName(),"DATA") ) )  {
	cout << "Writing " << idataset[i]->GetName() << " in file " << fDatasetRootFile->GetName() << endl;
	idataset[i]->Write();
      }
    }
  }
  closeDataSetFile();
}

RooAbsPdf* VirClass::createThorsten(RooRealVar& mes)
{
  // modified gauz parameters
  RooRealVar* Thor =        new RooRealVar("ThoSigR","thosig r",0.9,0.2,1);
  RooRealVar* Thosigma_r1 = new RooRealVar("sigma_r1","sigma_r1",0.00235,0.00050,0.00290);
  RooRealVar* Thoxc =       new RooRealVar("ThoSigXc","Thosig xc",5.27966,5.270,5.2810);
  RooRealVar* Thosigma_r2 = new RooRealVar("sigma_r2","sigma_r2",0.00304,0.0015,0.0035);
  RooRealVar* Thosigma_l  = new RooRealVar("sigma_l","sigma_l",0.0017,0.00120,0.00280);
  RooRealVar* Thon =        new RooRealVar("ThoSigN","thosig n",1.2,0.1,3);
  RooRealVar* Thoalpha =    new RooRealVar("ThoSigAlpha","thosig alpha",4.2,3.4,4.5);

  if (_debug > 1) std::cout << "Building Thorstens Modified Triple Function" << std::endl;
  
  RooThorstenSig* pFunction = new RooThorstenSig("ThoSig","Thorstens Triple Function", mes, 
						 *Thor, *Thosigma_r1, *Thoxc, *Thosigma_r2, *Thosigma_l, *Thon, *Thoalpha);

  if (_debug > 2) pFunction->printCompactTree();

  return pFunction;
}

RooAbsPdf* VirClass::createCCB(RooRealVar& mes, const bool endpointCorrection, RooRealVar* Rendpoint)
{
  // return function
  RooAbsPdf* pFunction = 0;

  // modified crystal ball parameters (same for all functions)
  RooRealVar* Rm = new RooRealVar("ccbmean","mean of gaussian 1", 5.2795, 5.2789, 5.2806);
  RooRealVar* Rs = new RooRealVar("ccbsigma","width of gaussians", 0.003, 0.001, 0.007);
  RooRealVar* Ra = new RooRealVar("ccbalpha","alpha parameter", 0.529, 0.1, 0.7);
  RooRealVar* Rn = new RooRealVar("ccbn","n parameter", 5., 0.1, 20.);
  if (Rendpoint == 0) Rendpoint = new RooRealVar("ccbcutoff", "ccb cutoff", 5.2891, 5.288, 5.2944);

  if (endpointCorrection) {

    if (_debug > 1) std::cout << "Building sum of modified Crystal Ball" << std::endl;

    std::vector<Double_t> vWeight, vEndpoint;
    Double_t totalWeight = 0.;

    for (size_t i = 0; i < mesCor->mesPeriodMax(); ++i) {
      Double_t endPoint = mesCor->mesEndpoint(i) - 5.2891;
      Double_t weight = mesCor->mesWeight(i);

      if (weight == 0.) continue;
      totalWeight += weight;

      vWeight.push_back(weight);
      vEndpoint.push_back(endPoint);
    }

    for (size_t i = 0; i < vWeight.size(); ++i) vWeight[i] /= totalWeight;

    // build function
    pFunction = new RooSumCCB("ccb", "Modified Crystal Ball (ccb)", mes, *Rm, *Rs, *Ra, *Rn, *Rendpoint, vWeight, vEndpoint);
    Rendpoint->setConstant();

  } else {

    if (_debug > 1) std::cout << "Building single modified Crystal Ball" << std::endl;
    pFunction = new RooCCB("ccb", "Modified Crystal Ball (ccb)", mes, *Rm, *Rs, *Ra, *Rn, *Rendpoint);

  }

  if (_debug > 2) pFunction->printCompactTree();

  return pFunction;
}

RooAbsPdf* VirClass::createCB(RooRealVar& mes)
{
  // return function
  RooAbsPdf* pFunction = 0;

  // modified crystal ball parameters (same for all functions)
  RooRealVar* Rm = new RooRealVar("mean","cb: mean of gaussian 1", 5.28, 5.275, 5.285);
  RooRealVar* Rs = new RooRealVar("sigma","cb: width of gaussians", 0.003, 0.002, 0.004);
  RooRealVar* Ra = new RooRealVar("alpha","cb: alpha parameter", 1.3, 0., 10.);
  RooRealVar* Rn = new RooRealVar("n","cb: n parameter", 3.46, 1., 7.);

  if (_debug > 1) std::cout << "Building Crystal Ball Function" << std::endl;
  pFunction = new RooCBShape("cb", "Crystal Ball", mes, *Rm, *Rs, *Ra, *Rn);

  if (_debug > 2) pFunction->printCompactTree();

  return pFunction;
}

RooAbsPdf* VirClass::createArgus(RooRealVar& mes, const bool endpointCorrection)
{
  // return function
  RooAbsPdf* pFunction = 0;

  // argus parameters (same for all functions)
  RooRealVar* pArgPar = new RooRealVar("ar", "argus shape parameter", -60., -100., -10.);
  RooRealVar* pCutOff = new RooRealVar("cutoff", "argus cutoff", 5.2891, 5.288, 5.292);

  if (endpointCorrection) {

    if (_debug > 1) std::cout << "Building Sum of Argus PDFs" << std::endl;

    std::vector<Double_t> vWeight, vEndpoint;
    Double_t totalWeight = 0.;

    for (size_t i = 0; i < mesCor->mesPeriodMax(); ++i) {
      Double_t endPoint = mesCor->mesEndpoint(i) - 5.2891;
      Double_t weight = mesCor->mesWeight(i);

      if (weight == 0.) continue;
      totalWeight += weight;

      vWeight.push_back(weight);
      vEndpoint.push_back(endPoint);
    }

    for (size_t i = 0; i < vWeight.size(); ++i) vWeight[i] /= totalWeight;

    pFunction = new RooSumArgusBG("a", "Argus PDF", mes, *pCutOff, *pArgPar, vWeight, vEndpoint);
    pCutOff->setConstant();

  } else {

    if (_debug > 1) std::cout << "Building single Argus" << std::endl;
    pFunction = new RooArgusBG("a", "Argus PDF", mes, *pCutOff, *pArgPar);

  }

  if (_debug > 2) pFunction->printCompactTree();
  
  return pFunction;
}

void  VirClass::getSOverPk(const char* comp, int mcat, int signalUnfolding){


  if(_debug>2)
    std::cout<<" Now determining signal to peaking BKG ratios for dataset "<<comp<<std::endl;

  std::vector<double> fitResults;

  std::map<std::string, RooDataSet*> dataSets; // xxx maybe move somewhere more general
  //CB  dataSets["data"] = datadata;
  if (signalUnfolding == 1) {
    dataSets["vubin"]  = datavubin; 
    dataSets["vubout"] = datavubout;
    dataSets["vcboth"] = datavcboth;
  } else {
    dataSets["vub"]    = datamcvub;
    dataSets["vcb"]    = datamcvcb; 
    dataSets["other"]  = datamcoth;
  }

  if (dataSets.find(comp) == dataSets.end()) {
    std::cout << "getSOverPk: No dataset with name " << comp << " found! Doing nothing!" << std::endl;
    std::cout << "This message is OK for data" << std::endl;
    return;
  }
    

  //---------------------------------------------------------


  TVector2 signalsig;
  char simply[100];

  double sigs[nB-1][2]; double errsigs[nB-1][2];
  double rat, errrat;
  double all[2]; double allerr[2];
  double allrat; double allraterr;

  int catnum = 1;  // Multiplicity categories
  if(mcat) catnum = 5;

  for (int k=1; k<catnum+1; k++) {
    for(int jMtch=1; jMtch<3; jMtch++) {
      
      TCanvas *c2  = new TCanvas("c2"," ",200,10,1400,1200); 
      c2->Clear();
      c2->Divide(5, 4);
      
      //Calculating default fits parameters.
      
      c2->cd(1); 

      //CB USECB = 0 in order to refit the pdf parameters for signal and background
      
      sprintf(simply,"%s%.3f%s%.3f%s%d","(chop>",choplowB,") && chop<",chophighB," && lepYaSe==1 && trumtch ==",jMtch);
      
      
      if(signalUnfolding == 1){
	if (std::string(comp) == "vubin") {
	  signalsig = sighistounb(datavubin,  Vmes, fitResults, mesvubcuts, 2500., 200., simply, 0, 0, jMtch);
	} else if (std::string(comp) == "vubout") {
	  signalsig = sighistounb(datavubout, Vmes, fitResults, mesvubcuts, 2500., 200., simply, 0, 0, jMtch);
	} else if (std::string(comp) == "vcboth") {
	  signalsig = sighistounb(datavcboth, Vmes, fitResults, mesothcuts,  800., 180., simply, 0, 0, jMtch);
	}
      } else {
	if (std::string(comp) == "vub") {
	  signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubcuts, 2500., 200., simply, 0, 0, jMtch);
	} else if (std::string(comp) == "vcb") {
	  signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbcuts, 4000., 700., simply, 0, 0, jMtch);
	} else if (std::string(comp) == "other") {
	  signalsig = sighistounb(datamcoth, Vmes, fitResults, mesothcuts,  800., 180., simply, 0, 0, jMtch);
	}
      }
      
      //CB Get the S/peakingBG fraction on the full sample and use it on low statistics bins
      all[jMtch-1] = signalsig.X(); allerr[jMtch-1] = signalsig.Y(); 

      // And now the 1d plane is filled
      
      
      for (int iBin=1; iBin< nB; iBin++) {  

        c2->cd(iBin+1);

	// prepare the cut
	char simply[400];
	sprintf(simply,"%s%.3f%s%.3f%s%d%s","(chop>",chopB1[iBin-1],") && (chop<",chopB1[iBin],") && (trumtch==", jMtch,") && lepYaSe==1");
	if (mcat) { sprintf(simply,"%s%s%d%s", simply," && (multcat== ",k,")"); }

	// default parameters
	double nSignalStart = 200., nBackgroundStart = 1.;
	//  exceptions from these (please add more here if needed)
	// if (signalUnfolding!= 1 && TString(comp) == "vcb") { nSignalStart = 200; nBackgroundStart = 1.; }
	
	std::vector<double> dummyVector;
	TVector2 signalsig = sighistounb(dataSets[comp], Vmes, dummyVector, fitResults, nSignalStart, nBackgroundStart, simply, 1, 0, jMtch);

	//get here the number of signal and peaking background events

	// getting fit result: number of events and error 
        sigs[iBin-1][jMtch-1] = errsigs[iBin-1][jMtch-1] =  0.;
        if(signalsig.X()>0.00001) {
          sigs[iBin-1][jMtch-1] = signalsig.X();
          errsigs[iBin-1][jMtch-1] =  signalsig.Y();
        }
      } // for (int iBin=1; iBin<nB; iBin++)
      

      // generate plots
      char line[200];
      sprintf(line,"%s%s%s%s%d%s",DIRNAME.Data(),PREFIXOUT.Data(),"mES_mctruth",comp,jMtch,".eps");
      gStyle->SetPaperSize(4.*20., 4.*26.);
      c2->Print(line);
      gStyle->SetPaperSize(20., 26.);

      delete c2;

    } // for (int jMtch=1; jMtch<3; jMtch++)
    
    if(all[0] != 0 && all[1] !=0) {
    allrat = all[1]/all[0];
    allraterr = allrat*sqrt((allerr[1]*allerr[1]/all[1]/all[1])+
			    (allerr[0]*allerr[0]/all[0]/all[0]));
    }

    if (_debug>2){
      std::cout << "getSOverP: The overall S/P ratio for the " << comp << " sample is " << allrat << " +/- " << allraterr << std::endl;
    }

    for (int iBin=1; iBin< nB; iBin++) {  
      //compute the signal/peaking background here

      if (sigs[iBin-1][0] !=0 && sigs[iBin-1][1] !=0) {
	rat = sigs[iBin-1][1]/sigs[iBin-1][0];
	errrat = rat*sqrt((errsigs[iBin-1][1]*errsigs[iBin-1][1]/sigs[iBin-1][1]/sigs[iBin-1][1])+
			  (errsigs[iBin-1][0]*errsigs[iBin-1][0]/sigs[iBin-1][0]/sigs[iBin-1][0]));
      } else if (allrat != 0){
	rat = allrat;
	errrat = allraterr;
	std::cout << "getSOverP: WARNING: taking S/P ratio of bin " << iBin << " from the overall sample: " << rat << " +/- " << errrat << std::endl;
      } else {
	//CB
	std::cout << "getSOverP: WARNING: taking S/P ratio of bin " << iBin << " from the previous one: " << rat << " +/- " << errrat << std::endl;
      }

      if(_debug>2){
	std::cout <<"-----> getSOverP: Fitted " << comp << " sample in bin " << iBin << std::endl;
	std::cout <<"-----> getSOverP: Matched MC truth:   " << sigs[iBin-1][1] << " +/- " << errsigs[iBin-1][1] << std::endl;
	std::cout <<"-----> getSOverP: Unmatched MC truth: " << sigs[iBin-1][0] << " +/- " << errsigs[iBin-1][0] << std::endl;
	std::cout <<"-----> getSOverP: S/peakingBG ratio:  " << rat <<" +/- "<< errrat << std::endl;
      }

      //store this information into the vectors
      if(signalUnfolding == 1){
	if (std::string(comp) == "vubin") {
	  sigtopeakratiovubin.push_back(rat);
	  sigtopeakratioerrvubin.push_back(errrat);
	} else if (std::string(comp) == "vubout") {
	  sigtopeakratiovubout.push_back(rat);
	  sigtopeakratioerrvubout.push_back(errrat);
	} else if (std::string(comp) == "vcboth") {
	  sigtopeakratiovcboth.push_back(rat);
	  sigtopeakratioerrvcboth.push_back(errrat);
	}
      } else {
	if (std::string(comp) == "vub") {
	  sigtopeakratiovub.push_back(rat);
	  sigtopeakratioerrvub.push_back(errrat);
	} else if (std::string(comp) == "vcb") {
	  sigtopeakratiovcb.push_back(rat);
	  sigtopeakratioerrvcb.push_back(errrat);
	} else if (std::string(comp) == "other") {
	  sigtopeakratiooth.push_back(rat);
	  sigtopeakratioerroth.push_back(errrat);
	}
      }
    }
  } // for (int k=1; k<catnum+1; k++)
  
  
  return;
}

void VirClass::setActiveCorrection(const char* comp, int signalUnfolding, int iBin){


  if(signalUnfolding == 1){
    if (std::string(comp) == "vubin") {
      activecorrection=&sigtopeakratiovubin[iBin-1];
      activecorrectionerror=&sigtopeakratioerrvubin[iBin-1];
    } else if (std::string(comp) == "vubout") {
      activecorrection=&sigtopeakratiovubout[iBin-1];
      activecorrectionerror=&sigtopeakratioerrvubout[iBin-1];
    } else if (std::string(comp) == "vcboth") {
      activecorrection=&sigtopeakratiovcboth[iBin-1];
      activecorrectionerror=&sigtopeakratioerrvcboth[iBin-1];
    }
  } else {
    if (std::string(comp) == "vub") {
      activecorrection=&sigtopeakratiovub[iBin-1];
      activecorrectionerror=&sigtopeakratioerrvub[iBin-1];
    } else if (std::string(comp) == "vcb") {
      activecorrection=&sigtopeakratiovcb[iBin-1];
      activecorrectionerror=&sigtopeakratioerrvcb[iBin-1];
    } else if (std::string(comp) == "other") {
      activecorrection=&sigtopeakratiooth[iBin-1];
      activecorrectionerror=&sigtopeakratioerroth[iBin-1];
    }
  }
  if(std::string(comp) == "data") {
    std::cout << "active correction for data " << std::endl;
    activecorrection=&sigtopeakratiocorrmx[iBin-1];
    activecorrectionerror=&sigtopeakratioerrcorrmx[iBin-1];
    std::cout << "-------------------------- " << std::endl;
  }

  if(_debug > 2) {
    std::cout << "signal/peaking background correction for dataset " << comp << " and bin " << iBin << ": " << 
      *activecorrection << " +/- " << *activecorrectionerror << std::endl; 
  }
}

// =========================================

float VirClass::SPrandomized(float mean,float lsig, float hsig, TRandom& rndm, int seed){
  if(seed == 0 ) return mean;// no smearing required
  if(lsig==0. && hsig==0.) return mean; // no smearing possible

  // Version with normal distribution first
   float result;
   float dev=rndm.Gaus(0.,1.);
   if(dev<0)
     result = mean + dev*lsig;
   else
     result = mean + dev*hsig;
   if(result < 0) result = SPrandomized(mean,lsig,hsig,rndm,seed); // if negative weight throw the dice again
   return result;
}
// ===========================================

void VirClass::SetMesFitModel(Int_t fitmodel){
  MESFITMODEL = fitmodel;
}

// ===========================================

int VirClass::Bmode(int theid){

  int hasPi0(0);	
  int bmode = theid%100;  
  
  if(bmode == 3)  hasPi0 = 1;
  if(bmode == 4)  hasPi0 = 1; 
  if(bmode == 7)  hasPi0 = 1; 
  if(bmode == 8)  hasPi0 = 1; 
  if(bmode == 12) hasPi0 = 1; 
  if(bmode == 13) hasPi0 = 1; 
  if(bmode == 14) hasPi0 = 1; 
  if(bmode == 15) hasPi0 = 1; 
  if(bmode == 16) hasPi0 = 1; 
  if(bmode == 17) hasPi0 = 1; 
  if(bmode == 19) hasPi0 = 1; 
  if(bmode == 20) hasPi0 = 1; 
  if(bmode == 21) hasPi0 = 1; 
  if(bmode == 25) hasPi0 = 1; 
  if(bmode == 26) hasPi0 = 1; 
  if(bmode == 27) hasPi0 = 1; 
  if(bmode == 29) hasPi0 = 1; 
  if(bmode == 31) hasPi0 = 1; 
  if(bmode == 32) hasPi0 = 1; 
  if(bmode == 33) hasPi0 = 1; 
  if(bmode == 34) hasPi0 = 1; 
  if(bmode == 35) hasPi0 = 1; 
  if(bmode == 40) hasPi0 = 1; 
  if(bmode == 41) hasPi0 = 1; 
  if(bmode == 42) hasPi0 = 1; 
  if(bmode == 43) hasPi0 = 1; 
  if(bmode == 44) hasPi0 = 1; 
  if(bmode == 45) hasPi0 = 1; 
  if(bmode == 46) hasPi0 = 1; 
  if(bmode == 47) hasPi0 = 1; 
  if(bmode == 51) hasPi0 = 1; 
  if(bmode == 52) hasPi0 = 1; 
  if(bmode == 53) hasPi0 = 1; 

  return hasPi0;

}

//=======================================================================

// FUNCTION TO RETRIEVE number of tracks for truth-matching algorithm 
void GetMultiplicity(int mode, int &ncha, int &ngamma, int &nk0, int &npi0){

  int dmode, bmode;

  // mode = dmode*100+bmode;

  ncha =0;
  ngamma=0;
  npi0=0;
  nk0=0;

  dmode = (int)mode/100;
  bmode = mode - dmode*100;

  //  cout << "Mode " << mode << " " << bmode << " " << dmode << endl;

  if(dmode == 110){
    //  "D0->kpi"
    ncha=2;
  }else if(dmode == 111){
    //"D0->kpipi0"
    ncha=2;
    npi0=1;
  }else if(dmode == 112){
    //"D0->k3pi"
    ncha=4;
  }else if(dmode == 113){
    //"D0->kspipi"
    ncha=2;
    nk0=1;
  }else if(dmode == 130){
    //"D*,D0->kpi"
    ncha=3;
  }else if(dmode == 131){
    //"D*,D0->kpipi0"
    ncha=3;
    npi0=1;
  }else if(dmode == 132){
    //"D*,D0->k3pi"
    ncha=5;
  }else if(dmode == 133){
    //"D*,D0->kspipi"
    ncha=3;
    nk0=1;
  }else if(dmode == 120){
    //"Dc->kspi"
    ncha=1;
    nk0=1;
  }else if(dmode == 121){
    //"Dc->kpipi"
    ncha=3;
  }else if(dmode == 122){
    //"Dc->kspipi0"
    ncha=1;
    nk0=1;
    npi0=1;
  }else if(dmode == 123){
    //"Dc->kpipipi0"
    ncha=3;
    npi0=1;
  }else if(dmode == 124){
    //"Dc->kspipipi"
    ncha=3;
    nk0=1;
  }else if(dmode == 140){
    //"D*0->D0pi0,D0->kpi"
    ncha=2;
    npi0=1;
  }else if(dmode == 141){
    //"D*0->D0pi0,D0->kpipi0"
    ncha=2;
    npi0=2;
  }else if(dmode == 142){
    //"D*0->D0pi0,D0->k3pi"
    ncha=4;
    npi0=1;
  }else if(dmode == 143){
    //"D*0->D0pi0,D0->kspipi"
    ncha=2;
    nk0=1;
    npi0=1;
  }else if(dmode == 150){
    //"D*0->D0gamma,D0->kpi"
    ncha=2;
    ngamma=1;
  }else if(dmode == 151){
    //"D*0->D0gamma,D0->kpipi0"
    ncha=2;
    npi0=1;
    ngamma=1;
  }else if(dmode == 152){
    //"D*0->D0gamma,D0->k3pi"
    ncha=4;
    ngamma=1;
  }else if(dmode == 153){
    //"D*0->D0gamma,D0->kspipi"
    ncha=2;
    nk0=1;
    ngamma=1;
  }else{
    //    cout << "Unrecognised D Mode " << dmode << endl;
  }

  if(bmode == 1){
    //"B->Dpi"
    ncha+=1;
  }else if(bmode == 2){
    //"B->Dk"
    ncha+=1;
  }else if(bmode == 3 || bmode == 4){
    //"B->Dpipi0 or DKpi0"
    ncha+=1;
    npi0+=1;
  }else if(bmode == 5 || bmode == 6){
    //"B->DpiKs or DKKs"
    ncha+=1;
    nk0+=1;
  }else if(bmode == 7 || bmode == 8){
    //"B->Dpi2pi0 or DK2pi0"
    ncha+=1;
    npi0+=2;
  }else if(bmode == 9){
    //"B->D3pi"
    ncha+=3;
  }else if(bmode == 10){
    //"B->DK2pi"
    ncha+=3;
  }else if(bmode == 11){
    //"B->D2kpi_Ds"
    ncha+=3;
  }else if(bmode == 12){
    //"B->Domegah  ????" h probably one h+, see BAD 271
    ncha+=3;
    npi0+=1;
  }else if(bmode == 13){
    //"B->DK2pipi0"
    ncha+=3;  
    npi0+=1;
  }else if(bmode == 14){
    //"B->D2kpipi0_Ds*"
    ncha+=3;  
    npi0+=1;
  }else if(bmode == 15){
    //"B->Dpipi0ks"
    ncha+=1;   
    npi0+=1;
    nk0+=1;
  }else if(bmode == 16){
    //"B->Dkpi0ks_<1.8GeV"
    ncha+=1;   
    npi0+=1;
    nk0+=1;
  }else if(bmode == 17){
    //"B->Dk2pi0ks_1.8-2.2GeV"
    ncha+=1;   
    npi0+=2;
    nk0+=1;
  }else if(bmode == 18){
    //"B->D2ksX ????"
    nk0+=2;
    ncha+=1;//maybe another pi0, maybe not
  }else if(bmode == 19){
    //"B->D3pi2pi0_<2.2GeV"
    ncha+=3;   
    npi0+=2;
  }else if(bmode == 20){
    //"B->Dk2pi2pi0_<2.2GeV"
    ncha+=3;   
    npi0+=2;
  }else if(bmode == 21){
    //"B->D2kpi2pi0_Ds*"
    ncha+=3;   
    npi0+=2;
  }else if(bmode == 22){
    //"B->D5pi_<2.3GeV"
    ncha+=5;   
  }else if(bmode == 23){
    //"B->Dk4pi_<2.3GeV"
    ncha+=5;   
  }else if(bmode == 24){
    //"B->D2K3pi_<2.7GeV"
    ncha+=5;   
  }else if(bmode == 25){
    //"B->D5pipi0_<2.2GeV"
    ncha+=5;   
    npi0+=1;
  }else if(bmode == 26){
    //"B->Dk4pipi0_<2.2GeV"
    ncha+=5;   
    npi0+=1;
  }else if(bmode == 27){
    //"B->D2k3pipi0_<2.5GeV"
    ncha+=5;   
    npi0+=1;
  }else if(bmode == 28){
    //"B->D3piks_D*"
    ncha+=3;   
    nk0+=1;
  }else if(bmode == 29){
    //"B->D3pikspi0_D*"
    ncha+=3;   
    nk0+=1;
    npi0+=1;
  }else if(bmode == 30){
    //"B->Dk2piks_D*"
    ncha+=3;   
    nk0+=1;
  }else if(bmode == 31){
    //"B->DD*_Dpi0 ???"
    npi0+=2;
    ncha+=5;
  }else if(bmode == 32){
    //"B->Dpipi0_>1.5GeV"
    ncha+=1;
    npi0+=1;
  }else if(bmode == 33){
    //"B->Dkpi0_>1.5GeV"
    ncha+=1;
    npi0+=1;
  }else if(bmode == 34){
    //"B->Dpi2pi0_1.5-2GeV"
    ncha+=1;
    npi0+=2;
  }else if(bmode == 35){
    //"B->Dk2pi0_>1.5GeV"
    ncha+=1;
    npi0+=2;
  }else if(bmode == 36){
    //"B->D3pi_1.5-2GeV"
    ncha+=3;
  }else if(bmode == 37){
    //"B->Dk2pi_>1.5GeV"
    ncha+=3;
  }else if(bmode == 38){
    //"B->D2kpi_K*"
    ncha+=3;
  }else if(bmode == 39){
    //"B->D2kpi_other"
    ncha+=3;
  }else if(bmode ==40){
    //"B->D3pipi0_<1.6GeV"
    ncha+=3;
    npi0+=1;
  }else if(bmode ==41){
    //"B->D3pipi0_1.6-2.2GeV"
    ncha+=3;
    npi0+=1;
  }else if(bmode ==42){
    //"B->Dk2pipi0_>2.2GeV"
    ncha+=3;
    npi0+=1;
  }else if(bmode ==43){
    //"B->D2kpipi0_other"
    ncha+=3;
    npi0+=1;
  }else if(bmode ==44){
    //"B->Dkpi0ks_>1.8GeV"
    ncha+=1;
    npi0+=1;
    nk0+=1;
  }else if(bmode ==45){
    //"B->D3pi2pi0_>2.2GeV"
    ncha+=3;
    npi0+=2;
  }else if(bmode ==46){
    //"B->Dk2pi2pi0_>2.2GeV"
    ncha+=3;
    npi0+=2;
  }else if(bmode ==47){
    //"B->D2kpi2pi0_other"
    ncha+=3;
    npi0+=2;
  }else if(bmode ==48){
    //"B->D5pi_>2.3GeV"
    ncha+=5;
  }else if(bmode ==49){
    //"B->Dk4p_>2.7GeV"
    ncha+=5;
  }else if(bmode ==50){
    //"B->D2K3pi_>2.7GeV"
    ncha+=5;
  }else if(bmode ==51){
    //"B->D5pipi0_>2.2GeV"
    ncha+=5;
    npi0+=1;
  }else if(bmode ==52){
    //"B->D3piks_noD*"
    ncha+=3;
    nk0+=1;
  }else if(bmode ==53){
    //"B->D3pikspi0_noD*"
    ncha+=3;
    nk0+=1;
    npi0+=1;
  }else{
    //    cout << "Unrecognised B Mode " << bmode << endl;
  }
  
  //  cout << "Mult. " << ncha << " " << nk0 << " " << npi0 << " " << ngamma << endl;
}

void VirClass::GetMCTrueNumbers(int comb){

  ofstream outfile;
  char name[200];
  sprintf(name,"%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),"truthnumbers.txt");  
  outfile.open(name); 
  outfile  << "NOTICE: these numbers are valid for -Sun analysis for now. Check VirClass::GetMCTRueNumbers in VirUtil.icc " <<endl;
  outfile  << "===========================================================================================================" <<endl;

  TVector2 data3,data4,data5,sumVubIN,sumVubOUT,sumVcb,sumVubINmixcorr,sumVubOUTmixcorr,sumVcbmixcorr,total,sumvcboth,sumvcbothmixcorr;
  TVector2 Nu,Numixc, NSL, NSLmixc, epsuchop, epsuchopmixc, pstar, pstarmixc, effdfn;
  // Holder for fast loop
  TObjArray dsets,res,sums,sumsmixcorr;
  RooDataSet *rds;


  //=========================== N_u first =====================

  res.Add(&data3); res.Add(&data4); res.Add(&data5);

  outfile << "=============== N_u ============="<<endl;
  
  TString cut;
  TString mesRangeCut = (FITALLMESRANGE ? "":" && mes > 5.27");

  if(comb) {
    cut="lepYaSe == 1 && mx < "; cut+=MXBIN; cut+=" && q2 > "; cut+=Q2BIN; }
  else {
    cut = "lepYaSe == 1 && chop < "; cut+=CHOPBIN; }
  
  cut += mesRangeCut;

  for(Int_t mloop=0; mloop<2; mloop++){
    if(mloop==1){ cut+= " && trumtch==2"; 

    outfile <<"========= N_u Truth-matched ==========="<<endl;}
    
    for(Int_t jflav=3; jflav<6; jflav++) {
      cut += " && flavB == "; cut += jflav;
	
      rds = (RooDataSet*)datavubin->reduce(cut);
      cout<<rds->GetName()<<" "<<cut<<" "<<rds->numEntries(1)<<endl;
	
      ((TVector2*)res[jflav-3])->Set(rds->numEntries(1),sqrt((Float_t)rds->numEntries(1))); 
      delete rds; rds=NULL;
      cut.Resize(cut.Length()-14);
    } //end of flav loop

    sumVubIN.Set( data3.X() + data4.X() + data5.X(), sqrt( data3.Y()*data3.Y() + data4.Y()*data4.Y() + data5.Y()*data5.Y()));
    //if MIXCORR==0 it DOES NOT APPLY Mixingcorrection: see ApplyCorrFactor()..
    sumVubINmixcorr = ApplyCorrFactors(data3,data4,data5,true);
    
    sumVubIN *= LUMI_GENERIC/LUMI_SIGNAL;
    sumVubINmixcorr *= LUMI_GENERIC/LUMI_SIGNAL;


    outfile << "N_u without mixing corr " << sumVubIN.X()<< " +- " << sumVubIN.Y() << endl; 
    if(mloop==0)
      Nu.Set(sumVubIN.X(), sumVubIN.Y());

    outfile << "N_u with mixing corr "<< sumVubINmixcorr.X() << " +- " << sumVubINmixcorr.Y()<<endl; 
    if(mloop==0)
      Numixc.Set(sumVubINmixcorr.X(),sumVubINmixcorr.Y());
    outfile << endl;
  } // END OF MASTER LOOP
  
  //===================================================================================================
  
  // Sweep
  res.Clear();  cut.Resize(0);

  //=================================================================
  //                             NSL 
  //=================================================================


  outfile << "===================== NSL =============="<<endl;
  
  dsets.Add(datamcvcb); dsets.Add(datavubin); dsets.Add(datavubout); dsets.Add(datavcboth);
  sums.Add(&sumVcb); sums.Add(&sumVubIN); sums.Add(&sumVubOUT); sums.Add(&sumvcboth);
  sumsmixcorr.Add(&sumVcbmixcorr); sumsmixcorr.Add(&sumVubINmixcorr); sumsmixcorr.Add(&sumVubOUTmixcorr); sumsmixcorr.Add(&sumvcbothmixcorr);
  res.Add(&data3); res.Add(&data4); res.Add(&data5);

  cut = "lepYes==1"; cut+=mesRangeCut;
  
  for(Int_t mloop=0;mloop<2;mloop++){
    if(mloop==1)
      {cut+= " && trumtch==2"; outfile <<"=========NSL Truth-matched ==========="<<endl;}
    
    for(Int_t jarr=0; jarr<dsets.GetLast()+1; jarr++){
      for(Int_t jflav=3; jflav<6; jflav++) {
	
	cut += " && flavB == "; cut += jflav;
	
	rds = (RooDataSet*)( (RooDataSet*)dsets[jarr])->reduce(cut);
	cout<<rds->GetName()<<" "<<cut<<" "<<rds->numEntries(1)<<endl;
	
	((TVector2*)res[jflav-3])->Set(rds->numEntries(1),sqrt((Float_t)rds->numEntries(1)));
	delete rds; rds=NULL;
	cut.Resize(cut.Length()-14);
      } //end of flav loop

      ( (TVector2*)sums[jarr])->Set( data3.X() + data4.X() + data5.X(), sqrt( data3.Y()*data3.Y()+data4.Y()*data4.Y()+data5.Y()*data5.Y()));
      //if MIXCORR==0 it DOES NOT APPLY Mixingcorrection: see ApplyCorrFactors()..
      *( (TVector2*)sumsmixcorr[jarr])= ApplyCorrFactors(data3,data4,data5,true);

    } // end of dataset component loop

    total.Set( sumVcb.X()+LUMI_GENERIC/LUMI_SIGNAL*(sumVubIN.X()+sumVubOUT.X()),sqrt(sumVcb.Y()*sumVcb.Y()+
										     LUMI_GENERIC/LUMI_SIGNAL*LUMI_GENERIC/LUMI_SIGNAL*
										     (sumVubIN.Y()*sumVubIN.Y()+sumVubOUT.Y()*sumVubOUT.Y()))); //without mixing correction
    outfile << "N_SL without mixing corr " << total.X() << " +- " << total.Y() <<endl; 
    if(mloop==0)
      NSL.Set(total.X(),total.Y());
    total.Set( (sumVcb.X()+LUMI_GENERIC/LUMI_SIGNAL*(sumVubIN.X()+sumVubOUT.X()))/(sumvcboth.X()+LUMI_GENERIC/LUMI_SIGNAL*(sumVubIN.X()+sumVubOUT.X())),
	       1.);
    outfile << "fact without mixing corr "<<total.X()<<endl;

    total.Set(sumVcbmixcorr.X()+LUMI_GENERIC/LUMI_SIGNAL*(sumVubINmixcorr.X()+sumVubOUTmixcorr.X()),sqrt(sumVcbmixcorr.Y()*sumVcbmixcorr.Y()+
													 LUMI_GENERIC/LUMI_SIGNAL*LUMI_GENERIC/LUMI_SIGNAL*
													 (sumVubINmixcorr.Y()*sumVubINmixcorr.Y()+sumVubOUTmixcorr.Y()*sumVubOUTmixcorr.Y())));
    if(mloop==0)
      NSLmixc.Set(total.X(),total.Y());
    outfile << "N_SL with mixing corr "<< total.X() << " +- " << total.Y()<<endl;
    total.Set((sumVcbmixcorr.X()+LUMI_GENERIC/LUMI_SIGNAL*(sumVubINmixcorr.X()+sumVubOUTmixcorr.X()))/
	      (sumvcbothmixcorr.X()+LUMI_GENERIC/LUMI_SIGNAL*(sumVubINmixcorr.X()+sumVubOUTmixcorr.X())),1.);
  } // end of master loop

  //============================== fact calculation  fact = ( vcbmc + LUMI_GENERIC/LUMI_SIGNAL*(vubmc + vuboutmc) )/ (totmc + LUMI_GENERIC/LUMI_SIGNAL * (vubmc + vuboutmc)) =
  
  //sweep
  dsets.Clear(); res.Clear(); sums.Clear(); sumsmixcorr.Clear(); cut.Resize(0);
  
  //=================================================================
  //                             Eps_u && Eps_mx
  //=================================================================

  outfile <<endl;
  outfile <<"=============== EFFICIENCIES ============="<<endl;

  res.Add(&data3); res.Add(&data4); res.Add(&data5);
  sums.Add(&sumVubIN); sums.Add(&sumVubOUT); sums.Add(&sumVcb); //use just names: sumVubIN=vubIN All Cut, sumVubOut= vubIN SL, SumVcb= vubINSB all cut
  sumsmixcorr.Add(&sumVubINmixcorr); sumsmixcorr.Add(&sumVubOUTmixcorr);
  sumsmixcorr.Add(&sumVcbmixcorr);

  for(Int_t mloop=0; mloop<2; mloop++){
    if(mloop==1) outfile <<"========= epsu Truth-matched ==========="<<endl;
 
    for(Int_t jarr=0; jarr<3; jarr++){
      if(jarr==0) cut="lepYaSe==1";
      if(jarr==1) cut="lepYes==1";
      if(jarr==2) {
	if(comb){ 
	  cut="lepYaSe == 1 && mx < "; cut+=MXBIN; cut+=" && q2 > "; cut+=Q2BIN; 
	} else {
 	  cut="lepYaSe==1 && chop< ";cut+=CHOPBIN; }
      }

      cut += mesRangeCut;
      if(mloop==1) cut+= " && trumtch==2"; 
      for(Int_t jflav=3; jflav<6; jflav++){
	cut += " && flavB == "; cut += jflav;
	
	rds = (RooDataSet*)datavubin->reduce(cut);
	cout<<rds->GetName()<<" "<<cut<<" "<<rds->numEntries(1)<<endl;
	
	((TVector2*)res[jflav-3])->Set(rds->numEntries(1),sqrt((Float_t)rds->numEntries(1))); //See if we need to set errors.
	delete rds; rds=NULL;
	cut.Resize(cut.Length()-14);
      } // end of jflav Loop
      
      ( (TVector2*)sums[jarr])->Set( data3.X()+data4.X()+data5.X(),sqrt(data3.Y()*data3.Y()+data4.Y()*data4.Y()+data5.Y()*data5.Y()));
    //if MIXCORR==0 it DOES NOT APPLY Mixingcorrection: see ApplyCorrFactors()..
      *( (TVector2*)sumsmixcorr[jarr])= ApplyCorrFactors(data3,data4,data5,true);
    } //end of dataset component Loop

    total.Set( sumVubIN.X()/sumVubOUT.X(),sumVubIN.X()/sumVubOUT.X()*sqrt(sumVubIN.Y()/sumVubIN.X()*sumVubIN.Y()/sumVubIN.X()
									 +sumVubOUT.Y()/sumVubOUT.X()*sumVubOUT.Y()/sumVubOUT.X())); //without mixing correction
    outfile << "Eps_u without mixing corr " << sumVubIN.X() <<"/"<<sumVubOUT.X()<<" = "<<total.X() << " +- " << total.Y() <<endl;

    total.Set(sumVubINmixcorr.X()/sumVubOUTmixcorr.X(),sqrt(sumVubINmixcorr.X()/sumVubOUTmixcorr.X()*
							    sqrt(sumVubINmixcorr.Y()/sumVubINmixcorr.X()*sumVubINmixcorr.Y()/sumVubINmixcorr.X()+
								 sumVubOUTmixcorr.Y()/sumVubOUTmixcorr.X()*sumVubOUTmixcorr.Y()/sumVubOUTmixcorr.X())));
    outfile << "Eps_u with mixing corr "<< sumVubINmixcorr.X()<<"/"<<sumVubOUTmixcorr.X()<<" = "<<total.X() << " +- " << total.Y()<<endl;

    total.Set(sumVcb.X()/sumVubIN.X(),sumVcb.X()/sumVubIN.X()*sqrt(sumVcb.Y()/sumVcb.X()*sumVcb.Y()/sumVcb.X()
									 +sumVubIN.Y()/sumVubIN.X()*sumVubIN.Y()/sumVubIN.X())); //without mixing correction
    outfile << "Eps_mx without mixing corr " << sumVcb.X() <<"/"<<sumVubIN.X()<<" = "<<total.X() << " +- " << total.Y() <<endl;

    total.Set(sumVcbmixcorr.X()/sumVubINmixcorr.X(),sqrt(sumVcbmixcorr.X()/sumVubIN.X()*
							    sqrt(sumVcbmixcorr.Y()/sumVcbmixcorr.X()*sumVcbmixcorr.Y()/sumVcbmixcorr.X()+
								 sumVubINmixcorr.Y()/sumVubINmixcorr.X()*sumVubINmixcorr.Y()/sumVubINmixcorr.X())));
    outfile << "Eps_mx with mixing corr "<< sumVcbmixcorr.X()<<"/"<<sumVubINmixcorr.X()<<" = "<<total.X() << " +- " << total.Y()<<endl;

    ///EPSU*EPSCHOP
    total.Set(sumVcb.X()/sumVubOUT.X(),sumVcb.X()/sumVubOUT.X()*
	      sqrt(sumVcb.Y()*sumVcb.Y()/(sumVcb.X()*sumVcb.X())+ sumVubOUT.Y()*sumVubOUT.Y()/(sumVubOUT.X()*sumVubOUT.X())));
    outfile << "Eps_mx*Eps_u without mixing corr "<< total.X() <<" +- "<<total.Y()<<endl;
    if(mloop==0)
      epsuchop.Set(total.X(),total.Y());
    
    total.Set(sumVcbmixcorr.X()/sumVubOUTmixcorr.X(),sumVcbmixcorr.X()/sumVubOUTmixcorr.X()*sqrt(sumVcbmixcorr.Y()*sumVcbmixcorr.Y()/(sumVcbmixcorr.X()*sumVcbmixcorr.X())+sumVubOUTmixcorr.Y()*sumVubOUTmixcorr.Y()/(sumVubOUTmixcorr.X()*sumVubOUTmixcorr.X())));
    outfile << "Eps_mx*Eps_u with mixing corr "<<total.X() <<" +- "<<total.Y()<<endl;
    if(mloop==0)
      epsuchopmixc.Set(total.X(),total.Y());
  }
  
  //sweep
  dsets.Clear(); res.Clear(); sums.Clear(); sumsmixcorr.Clear(); cut.Resize(0);
  
  //===========================================
  //              PSTAR
  //===========================================

  outfile <<endl;
  outfile <<"=============== PSTAR ========"<<endl;

  sums.Add(&sumVcb); sums.Add(&sumVubIN); //Again these are only names... sumVcb=pstarsample|_lepVcb,  sumVubIN=pstarsample|_lepVubSB
  sumsmixcorr.Add(&sumVcbmixcorr); sumsmixcorr.Add(&sumVubINmixcorr);

  if(comb) 
    effdfn = getEffFromDFN2D(MXBIN,Q2BIN);
  else {
    if (FITQ2 == 0) 
      effdfn = getEffFromDFN(MXBIN, VirClass::iVarMx);
    else if (FITQ2 == 1) 
      effdfn = getEffFromDFN(Q2BIN, VirClass::iVarQ2);
    else if (FITQ2 == 2) 
      effdfn = getEffFromDFN(PPLUSBIN, VirClass::iVarPplus);
  }
  res.Add(&data3); res.Add(&data4); res.Add(&data5);

  for(Int_t mloop=0; mloop<2; mloop++){
    if(mloop==1) outfile <<"========= PSTARSAMPLE Truth-matched ==========="<<endl;
      for(Int_t jarr=0; jarr<2; jarr++){
	if(jarr==0) cut="(lepVcb==1 || lepVub==1)";
	if(jarr==1) cut="lepVubSB==1";
	if(mloop==1) cut+=" && trumtch==2";
	
	cut += mesRangeCut;
	for(Int_t jflav=3; jflav<6; jflav++){
	  cut+=" && flavB== "; cut+=jflav;
	  rds=(RooDataSet*)pstarsample->reduce(cut);
	  cout<<rds->GetName()<<" "<<cut<<" "<<rds->numEntries(1)<<endl;
	  
	  ((TVector2*)res[jflav-3])->Set(rds->numEntries(1),sqrt((Float_t)rds->numEntries(1)));
	  delete rds; rds=NULL;
	  cut.Resize(cut.Length()-13);
	} //end of flav Loop
	  
	( (TVector2*)sums[jarr])->Set(data3.X() + data4.X() + data5.X(), sqrt( data3.Y()*data3.Y()+data4.Y()*data4.Y()+data5.Y()*data5.Y()));
	//if MIXCORR==0 it DOES NOT APPLY Mixingcorrection: see ApplyCorrFactors()..
	*( (TVector2*)sumsmixcorr[jarr])=ApplyCorrFactors(data3,data4,data5,true);

	cut.Resize(0);
	
      } // end of dataset component loop
      
      total.Set(sumVubIN.X()/sumVcb.X()*(BRRATIOVALUETAIL_C+BRRATIOVALUETAIL_U)/BRRATIOVALUETAIL_U*1./effdfn.X(),
		sumVubIN.X()/sumVcb.X()*(BRRATIOVALUETAIL_C+BRRATIOVALUETAIL_U)/BRRATIOVALUETAIL_U*1./effdfn.X()*
		sqrt(sumVubIN.Y()*sumVubIN.Y()/(sumVubIN.X()*sumVubIN.X()) + sumVcb.Y()*sumVcb.Y()/(sumVcb.X()*sumVcb.X()) +
		     effdfn.Y()*effdfn.Y()/(effdfn.X()*effdfn.X())));
      outfile << "PStar without mixing corr: lepvubSB/lepVCB * BR(Xlnu)/BR(Xulnu) * 1/effdfn = " << sumVubIN.X()<<"/"<<sumVcb.X()<<
	"*"<<(BRRATIOVALUETAIL_C+BRRATIOVALUETAIL_U)<<"/"<<BRRATIOVALUETAIL_U<<" * 1/"<<effdfn.X()<<" = "<<
	total.X()<<" +- "<<total.Y()<<endl;

      if(mloop==0)
	pstar.Set(total.X(),total.Y());
      
      total.Set(sumVubINmixcorr.X()/sumVcbmixcorr.X()*(BRRATIOVALUETAIL_C+BRRATIOVALUETAIL_U)/BRRATIOVALUETAIL_U*1./effdfn.X(),
		sumVubINmixcorr.X()/sumVcbmixcorr.X()*(BRRATIOVALUETAIL_C+BRRATIOVALUETAIL_U)/BRRATIOVALUETAIL_U*1./effdfn.X()*
		sqrt(sumVubINmixcorr.Y()*sumVubINmixcorr.Y()/(sumVubINmixcorr.X()*sumVubINmixcorr.X()) + sumVcbmixcorr.Y()*sumVcbmixcorr.Y()/
		     (sumVcbmixcorr.X()*sumVcbmixcorr.X()) + effdfn.Y()*effdfn.Y()/(effdfn.X()*effdfn.X())));
      outfile << "PStar with mixing corr: lepvubSB/lepVCB * BR(Xlnu)/BR(Xulnu) * 1/effdfn = " << sumVubINmixcorr.X()<<"/"<<sumVcbmixcorr.X()<<
	"*"<<(BRRATIOVALUETAIL_C+BRRATIOVALUETAIL_U)<<"/"<<BRRATIOVALUETAIL_U<<" * 1/"<<effdfn.X()<<" = "<<
	total.X()<<" +- "<<total.Y()<<endl;

      if(mloop==0)
	pstarmixc.Set(total.X(),total.Y());

  }
  sums.Clear(); res.Clear(); sumsmixcorr.Clear();
  
  outfile <<" CHECL Nu= "<<Nu.X()<<" NSL "<<NSL.X()<<" epsuchop "<<epsuchop.X()<<" pstar "<<pstar.X()<<" EFFDFN "<<effdfn.X()<<endl;
  total.Set( Nu.X()/NSL.X() / epsuchop.X() / pstar.X() / effdfn.X() ,Nu.X()/NSL.X()/epsuchop.X()/pstar.X()/effdfn.X()*
	    sqrt(Nu.Y()*Nu.Y()/(Nu.X()*Nu.X())+NSL.Y()*NSL.Y()/(NSL.X()*NSL.X())+epsuchop.Y()*epsuchop.Y()/(epsuchop.X()*epsuchop.X())+
		 pstar.Y()*pstar.Y()/(pstar.X()*pstar.X())+effdfn.Y()*effdfn.Y()/(effdfn.X()*effdfn.X())));
  outfile << "========================"<<endl;
  outfile << " results: BRBR calculated no mix corr= "<<total.X()
	  <<" +- "<<total.Y() <<" BRBR generated= "<<BRRATIOGENVALUE<<endl;
  
  outfile <<" CHECK Nu= "<<Numixc.X()<<" NSL "<<NSLmixc.X()<<" epsuchop "<<epsuchopmixc.X()<<" pstar "<<pstarmixc.X()<<" EFFDFN "<<effdfn.X()<<endl;
  total.Set( Numixc.X()/NSLmixc.X() / epsuchopmixc.X() / pstarmixc.X() / effdfn.X() ,Numixc.X()/NSLmixc.X()/epsuchopmixc.X()/pstarmixc.X()/effdfn.X()*
	     sqrt(Numixc.Y()*Numixc.Y()/(Numixc.X()*Numixc.X())+NSLmixc.Y()*NSLmixc.Y()/(NSLmixc.X()*NSLmixc.X())+epsuchopmixc.Y()*epsuchopmixc.Y()/
		  (epsuchopmixc.X()*epsuchopmixc.X())+
		  pstarmixc.Y()*pstarmixc.Y()/(pstarmixc.X()*pstarmixc.X())+effdfn.Y()*effdfn.Y()/(effdfn.X()*effdfn.X())));


  outfile <<" results: BRBR calculated with mix corr= "<<total.X() <<" +- "<<total.Y() <<" BRBR generated= "<<BRRATIOGENVALUE<<endl;

  //===================================================================================================
  
  outfile.close();
}
TVector2 VirClass::ApplyCorrFactors(const TVector2 & fl3,const TVector2 & fl4, const TVector2& fl5, bool hasMixingCorr, Float_t chargecorr){

  const Float_t chid = 0.188;
  Float_t totale, errortotale;

  if( MIXCORR == 0 || !hasMixingCorr ) {
      
    cout << " ApplyCorrFactors:: Not Applying Mixing Correction. Correctionratio is " << chargecorr << endl;
      totale = fl3.X()*chargecorr + fl4.X() + fl5.X();
      errortotale = sqrt(chargecorr*chargecorr*fl3.Y()*fl3.Y() + fl4.Y()*fl4.Y() + fl5.Y() * fl5.Y());
  } else {
    
      cout << " ApplyCorrFactors:: Applying Mixing Correction. Correctionratio is "<<chargecorr<<endl;
      totale = fl3.X()*chargecorr + ((1-chid)/(1-2*chid)) * fl4.X() - (chid/(1-2*chid)) * fl5.X();
      errortotale = sqrt(chargecorr*chargecorr*fl3.Y() * fl3.Y() +
			 ((1-chid)/(1-2*chid)) * ((1-chid)/(1-2*chid)) * fl4.Y() * fl4.Y() +
			 (chid/(1-2*chid)) * (chid/(1-2*chid)) * fl5.Y() * fl5.Y());
  }
  return TVector2(totale,errortotale); 
}


TVector2 VirClass::ApplyCorrFactors(const TVector2 & fl3,const TVector2 & fl4, const TVector2& fl5, bool hasMixingCorr, const TString& dset, const TString& cut, Float_t chargecorr){

  const Float_t chid = 0.188;
  Float_t totale, errortotale;


  if( BTYPE == 2 ) {
    if( MIXCORR == 0 || !hasMixingCorr ) {
      
      cout << " ApplyCorrFactors:: Not Applying Mixing Correction. Correctionratio is " << chargecorr << endl;
      totale = fl3.X()*chargecorr + fl4.X() + fl5.X();
      errortotale = sqrt(chargecorr*chargecorr*fl3.Y()*fl3.Y() + fl4.Y()*fl4.Y() + fl5.Y() * fl5.Y());
    } else {
      cout << " ApplyCorrFactors:: Applying Mixing Correction. Correctionratio is "<<chargecorr<<endl;
      totale = fl3.X()*chargecorr + ((1-chid)/(1-2*chid)) * fl4.X() - (chid/(1-2*chid)) * fl5.X();
      errortotale = sqrt(chargecorr*chargecorr*fl3.Y() * fl3.Y() +
			 ((1-chid)/(1-2*chid)) * ((1-chid)/(1-2*chid)) * fl4.Y() * fl4.Y() +
			 (chid/(1-2*chid)) * (chid/(1-2*chid)) * fl5.Y() * fl5.Y());
    }
    return TVector2(totale,errortotale);

  } else {  // CHARGE SEPARATION: WE NEED TO APPLY CROSSFEED HERE!
    TVector2 jojo(0,0);

    if( MIXCORR == 0 || !hasMixingCorr ) {
      cout << " ApplyCorrFactors for separated charge:: Not Applying Mixing Correction. Correctionratio is " << chargecorr << endl;
      ApplyCrossFeedCalculations(dset,cut,fl3,fl4,jojo);
    } else {
      cout << " ApplyCorrFactors for separated charge:: Applying Mixing Correction to the neutral component. Correctionratio is " << chargecorr << endl;
      TVector2 tmp(0,0);
      cout << " Before Mixing correction flavB 4= " << fl4.X() << " +- " << fl4.Y() << " and flavB 5= " << fl5.X()<< " +- " << fl5.Y() << endl;
      tmp.Set( (1-chid)/(1-2*chid)*fl4.X() - (chid/(1-2*chid))*fl5.X() , sqrt( ((1-chid)/(1-2*chid)) * ((1-chid)/(1-2*chid)) * fl4.Y() * fl4.Y() +
			 (chid/(1-2*chid)) * (chid/(1-2*chid)) * fl5.Y() * fl5.Y()) );
      cout << " After Mixing correction= " << tmp.X() << " +- " << tmp.Y() <<  endl;
      ApplyCrossFeedCalculations(dset,cut,fl3,tmp,jojo);
    }
    return jojo;
  }
}



void VirClass::computeChargeCorr(int su, int comb)
{
  
  cout << "---------------------------------------------------------------" << endl;
  cout << "      Compute correction ratios for DATA/MC B+ B0s differences " << endl;
  cout << endl;

  std::vector<double> fitResults;
  char simply[100];

  int matchMC = countMC ? 2: 0;
  
  //Computes statistical correction for B0/B+ events ratio
  TVector2 signalsig;
  c1  = new TCanvas("c2"," ",200,10,1200,800); 
  c1->Clear();
  c1->Divide(3, 4);

  //---------- DATA Semileptonic Cut Bch -----------
  c1->cd(1);    
  sprintf(simply,"(flavB == 3) && lepYes == 1");
  std::vector<double> mesNslTmp(mesNsl); mesNslTmp[3] = 5.;
  if(!SMALLSTATCORR)
    signalsig = sighistounb(datadata, Vmes, fitResults, mesNslTmp,  20000, 10000, simply, USECB);
  else{
    sprintf(simply,"(flavB == 3) && lepYaSe == 1");
    signalsig = sighistounb(datadata, Vmes, fitResults, mesdatacuts,  20000, 10000, simply, USECB);
  }
  double nbchdata = signalsig.X();

  //---------  DATA Semileptonic Cut B0s -----------
  c1->cd(2);    
  sprintf(simply,"flavB == 4 && lepYes == 1");// || flavB==5) && lepYes==1");
  if(!SMALLSTATCORR)
    signalsig = sighistounb(datadata, Vmes, fitResults, mesNslTmp,  10000, 3000, simply, USECB);
  else{
    sprintf(simply,"flavB == 4 && lepYaSe == 1");//|| flavB==5) && lepYaSe==1");
    signalsig = sighistounb(datadata, Vmes, fitResults, mesdatacuts,  10000, 3000, simply, USECB);
  }
  double nb0sdata = signalsig.X();
  
  //---------  DATA Semileptonic Cut Bss -----------
  c1->cd(3);    
  sprintf(simply,"flavB == 5 && lepYes == 1");
  if(!SMALLSTATCORR)
    signalsig = sighistounb(datadata, Vmes, fitResults, mesNslTmp,  10000, 3000, simply, USECB);
  else{
    sprintf(simply,"flavB == 5 && lepYaSe == 1");
    signalsig = sighistounb(datadata, Vmes, fitResults, mesdatacuts,  10000, 3000, simply, USECB);
  }
  double nbssdata = signalsig.X();

  //if we count on MC we have to subtract peaking bkgd from fit on data...
 
  if(matchMC || SUBTRACTPEAKING){
    if(SMALLSTATCORR)
      cout<<"!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!! Peaking background subtraction not correct here. Must use All Cut values!!"<<endl;
    for(UInt_t i=0;i<pkgbkgcorr_SL.size();i++)
      cout<<"Subtracting peaking background from data SemiLeptonic cuts flavB= "<<3+i<<" correction "<<pkgbkgcorr_SL[i].X()<<endl;
    nbchdata *= pkgbkgcorr_SL[0].X();
    nb0sdata *= pkgbkgcorr_SL[1].X();    
    nbssdata *= pkgbkgcorr_SL[2].X();
  }
  
  double nb0data = nb0sdata+nbssdata;

  //---------- Vcb Semileptonic Cut Bch ---------------
  
  c1->cd(4);    
  sprintf(simply,"(flavB == 3) && lepYes == 1");
  if(su ==1)
    signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 60000., 15000., simply, USECB, 0, matchMC);
  else {
    if(!SMALLSTATCORR)
      signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 60000., 15000., simply, USECB, 0, matchMC);
    else{
      sprintf(simply,"(flavB == 3) && lepYaSe == 1");
      signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbcuts, 60000., 15000., simply, USECB, 0, matchMC);
    }
  }

  double nbchvcb = signalsig.X();

  //---------- Vcb Semileptonic Cut B0s ---------------
  c1->cd(5);  
  sprintf(simply,"(flavB == 4 || flavB == 5) && lepYes == 1");
  if(su ==1)
    signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 30000., 7000., simply, USECB, 0, matchMC);
  else {
    if(!SMALLSTATCORR)
      signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbMC, 30000., 7000., simply, USECB, 0, matchMC);
    else{
      sprintf(simply,"(flavB == 4 || flavB == 5) && lepYaSe == 1");
      signalsig = sighistounb(datamcvcb, Vmes, fitResults, mesvcbcuts, 30000., 7000., simply, USECB, 0, matchMC);
    }
  }
  double nb0vcb = signalsig.X();

  //---------- Vub IN Semileptonic Cut Bch ---------------
  c1->cd(6);  
  sprintf(simply,"(flavB == 3) && lepYes == 1");
  if(su ==1)
    signalsig = sighistounb(datavubin, Vmes, fitResults, mesvubMC,  3000, 800,  simply, USECB, 0, matchMC);
  else {
    if(!SMALLSTATCORR)
      signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubMC,  3000, 800,  simply, USECB, 0, matchMC);
    else {
      sprintf(simply,"(flavB == 3) && lepYaSe == 1");
      signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubcuts,  3000, 800,  simply, USECB, 0, matchMC);
    }
  }
  double nbchvub = signalsig.X();

  //---------- Vub IN Semileptonic Cut B0s ---------------
  c1->cd(7);    
  sprintf(simply,"(flavB == 4 || flavB == 5) && lepYes == 1");
  if(su ==1)
    signalsig = sighistounb(datavubin, Vmes, fitResults, mesvubMC,  1600, 500, simply, USECB, 0, matchMC);
  else {
    if(!SMALLSTATCORR)
      signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubMC,  1600, 500, simply, USECB, 0, matchMC);
    else {
      sprintf(simply,"(flavB == 4 || flavB == 5) && lepYaSe == 1");
      signalsig = sighistounb(datamcvub, Vmes, fitResults, mesvubcuts,  1600, 500, simply, USECB, 0, matchMC);
    }
  }
  double nb0vub = signalsig.X();
  
  c1->cd(8); 
  //---------- Vub OUT Semileptonic Cut Bch ---------------
  sprintf(simply,"(flavB == 3) && lepYes == 1");
  if(su == 1){
    signalsig = sighistounb(datavubout, Vmes, fitResults, mesvuboutMC, 6000, 1000, simply, USECB, 0, matchMC);
    //  }else{
  }
  std::cout << "Fitting semileptonic events on vubout mc3!!! :: " << fitResults << std::endl;
  double  nbchvubout = signalsig.X();                 

  c1->cd(9); 

  //---------- Vub OUT Semileptonic Cut B0s ---------------
  sprintf(simply,"(flavB == 4 || flavB == 5) && lepYes == 1");
  if(su == 1){
    signalsig = sighistounb(datavubout, Vmes, fitResults, mesvuboutMC, 6000, 1000, simply, USECB, 0, matchMC);
    //  }else{
  }

  double  nb0vubout = signalsig.X();                 

  c1->cd(10);
  //---------- Vcboth Semileptonic Cut Bch ---------------
  sprintf(simply,"(flavB == 3) && lepYes == 1");
  if(su == 1)
    signalsig = sighistounb(datavcboth, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  else
    signalsig = sighistounb(datamcoth, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);

  double  nbchvcboth = signalsig.X();             

  c1->cd(11); 

  //---------- Vcboth Semileptonic Cut B0s ---------------
  sprintf(simply,"(flavB == 4 || flavB == 5) && lepYes == 1");
  if(su == 1)
    signalsig = sighistounb(datavcboth, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);
  else
    signalsig = sighistounb(datamcoth, Vmes, fitResults, mesvcbMC, 100000, 25000, simply, USECB, 0, matchMC);


  double  nb0vcboth = signalsig.X();              
  
  // calculate purity for data ( vub + vcb + oth ). We are correcting for "other".

  if( !Sun ) {
    nbchvcboth += nbchvcb;
    nb0vcboth += nb0vcb;
    nbchvubout = 0;
    nb0vubout = 0;
  }						
   
  double puritybchvcb = (nbchvub+nbchvubout+nbchvcboth == 0) ? 1 : nbchvcb/( (nbchvub+nbchvubout)*LUMI_GENERIC/LUMI_SIGNAL+nbchvcboth);
  double purityb0vcb = (nb0vub+nb0vubout+nb0vcboth == 0) ? 1: nb0vcb/((nb0vub+nb0vubout)*LUMI_GENERIC/LUMI_SIGNAL+nb0vcboth);

  double ratiobchb0 = (nb0data == 0) ? 1: nbchdata*puritybchvcb/(nb0data*purityb0vcb);
  double ratiobchb0vcb = (nb0vcb == 0) ? 1: nbchvcb/nb0vcb;
  double ratiobchb0vub = (nb0vub == 0) ? 1: nbchvub/nb0vub;
  double ratiobchb0vubout = (nb0vubout ==0) ? 1: nbchvubout/nb0vubout;

  correctionratiovcb = ratiobchb0/ratiobchb0vcb;
  correctionratiovub = correctionratiovcb; // * ratiobchb0vub;///ratiobchb0vcb;
  correctionratiovubout = correctionratiovcb; // * ratiobchb0vubout;///ratiobchb0vcb;

  //  correctionratiovub = ratiobchb0/ratiobchb0vub; //OLD CORRECTION RATIO CALCULATION: in principle we don't want
  // to apply the correction on vub as on data (which is actually vcb)
  // ! ! ! ! ! ! ! ! ! ! ! ! WARNING !!!!!!!!!!!!!!!!!!!!
  // WHEN we are NOT fitting MC (thas has for all components the same file) we gotta correct for ratios of Branching
  // fraction and number of B+ and B0 that is actually on each (vub, generic) component
  // THIS STILL NEED TO BE IMPLEMENTED!!!!!! BE CAREFUL WHEN IMPLEMENTING STUFF ON DATA 


  sprintf(simply,"%s%s",DIRNAME.Data(),"chgcorr.eps");
  c1->SaveAs(simply);

  delete c1; c1 = NULL;

  cout << "purity bch vcb: " << puritybchvcb << " purity b0 vcb " << purityb0vcb << endl;

  if(BTYPE != 2){
    correctionratiovub = 1;
    correctionratiovcb = 1;
    correctionratiovubout = 1;
  }
  cout << "correctionratiovcb " << correctionratiovcb << endl;
  cout << "correctionratiovub " << correctionratiovub << endl;
  cout << "correctionratiovubOUT " << correctionratiovubout << endl;
  cout << " WARNING CORRECTIONRATIO STILL DOES NOT WORK ON DATA" << endl;

  if(FIXCORRRATIO){
    correctionratiovub = 1;
    correctionratiovcb = 1;
    correctionratiovubout = 1;
  }
}
void VirClass::CreateNewPstarSample(bool isWriteData){
  
  cout<<"Now Reweighting VubIN and VubOUT dataset and adding it to VcbOther to have a new Pstarsample dataset"<<endl;
  
  RooArgSet pstarSet = RooArgSet(*Vmes, *VlepYes, *VlepYaSe, *VflavB, *VlepVcb, *VlepVub, *VlepVubSB, *Vtrumtch, *Vwe);
  pstarSet.add(*Vde); pstarSet.add(*Vchop); pstarSet.add(*Vmx); pstarSet.add(*Vq2);
  
  if(isWriteData){
    pstarSet.add(*Vintpur); pstarSet.add(*Vch); pstarSet.add(*Vmultcat); pstarSet.add(*Vpplus);
  }
  
  RooArgList lov=RooArgList(pstarSet);
  
  //cout<<" List Of Variables has "<<lov.getSize()<<" entries"<<endl;

  vector<RooDataSet*> holder(3);
  holder[0]=datavcboth;
  holder[1]=datavubin;
  holder[2]=datavubout;

  Float_t ratiolumi[3]={1.,LUMI_GENERIC/LUMI_SIGNAL,LUMI_GENERIC/LUMI_SIGNAL},_weight;
  RooArgSet* entry;

  //Loop over datasets
  for(Int_t idset=0;idset<holder.size();idset++){
    Int_t numentries = holder[idset]->numEntries();
    cout<<" DATASET "<<holder[idset]->GetName()<< " has "<<numentries<<" entries; ";
    cout<<"Additional weight factor for "<<holder[idset]->GetName() <<" component is (ratio of luminosity) = "<<ratiolumi[idset]<<endl;

    for(Int_t jentry=0; jentry < numentries; jentry++){
      
      //Getting values for variables in event jentry
      entry=(RooArgSet*)holder[idset]->get(jentry);

      //Looping over variables
      for(Int_t ivar=0; ivar<lov.getSize(); ivar++){
	RooRealVar* var=dynamic_cast<RooRealVar*>(&lov[ivar]);

	//handle special cases
	if(strcmp(var->GetName(),"weight")==0) continue;
	if(strcmp(var->GetName(),"lepVub")==0){
	  VlepVub->setVal(idset>0 ? 1 : 0); continue;
	}
	if(strcmp(var->GetName(),"lepVubSB")==0){
	  VlepVubSB->setVal(idset==1 ? 1 : 0); continue;
	}
	if(strcmp(var->GetName(),"lepVcb")==0){
	  VlepVcb->setVal(idset==0 ? 1 : 0); continue;
	}
	//Set variable value
	var->setVal(((RooRealVar*)entry->find(var->GetName()))->getVal());
      }
      //getting weight for event jentry
      _weight=(holder[idset]->weight())*ratiolumi[idset];
      pstarsamplesum->add(pstarSet,_weight);
    }
  }
}
void VirClass::FillPDFTree(const RooAbsPdf* model, Int_t mesIdx, Double_t lumi, Int_t idx)
{
  
  Bool_t is_first = false;

  if( fOutTree == NULL ) {
    fOutTree = new TTree("PdfTree","PdfTree");
    is_first = true;
  }
  
  RooArgSet *params = model->getParameters( RooArgSet() );
  TIterator *iter = params->createIterator();

  RooRealVar *var = NULL;
  Int_t i = 0;
  Float_t tempo[11]; //11 parameters in Argus+Frankenstein model
  Float_t tempo_err[11];  //11 parameters in Argus+Frankenstein model

  while( (var=(RooRealVar*)iter->Next()) ){
    cout << var->GetName() << " " << var->getVal() << endl;
    if( strcmp( var->GetName(),"mes" ) == 0 ) continue;
    
    tempo[i] = var->getVal();
    tempo_err[i] = var->getError();
    
    if( is_first ) {
      fOutTree->Branch( var->GetName(), &tempo[i], Form( "%s%s",var->GetName(),"/F" ) );
      fOutTree->Branch( Form("%s_err",var->GetName() ), &tempo_err[i], Form( "%s_err",var->GetName(),"/D" ) );
    } else {
      fOutTree->SetBranchAddress( var->GetName(),&tempo[i] );
      fOutTree->SetBranchAddress( Form( "%s_err",var->GetName() ), &tempo_err[i] );
    }
    i++;
  }
  
  if( is_first ) {
    fOutTree->Branch( "mesfitIndex", &mesIdx, "mesfitIndex/I");
    fOutTree->Branch( "lumi", &lumi, "luminosity/D");
    fOutTree->Branch( "identifier", &idx, "identifier/I");
  } else {
    fOutTree->SetBranchAddress( "mesfitIndex", &mesIdx );
    fOutTree->SetBranchAddress( "lumi", &lumi );
    fOutTree->SetBranchAddress( "identifier", &idx);
  }
  fOutTree->Fill();
  delete params;
  delete iter;
}

void VirClass::CalculateCFMatrix(int Sun,int comb){
  
  cout << "---------------------------------------------------------------" << endl;
  cout << "     Entering CF Matrix Calculation                            " << endl;
  cout << endl;
  
  const Int_t SIZE = 2;   // Size of the CF matrix (2x2 or 3x3 or 4x4)
  const Int_t DTST_SIZE = 4;  // Number of datasets
  Double_t mat[SIZE*SIZE];
  Double_t measured[SIZE];
  Double_t errmeas[SIZE];
  Double_t tru[SIZE];
  Double_t errtru[SIZE];
  Double_t g00(0), errg00(0), gcc(0), errgcc(0);
  TString cut,thecut;
  
  TVector2 sig;
  vector<double> fitResults;
  Int_t i,idrow,idcol;
  Int_t ican;
  RooDataSet *dataset = NULL;
  TCanvas *cfcanvas = NULL;

  CFUtil* SLcuts[DTST_SIZE];
  CFUtil* ACcuts[DTST_SIZE];

  SLcuts[0] = new CFUtil(pstarsample, mespstarMC);    ACcuts[0] = new CFUtil(pstarsample, mespstarcuts);
  if(Sun) {
    SLcuts[1] = new CFUtil(datavcboth,  mesvcbMC);      ACcuts[1] = new CFUtil(datavcboth,  mesothcuts);
    SLcuts[2] = new CFUtil(datavubin,   mesvubMC);      ACcuts[2] = new CFUtil(datavubin,   mesvubcuts);
    SLcuts[3] = new CFUtil(datavubout,  mesvuboutMC);   ACcuts[3] = new CFUtil(datavubout,  mesvubcuts);
  } else {
    SLcuts[1] = new CFUtil(datamcvcb, mesvcbMC);  ACcuts[1] = new CFUtil(datamcvcb, mesvcbcuts);
    SLcuts[2] = new CFUtil(datamcvub, mesvubMC);  ACcuts[2] = new CFUtil(datamcvub, mesvubcuts);
    SLcuts[3] = new CFUtil(datamcoth, mesvcbMC);  ACcuts[3] = new CFUtil(datamcoth, mesothcuts);
  }

  //Ciclo esterno datasets.
  for(Int_t idset = 0; idset < DTST_SIZE; idset++) {
    dataset = SLcuts[idset]->GetDataset();
    ican = 0;
    TCanvas *cfcanvas = new TCanvas("cfcanvas","cfcanvas",0,0,800,600);
    //    cfcanvas->Divide(4,4);
    cfcanvas->Print(Form("%s%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),dataset->GetName(),"crossfeed.ps["));

    //Ciclo sui tagli
    for(Int_t icut = 0; icut < 2; icut++) {
      //      cfcanvas->cd(ican++);
      i = 0;  idcol = 0; idrow=0;
      thecut = icut == 0 ? "lepYes == 1" : "lepYaSe == 1";

      dataset = icut == 0 ? SLcuts[idset]->GetDataset() : ACcuts[idset]->GetDataset();
      vector<double> initz = icut == 0 ? SLcuts[idset]->GetMesParams() : ACcuts[idset]->GetMesParams();

      // Section for Kinematic scan
//       if(icut == 1) {
// 	Int_t topbin = comb ? xB1.size() : nB;
	
// 	for(Int_t iBin = 1; iBin < topbin; iBin++) {
// 	  if(comb)
// 	    thecut += Form(" && mx > %.3f && mx < %.3f",xB1[iBin-1],xB1[iBin]);
//  	  else
// 	    thecut += Form(" && chop > %.3f && chop < %.3f",chopB1[iBin-1],chopB1[iBin]);

// 	  signal = sighistounb(dataset,Vmes,fitResults, initz, 60000.,  15000., thecut.Data(), 0); 

	  cout << " Calculate CFMatrix processing now " << dataset->GetName() << " with cut " << thecut.Data() << endl;

	  for(Int_t row = 0; row < SIZE; row++) {
	    
	    if(SIZE == 2 && row == 1) idrow = 2;
	
	    cut = thecut + Form(" && (brecoid == %d || brecoid == %d)",idrow,idrow+1);    
	    
	    sig = sighistounb(dataset, Vmes, fitResults, initz, 100000, 25000, cut.Data(), 0);            
	    measured[row] = sig.X();
	    errmeas[row] = sig.Y();
	    //measured[row] = pstarsample->sumEntries(cut);
	    cout << cut.Data() << " measured[" << row << "]= " << measured[row] << endl;
	    
	    cfcanvas->Print(Form("%s%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),dataset->GetName(),"crossfeed.ps("));
	    cfcanvas->Clear();
	    //	cfcanvas->cd(ican++);
	    
	    cut = thecut + Form(" && (brecoidtrue == %d || brecoidtrue == %d)",idrow,idrow+1);    
	    sig = sighistounb(dataset, Vmes, fitResults, initz, 100000, 25000, cut.Data(), 0);            
	    tru[row] = sig.X();
	    errtru[row] = sig.Y();
	    //tru[row] = pstarsample->sumEntries(cut);
	    cout << cut.Data() << " tru["<< row << "]= "<< tru[row]<<endl;
	    
	    cfcanvas->Print(Form("%s%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),dataset->GetName(),"crossfeed.ps("));
	    cfcanvas->Clear();
	    //	cfcanvas->cd(ican++);
	
	    for(Int_t col = 0; col < SIZE; col++) {
	      if(SIZE == 2 && col == 1) idcol = 2;
	      else
		idcol = 0;
	      if( i == 1 || i == 2) {i++; continue;}
	      
	      cut = thecut + Form(" && (brecoidtrue ==  %d || brecoidtrue == %d)",idcol,idcol+1) + Form(" && (brecoid == %d || brecoid == %d)",idrow,idrow+1);    
	      sig = sighistounb(dataset, Vmes, fitResults, initz, 100000, 25000, cut.Data(), 0);            
	      mat[i] = sig.X();
	      
	      switch (i) {
	      case 0: g00 = sig.X(); errg00 = sig.Y(); break;
	      case 3: gcc = sig.X(); errgcc = sig.Y(); break;
	      default: ;
	      }
	      
	      //mat[i] = pstarsample->sumEntries(cut);
	      cout << cut.Data() << " numerator  mat[" << i << "]= " << mat[i] << endl;
	      cfcanvas->Print(Form("%s%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),dataset->GetName(),"crossfeed.ps("));
	      cfcanvas->Clear();
	      //  cfcanvas->cd(ican++);
	      cut = thecut + Form(" && (brecoidtrue == %d || brecoidtrue == %d)",idcol,idcol+1);    
	      sig = sighistounb(dataset, Vmes, fitResults, initz, 100000, 25000, cut.Data(), 0);      
	  
	      mat[i] /= sig.X();
	      //mat[i] /= pstarsample->sumEntries(cut);
	      cout << cut.Data() << " denominator mat[" << i << "]= " << mat[i] << endl;
	      //	  cfcanvas->cd(ican++);
	      cfcanvas->Print(Form("%s%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),dataset->GetName(),"crossfeed.ps("));
	      cfcanvas->Clear();
	      i++;
	    }
	  }

	  mat[2] = 1 - mat[0];
	  mat[1] = 1 - mat[3];
	  
	  TMatrixD a = TMatrixD(SIZE,SIZE);
	  a.SetMatrixArray(mat);

	  TMatrixDRow A1(a,0);
	  TMatrixDRow A2(a,1);


	  cout << " Crossfeed probability matrix " << " | " << A1[0] << " " << A1[1] << " | " << endl;
	  cout << " Crossfeed probability matrix " << " | " << A2[0] << " " << A2[1] << " | " << endl;

	  a.Invert();

	  TMatrixDRow B1(a,0);
	  TMatrixDRow B2(a,1);

	  cout << " Crossfeed inverted probability matrix " << " | " << B1[0] << " " << B1[1] << " | " << endl;
	  cout << " Crossfeed inverted probability matrix " << " | " << B2[0] << " " << B2[1] << " | " << endl;

	  TMatrixD y = TMatrixD(SIZE,1);
	  y.SetMatrixArray(measured);

	  cfdump.push_back(new CFDump(dataset->GetName(),thecut,a,g00,errg00,tru[0],errtru[0],gcc,errgcc,tru[1],errtru[1],measured[0],measured[1]));

      // other display infos
      TMatrixD c = a*y ;
      TMatrixDRow c1(c,0);
      TMatrixDRow c2(c,1);

      cout << " Linear system output " << " | " << c1[0] << " +- " << 
	CFerrorProp(true, 0, g00, errg00, tru[0], errtru[0], measured[0], errmeas[0], gcc, errgcc, tru[1], errtru[1], measured[1], errmeas[1],measured[0],measured[1]) 
	   << " true "  << tru[0] << " +- " << errtru[0] << " difference " << (c1[0] - tru[0]) << " perc. var. " << (c1[0]-tru[0])/tru[0]*100 << endl; 
      cout << " Linear system output " << " | " << c2[0] << " +- " << 
	CFerrorProp(true, 1, g00, errg00,tru[0],  errtru[0], measured[0], errmeas[0], gcc, errgcc, tru[1], errtru[1], measured[1], errmeas[1],measured[0],measured[1]) 
	   << " true " << tru[1] << " +- " << errtru[1] << " difference " << (c2[0] - tru[1]) << " perc. var. " << (c2[0]-tru[1])/tru[1]*100 << endl; 

    } // End Cut Loop
    
    cfcanvas->Print(Form("%s%s%s%s",DIRNAME.Data(),PREFIXOUT.Data(),dataset->GetName(),"crossfeed.ps]"));
    delete cfcanvas;
    cfcanvas = NULL;
  } // End Dataset Loop
  
  for(Int_t i = 0; i < DTST_SIZE; i++) {
    delete SLcuts[i];
    delete ACcuts[i];
  }
}

Double_t CFerrorProp(bool isMC, bool ischarged, Double_t a, Double_t Sigmag0, Double_t b, Double_t Sigmag1, Double_t c, Double_t Sigmam0, Double_t d, Double_t Sigmag2, Double_t e, Double_t Sigmag3, Double_t f, Double_t Sigmamc, Double_t g, Double_t h) {
  
  /* a = Gnn = True neutrals reconstructed as neutrals (brecoid == 0 || 1 && brecoidtrue == 0 || 1)
     b = Gn  = True neutrals (brecoidtrue == 0 || 1)
     c = Mn  = Reconstructed Neutrals (brecoid == 0 || 1) (in the i-th bin of the kinematic variable)
     d = Gcc = True charged reconstructed as charged (brecoid == 2 || 3 && brecoidtrue == 2 || 3)
     e = Gc  = True charged (brecoidtrue == 2 || 3) (in the i-th bin of the kinematic variable)
     f = Mc  = Reconstructed Charged (brecoid == 2 || 3)
     g = Mnt = Reconstructed Neutrals on all kinematic range
     h = Mct = Reconstructed Charged  on all kinematic range
     sigmag0 = sigma a
     sigmag1 = sigma b
     sigmam0 = sigma c
     sigmag2 = sigma d
     sigmag3 = sigma e
     sigmamc = sigma f						
  */

  if(!ischarged) {
    if(isMC)
      return TMath::Sqrt((-((c*d)/(b*pow(-1 + a/b + d/e,2)*e)) + ((-d + e)*f)/(b*pow(-1 + a/b + d/e,2)*e))*((-((c*d)/(b*pow(-1 + a/b + d/e,2)*e)) + ((-d + e)*f)/(b*pow(-1 + a/b + d/e,2)*e))*pow(Sigmag0,2) + (a*((a*c*d)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e) - (a*(-d + e)*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e))*Sigmag0*Sigmag1)/b + (a*c*d*Sigmag0*Sigmam0)/((-1 + a/b + d/e)*e*pow(g,2))) + (d*((a*c*(-((c*d)/(b*pow(-1 + a/b + d/e,2)*e)) + ((-d + e)*f)/(b*pow(-1 + a/b + d/e,2)*e))*Sigmag0*Sigmam0)/pow(g,2) + (a*c*((a*c*d)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e) - (a*(-d + e)*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e))*Sigmag1*Sigmam0)/((b - d + e)*g) + (c*(-d + e)*((c*pow(d,2))/(pow(-1 + a/b + d/e,2)*pow(e,3)) - (c*d)/((-1 + a/b + d/e)*pow(e,2)) - f/((-1 + a/b + d/e)*e) - (d*(-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,3)) + ((-d + e)*f)/((-1 + a/b + d/e)*pow(e,2)))*Sigmag3*Sigmam0)/((a + e)*g) + (d*pow(Sigmam0,2))/((-1 + a/b + d/e)*e)))/((-1 + a/b + d/e)*e) + ((a*c*d)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e) - (a*(-d + e)*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e))*((a*(-((c*d)/(b*pow(-1 + a/b + d/e,2)*e)) + ((-d + e)*f)/(b*pow(-1 + a/b + d/e,2)*e))*Sigmag0*Sigmag1)/b + ((a*c*d)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e) - (a*(-d + e)*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e))*pow(Sigmag1,2) + (a*c*d*Sigmag1*Sigmam0)/((-1 + a/b + d/e)*e*(b - d + e)*g) - ((-a + b)*(-d + e)*f*Sigmag1*Sigmamc)/((b + d)*(-1 + a/b + d/e)*e*h)) + (-((c*d)/(pow(-1 + a/b + d/e,2)*pow(e,2))) + c/((-1 + a/b + d/e)*e) + f/((-1 + a/b + d/e)*e) + ((-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,2)))*((-((c*d)/(pow(-1 + a/b + d/e,2)*pow(e,2))) + c/((-1 + a/b + d/e)*e) + f/((-1 + a/b + d/e)*e) + ((-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,2)))*pow(Sigmag2,2) + (d*((c*pow(d,2))/(pow(-1 + a/b + d/e,2)*pow(e,3)) - (c*d)/((-1 + a/b + d/e)*pow(e,2)) - f/((-1 + a/b + d/e)*e) - (d*(-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,3)) + ((-d + e)*f)/((-1 + a/b + d/e)*pow(e,2)))*Sigmag2*Sigmag3)/e - (d*(-d + e)*f*Sigmag2*Sigmamc)/((-1 + a/b + d/e)*e*pow(h,2))) + ((c*pow(d,2))/(pow(-1 + a/b + d/e,2)*pow(e,3)) - (c*d)/((-1 + a/b + d/e)*pow(e,2)) - f/((-1 + a/b + d/e)*e) - (d*(-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,3)) + ((-d + e)*f)/((-1 + a/b + d/e)*pow(e,2)))*((d*(-((c*d)/(pow(-1 + a/b + d/e,2)*pow(e,2))) + c/((-1 + a/b + d/e)*e) + f/((-1 + a/b + d/e)*e) + ((-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,2)))*Sigmag2*Sigmag3)/e + ((c*pow(d,2))/(pow(-1 + a/b + d/e,2)*pow(e,3)) - (c*d)/((-1 + a/b + d/e)*pow(e,2)) - f/((-1 + a/b + d/e)*e) - (d*(-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,3)) + ((-d + e)*f)/((-1 + a/b + d/e)*pow(e,2)))*pow(Sigmag3,2) + (c*d*(-d + e)*Sigmag3*Sigmam0)/((-1 + a/b + d/e)*e*(a + e)*g) - (d*(-d + e)*f*Sigmag3*Sigmamc)/((-1 + a/b + d/e)*e*(-a + b + e)*h)) - ((-d + e)*(((-a + b)*f*((a*c*d)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e) - (a*(-d + e)*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e))*Sigmag1*Sigmamc)/((b + d)*h) + (d*f*(-((c*d)/(pow(-1 + a/b + d/e,2)*pow(e,2))) + c/((-1 + a/b + d/e)*e) + f/((-1 + a/b + d/e)*e) + ((-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,2)))*Sigmag2*Sigmamc)/pow(h,2) + (d*f*((c*pow(d,2))/(pow(-1 + a/b + d/e,2)*pow(e,3)) - (c*d)/((-1 + a/b + d/e)*pow(e,2)) - f/((-1 + a/b + d/e)*e) - (d*(-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,3)) + ((-d + e)*f)/((-1 + a/b + d/e)*pow(e,2)))*Sigmag3*Sigmamc)/((-a + b + e)*h) - ((-d + e)*pow(Sigmamc,2))/((-1 + a/b + d/e)*e)))/((-1 + a/b + d/e)*e));

    /* OLD ONE: WRONG CORRELATION MATRIX....
      return TMath::Sqrt((-((c*d)/(b*pow(-1 + a/b + d/e,2)*e)) + ((-d + e)*f)/(b*pow(-1 + a/b + d/e,2)*e))*((-((c*d)/(b*pow(-1 + a/b + d/e,2)*e)) + ((-d + e)*f)/(b*pow(-1 + a/b + d/e,2)*e))*pow(Sigmag0,2) + (a*((a*c*d)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e) - (a*(-d + e)*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e))*Sigmag0*Sigmag1)/b + (a*d*Sigmag0*Sigmam0)/(c*(-1 + a/b + d/e)*e)) + (d*((a*(-((c*d)/(b*pow(-1 + a/b + d/e,2)*e)) + ((-d + e)*f)/(b*pow(-1 + a/b + d/e,2)*e))* Sigmag0*Sigmam0)/c + (b*((a*c*d)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e) - (a*(-d + e)*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e))*Sigmag1*Sigmam0)/c + ((-d + e)*((c*pow(d,2))/(pow(-1 + a/b + d/e,2)*pow(e,3)) - (c*d)/((-1 + a/b + d/e)*pow(e,2)) - f/((-1 + a/b + d/e)*e) - (d*(-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,3)) + ((-d + e)*f)/((-1 + a/b + d/e)*pow(e,2)))*Sigmag3*Sigmam0)/e + (d*pow(Sigmam0,2))/((-1 + a/b + d/e)*e)))/((-1 + a/b + d/e)*e) + ((a*c*d)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e) - (a*(-d + e)*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e))* ((a*(-((c*d)/(b*pow(-1 + a/b + d/e,2)*e)) + ((-d + e)*f)/(b*pow(-1 + a/b + d/e,2)*e))* Sigmag0*Sigmag1)/b + ((a*c*d)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e) - (a*(-d + e)*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e))*pow(Sigmag1,2) + (b*d*Sigmag1*Sigmam0)/(c*(-1 + a/b + d/e)*e) - ((-a + b)*(-d + e)*Sigmag1*Sigmamc)/(b*(-1 + a/b + d/e)*e)) + (-((c*d)/(pow(-1 + a/b + d/e,2)*pow(e,2))) + c/((-1 + a/b + d/e)*e) + f/((-1 + a/b + d/e)*e) + ((-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,2)))*((-((c*d)/(pow(-1 + a/b + d/e,2)*pow(e,2))) + c/((-1 + a/b + d/e)*e) + f/((-1 + a/b + d/e)*e) + ((-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,2)))* pow(Sigmag2,2) + (d*((c*pow(d,2))/(pow(-1 + a/b + d/e,2)*pow(e,3)) - (c*d)/((-1 + a/b + d/e)*pow(e,2)) - f/((-1 + a/b + d/e)*e) - (d*(-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,3)) + ((-d + e)*f)/((-1 + a/b + d/e)*pow(e,2)))*Sigmag2*Sigmag3)/e - (d*(-d + e)*Sigmag2*Sigmamc)/((-1 + a/b + d/e)*e*f)) + ((c*pow(d,2))/(pow(-1 + a/b + d/e,2)*pow(e,3)) - (c*d)/((-1 + a/b + d/e)*pow(e,2)) - f/((-1 + a/b + d/e)*e) - (d*(-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,3)) + ((-d + e)*f)/((-1 + a/b + d/e)*pow(e,2)))*((d*(-((c*d)/(pow(-1 + a/b + d/e,2)*pow(e,2))) + c/((-1 + a/b + d/e)*e) + f/((-1 + a/b + d/e)*e) + ((-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,2)))*Sigmag2* Sigmag3)/e + ((c*pow(d,2))/(pow(-1 + a/b + d/e,2)*pow(e,3)) - (c*d)/((-1 + a/b + d/e)*pow(e,2)) - f/((-1 + a/b + d/e)*e) - (d*(-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,3)) + ((-d + e)*f)/((-1 + a/b + d/e)*pow(e,2)))*pow(Sigmag3,2) + (d*(-d + e)*Sigmag3*Sigmam0)/((-1 + a/b + d/e)*pow(e,2)) - ((-d + e)*Sigmag3*Sigmamc)/((-1 + a/b + d/e)*f)) - ((-d + e)*(((-a + b)*((a*c*d)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e) - (a*(-d + e)*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)*e))*Sigmag1*Sigmamc)/b + (d*(-((c*d)/(pow(-1 + a/b + d/e,2)*pow(e,2))) + c/((-1 + a/b + d/e)*e) + f/((-1 + a/b + d/e)*e) + ((-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,2)))*Sigmag2*Sigmamc)/f + (e*((c*pow(d,2))/(pow(-1 + a/b + d/e,2)*pow(e,3)) - (c*d)/((-1 + a/b + d/e)*pow(e,2)) - f/((-1 + a/b + d/e)*e) - (d*(-d + e)*f)/(pow(-1 + a/b + d/e,2)*pow(e,3)) + ((-d + e)*f)/((-1 + a/b + d/e)*pow(e,2)))*Sigmag3*Sigmamc)/f - ((-d + e)*pow(Sigmamc,2))/((-1 + a/b + d/e)*e)))/((-1 + a/b + d/e)*e));
*/
    else
      return TMath::Sqrt((-((c*d*(b/pow(a,2) + d/(b*e) - (b*d)/(pow(a,2)*e))) / (pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e)) + ((b/pow(a,2) + d/(b*e) - (b*d)/(pow(a,2)*e))*(-d + e)*f) / (pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e))*((-((c*d*(b/pow(a,2) + d/(b*e) - (b*d)/(pow(a,2)*e)))/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e)) + ((b/pow(a,2) + d/(b*e) - (b*d)/(pow(a,2)*e))*(-d + e)*f)/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e))*pow(Sigmag0,2) + (a*(-((c*d*(-(1/a) + d/(a*e) - (a*d)/(pow(b,2)*e)))/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e)) + ((-(1/a) + d/(a*e) - (a*d)/(pow(b,2)*e))*(-d + e)*f)/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e))*Sigmag0*Sigmag1)/b) + (-((c*d*(-(1/a) + d/(a*e) - (a*d)/(pow(b,2)*e)))/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e)) + ((-(1/a) + d/(a*e) - (a*d)/(pow(b,2)*e))*(-d + e)*f)/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e))*((a*(-((c*d*(b/pow(a,2) + d/(b*e) - (b*d)/(pow(a,2)*e)))/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e)) + ((b/pow(a,2) + d/(b*e) - (b*d)/(pow(a,2)*e))*(-d + e)*f)/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e))*Sigmag0*Sigmag1)/b + (-((c*d*(-(1/a) + d/(a*e) - (a*d)/(pow(b,2)*e)))/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e)) + ((-(1/a) + d/(a*e) - (a*d)/(pow(b,2)*e))*(-d + e)*f)/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e))*pow(Sigmag1,2)) + (-((c*d*(-(1/e) + a/(b*e) + b/(a*e)))/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e)) + c/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*e) + f/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*e) + ((-(1/e) + a/(b*e) + b/(a*e))*(-d + e)*f)/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e))*((-((c*d*(-(1/e) + a/(b*e) + b/(a*e)))/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e)) + c/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*e) + f/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*e) + ((-(1/e) + a/(b*e) + b/(a*e))*(-d + e)*f)/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e))*pow(Sigmag2,2) + (d*(-((c*d)/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*pow(e,2))) - (c*d*(d/pow(e,2) - (a*d)/(b*pow(e,2)) - (b*d)/(a*pow(e,2))))/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e) - f/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*e) + ((-d + e)*f)/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*pow(e,2)) + ((d/pow(e,2) - (a*d)/(b*pow(e,2)) - (b*d)/(a*pow(e,2)))*(-d + e)*f)/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e))*Sigmag2*Sigmag3)/e) + (-((c*d)/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*pow(e,2))) - (c*d*(d/pow(e,2) - (a*d)/(b*pow(e,2)) - (b*d)/(a*pow(e,2))))/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e) - f/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*e) + ((-d + e)*f)/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*pow(e,2)) + ((d/pow(e,2) - (a*d)/(b*pow(e,2)) - (b*d)/(a*pow(e,2)))*(-d + e)*f)/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e))*((d*(-((c*d*(-(1/e) + a/(b*e) + b/(a*e)))/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e)) + c/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*e) + f/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*e) + ((-(1/e) + a/(b*e) + b/(a*e))*(-d + e)*f)/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e))*Sigmag2*Sigmag3)/e + (-((c*d)/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*pow(e,2))) - (c*d*(d/pow(e,2) - (a*d)/(b*pow(e,2)) - (b*d)/(a*pow(e,2))))/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e) - f/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*e) + ((-d + e)*f)/((1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))*pow(e,2)) + ((d/pow(e,2) - (a*d)/(b*pow(e,2)) - (b*d)/(a*pow(e,2)))*(-d + e)*f)/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*e))*pow(Sigmag3,2)) + (pow(d,2)*pow(Sigmam0,2))/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*pow(e,2)) + (pow(-d + e,2)*pow(Sigmamc,2))/(pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)*pow(e,2)));
  } 
  
  if(ischarged) {
    if(isMC)
      return TMath::Sqrt((((-a + b)*c)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + c/(b*(-1 + a/b + d/e)) - (a*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + f/(b*(-1 + a/b + d/e)))*((((-a + b)*c)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + c/(b*(-1 + a/b + d/e)) - (a*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + f/(b*(-1 + a/b + d/e)))*pow(Sigmag0,2) + (a*(-((a*(-a + b)*c)/(pow(b,3)*pow(-1 + a/b + d/e,2))) - c/(b*(-1 + a/b + d/e)) + ((-a + b)*c)/(pow(b,2)*(-1 + a/b + d/e)) + (pow(a,2)*f)/(pow(b,3)*pow(-1 + a/b + d/e,2)) - (a*f)/(pow(b,2)*(-1 + a/b + d/e)))*Sigmag0*Sigmag1)/b - (a*(-a + b)*c*Sigmag0*Sigmam0)/(b*(-1 + a/b + d/e)*pow(g,2))) - ((-a + b)*((a*c*(((-a + b)*c)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + c/(b*(-1 + a/b + d/e)) - (a*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + f/(b*(-1 + a/b + d/e)))*Sigmag0*Sigmam0)/pow(g,2) + (a*c*(-((a*(-a + b)*c)/(pow(b,3)*pow(-1 + a/b + d/e,2))) - c/(b*(-1 + a/b + d/e)) + ((-a + b)*c)/(pow(b,2)*(-1 + a/b + d/e)) + (pow(a,2)*f)/(pow(b,3)*pow(-1 + a/b + d/e,2)) - (a*f)/(pow(b,2)*(-1 + a/b + d/e)))*Sigmag1*Sigmam0)/((b - d + e)*g) + (c*(-d + e)*(-(((-a + b)*c*d)/(b*pow(-1 + a/b + d/e,2)*pow(e,2))) + (a*d*f)/(b*pow(-1 + a/b + d/e,2)*pow(e,2)))*Sigmag3*Sigmam0)/((a + e)*g) - ((-a + b)*pow(Sigmam0,2))/(b*(-1 + a/b + d/e))))/(b*(-1 + a/b + d/e)) + (-((a*(-a + b)*c)/(pow(b,3)*pow(-1 + a/b + d/e,2))) - c/(b*(-1 + a/b + d/e)) + ((-a + b)*c)/(pow(b,2)*(-1 + a/b + d/e)) + (pow(a,2)*f)/(pow(b,3)*pow(-1 + a/b + d/e,2)) - (a*f)/(pow(b,2)*(-1 + a/b + d/e)))*((a*(((-a + b)*c)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + c/(b*(-1 + a/b + d/e)) - (a*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + f/(b*(-1 + a/b + d/e)))*Sigmag0* Sigmag1)/b + (-((a*(-a + b)*c)/(pow(b,3)*pow(-1 + a/b + d/e,2))) - c/(b*(-1 + a/b + d/e)) + ((-a + b)*c)/(pow(b,2)*(-1 + a/b + d/e)) + (pow(a,2)*f)/(pow(b,3)*pow(-1 + a/b + d/e,2)) - (a*f)/(pow(b,2)*(-1 + a/b + d/e)))*pow(Sigmag1,2) - (a*(-a + b)*c*Sigmag1*Sigmam0)/(b*(-1 + a/b + d/e)*(b - d + e)*g) + (a*(-a + b)*f*Sigmag1*Sigmamc)/(b*(b + d)*(-1 + a/b + d/e)*h)) + (((-a + b)*c)/(b*pow(-1 + a/b + d/e,2)*e) - (a*f)/(b*pow(-1 + a/b + d/e,2)*e))*((((-a + b)*c)/(b*pow(-1 + a/b + d/e,2)*e) - (a*f)/(b*pow(-1 + a/b + d/e,2)*e))*pow(Sigmag2,2) + (d*(-(((-a + b)*c*d)/(b*pow(-1 + a/b + d/e,2)*pow(e,2))) + (a*d*f)/(b*pow(-1 + a/b + d/e,2)*pow(e,2)))*Sigmag2*Sigmag3)/e + (a*d*f*Sigmag2*Sigmamc)/(b*(-1 + a/b + d/e)*pow(h,2))) + (-(((-a + b)*c*d)/(b*pow(-1 + a/b + d/e,2)*pow(e,2))) + (a*d*f)/(b*pow(-1 + a/b + d/e,2)*pow(e,2)))*((d*(((-a + b)*c)/(b*pow(-1 + a/b + d/e,2)*e) - (a*f)/(b*pow(-1 + a/b + d/e,2)*e))*Sigmag2*Sigmag3)/e + (-(((-a + b)*c*d)/(b*pow(-1 + a/b + d/e,2)*pow(e,2))) + (a*d*f)/(b*pow(-1 + a/b + d/e,2)*pow(e,2)))*pow(Sigmag3,2) - ((-a + b)*c*(-d + e)*Sigmag3*Sigmam0)/(b*(-1 + a/b + d/e)*(a + e)*g) + (a*d*f*Sigmag3*Sigmamc)/(b*(-1 + a/b + d/e)*(-a + b + e)*h)) + (a*(((-a + b)*f*(-((a*(-a + b)*c)/(pow(b,3)*pow(-1 + a/b + d/e,2))) - c/(b*(-1 + a/b + d/e)) + ((-a + b)*c)/(pow(b,2)*(-1 + a/b + d/e)) + (pow(a,2)*f)/(pow(b,3)*pow(-1 + a/b + d/e,2)) - (a*f)/(pow(b,2)*(-1 + a/b + d/e)))*Sigmag1*Sigmamc)/((b + d)*h) + (d*f*(((-a + b)*c)/(b*pow(-1 + a/b + d/e,2)*e) - (a*f)/(b*pow(-1 + a/b + d/e,2)*e))*Sigmag2*Sigmamc)/pow(h,2) + (d*f*(-(((-a + b)*c*d)/(b*pow(-1 + a/b + d/e,2)*pow(e,2))) + (a*d*f)/(b*pow(-1 + a/b + d/e,2)*pow(e,2)))*Sigmag3*Sigmamc)/((-a + b + e)*h) + (a*pow(Sigmamc,2))/(b*(-1 + a/b + d/e))))/(b*(-1 + a/b + d/e)));

    /* OLD ONE: WRONG CORRELATION MATRIX
return TMath::Sqrt((((-a + b)*c)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + c/(b*(-1 + a/b + d/e)) - (a*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + f/(b*(-1 + a/b + d/e)))*((((-a + b)*c)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + c/(b*(-1 + a/b + d/e)) - (a*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + f/(b*(-1 + a/b + d/e)))*pow(Sigmag0,2) + (a*(-((a*(-a + b)*c)/(pow(b,3)*pow(-1 + a/b + d/e,2))) - c/(b*(-1 + a/b + d/e)) + ((-a + b)*c)/(pow(b,2)*(-1 + a/b + d/e)) + (pow(a,2)*f)/(pow(b,3)*pow(-1 + a/b + d/e,2)) - (a*f)/(pow(b,2)*(-1 + a/b + d/e)))* Sigmag0*Sigmag1)/b - (a*(-a + b)*Sigmag0*Sigmam0)/(b*c*(-1 + a/b + d/e))) - ((-a + b)*((a*(((-a + b)*c)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + c/(b*(-1 + a/b + d/e)) - (a*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + f/(b*(-1 + a/b + d/e)))*Sigmag0* Sigmam0)/c + (b*(-((a*(-a + b)*c)/(pow(b,3)*pow(-1 + a/b + d/e,2))) - c/(b*(-1 + a/b + d/e)) + ((-a + b)*c)/(pow(b,2)*(-1 + a/b + d/e)) + (pow(a,2)*f)/(pow(b,3)*pow(-1 + a/b + d/e,2)) - (a*f)/(pow(b,2)*(-1 + a/b + d/e))) *Sigmag1*Sigmam0)/c + ((-d + e)*(-(((-a + b)*c*d)/(b*pow(-1 + a/b + d/e,2)*pow(e,2))) + (a*d*f)/(b*pow(-1 + a/b + d/e,2)*pow(e,2)))*Sigmag3*Sigmam0)/e - ((-a + b)*pow(Sigmam0,2))/(b*(-1 + a/b + d/e))))/(b*(-1 + a/b + d/e)) + (-((a*(-a + b)*c)/(pow(b,3)*pow(-1 + a/b + d/e,2))) - c/(b*(-1 + a/b + d/e)) + ((-a + b)*c)/(pow(b,2)*(-1 + a/b + d/e)) + (pow(a,2)*f)/(pow(b,3)*pow(-1 + a/b + d/e,2)) - (a*f)/(pow(b,2)*(-1 + a/b + d/e)))* ((a*(((-a + b)*c)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + c/(b*(-1 + a/b + d/e)) - (a*f)/(pow(b,2)*pow(-1 + a/b + d/e,2)) + f/(b*(-1 + a/b + d/e)))*Sigmag0* Sigmag1)/b + (-((a*(-a + b)*c)/(pow(b,3)*pow(-1 + a/b + d/e,2))) - c/(b*(-1 + a/b + d/e)) + ((-a + b)*c)/(pow(b,2)*(-1 + a/b + d/e)) + (pow(a,2)*f)/(pow(b,3)*pow(-1 + a/b + d/e,2)) - (a*f)/(pow(b,2)*(-1 + a/b + d/e)))* pow(Sigmag1,2) - ((-a + b)*Sigmag1*Sigmam0)/(c*(-1 + a/b + d/e)) + (a*(-a + b)*Sigmag1*Sigmamc)/(pow(b,2)*(-1 + a/b + d/e))) + (((-a + b)*c)/(b*pow(-1 + a/b + d/e,2)*e) - (a*f)/(b*pow(-1 + a/b + d/e,2)*e))*((((-a + b)*c)/(b*pow(-1 + a/b + d/e,2)*e) - (a*f)/(b*pow(-1 + a/b + d/e,2)*e))* pow(Sigmag2,2) + (d*(-(((-a + b)*c*d)/(b*pow(-1 + a/b + d/e,2)*pow(e,2))) + (a*d*f)/(b*pow(-1 + a/b + d/e,2)*pow(e,2)))*Sigmag2*Sigmag3)/e + (a*d*Sigmag2*Sigmamc)/(b*(-1 + a/b + d/e)*f)) + (-(((-a + b)*c*d)/(b*pow(-1 + a/b + d/e,2)*pow(e,2))) + (a*d*f)/(b*pow(-1 + a/b + d/e,2)*pow(e,2)))* ((d*(((-a + b)*c)/(b*pow(-1 + a/b + d/e,2)*e) - (a*f)/(b*pow(-1 + a/b + d/e,2)*e))* Sigmag2*Sigmag3)/e + (-(((-a + b)*c*d)/(b*pow(-1 + a/b + d/e,2)*pow(e,2))) + (a*d*f)/(b*pow(-1 + a/b + d/e,2)*pow(e,2)))*pow(Sigmag3,2) - ((-a + b)*(-d + e)*Sigmag3*Sigmam0)/(b*(-1 + a/b + d/e)*e) + (a*e*Sigmag3*Sigmamc)/(b*(-1 + a/b + d/e)*f)) + (a*(((-a + b)*(-((a*(-a + b)*c)/(pow(b,3)*pow(-1 + a/b + d/e,2))) - c/(b*(-1 + a/b + d/e)) + ((-a + b)*c)/(pow(b,2)*(-1 + a/b + d/e)) + (pow(a,2)*f)/(pow(b,3)*pow(-1 + a/b + d/e,2)) - (a*f)/(pow(b,2)*(-1 + a/b + d/e))) *Sigmag1*Sigmamc)/b + (d*(((-a + b)*c)/(b*pow(-1 + a/b + d/e,2)*e) - (a*f)/(b*pow(-1 + a/b + d/e,2)*e))* Sigmag2*Sigmamc)/f + (e*(-(((-a + b)*c*d)/(b*pow(-1 + a/b + d/e,2)*pow(e,2))) + (a*d*f)/(b*pow(-1 + a/b + d/e,2)*pow(e,2)))*Sigmag3*Sigmamc)/f + (a*pow(Sigmamc,2))/(b*(-1 + a/b + d/e))))/(b*(-1 + a/b + d/e)));
       */
    else
      return TMath::Sqrt((((-a + b)*c*(b/pow(a,2) + d/(b*e) - (b*d)/(pow(a,2)*e)))/(a*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) + c/(a*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))) + ((-a + b)*c)/(pow(a,2)*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))) - (a*(b/pow(a,2) + d/(b*e) - (b*d)/(pow(a,2)*e))*f)/(b*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) + f/(b*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))))* ((((-a + b)*c*(b/pow(a,2) + d/(b*e) - (b*d)/(pow(a,2)*e)))/(a*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) + c/(a*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))) + ((-a + b)*c)/(pow(a,2)*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))) - (a*(b/pow(a,2) + d/(b*e) - (b*d)/(pow(a,2)*e))*f)/(b*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) + f/(b*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))))*pow(Sigmag0,2) + (a*(((-a + b)*c*(-(1/a) + d/(a*e) - (a*d)/(pow(b,2)*e)))/(a*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) - c/(a*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))) - (a*(-(1/a) + d/(a*e) - (a*d)/(pow(b,2)*e))*f)/(b*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) - (a*f)/(pow(b,2)*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))))*Sigmag0*Sigmag1)/b) + (((-a + b)*c*(-(1/a) + d/(a*e) - (a*d)/(pow(b,2)*e)))/(a*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) - c/(a*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))) - (a*(-(1/a) + d/(a*e) - (a*d)/(pow(b,2)*e))*f)/(b*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) - (a*f)/(pow(b,2)*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))))*((a*(((-a + b)*c*(b/pow(a,2) + d/(b*e) - (b*d)/(pow(a,2)*e)))/(a*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) + c/(a*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))) + ((-a + b)*c)/(pow(a,2)*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))) - (a*(b/pow(a,2) + d/(b*e) - (b*d)/(pow(a,2)*e))*f)/(b*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) + f/(b*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))))*Sigmag0*Sigmag1)/b + (((-a + b)*c*(-(1/a) + d/(a*e) - (a*d)/(pow(b,2)*e)))/(a*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) - c/(a*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))) - (a*(-(1/a) + d/(a*e) - (a*d)/(pow(b,2)*e))*f)/(b*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) - (a*f)/(pow(b,2)*(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e))))*pow(Sigmag1,2)) + (((-a + b)*c*(-(1/e) + a/(b*e) + b/(a*e)))/(a*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) - (a*(-(1/e) + a/(b*e) + b/(a*e))*f)/(b*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)))*((((-a + b)*c*(-(1/e) + a/(b*e) + b/(a*e)))/(a*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) - (a*(-(1/e) + a/(b*e) + b/(a*e))*f)/(b*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)))* pow(Sigmag2,2) + (d*(((-a + b)*c*(d/pow(e,2) - (a*d)/(b*pow(e,2)) - (b*d)/(a*pow(e,2))))/(a*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) - (a*(d/pow(e,2) - (a*d)/(b*pow(e,2)) - (b*d)/(a*pow(e,2)))*f)/(b*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)))*Sigmag2*Sigmag3)/e) + (((-a + b)*c*(d/pow(e,2) - (a*d)/(b*pow(e,2)) - (b*d)/(a*pow(e,2))))/(a*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) - (a*(d/pow(e,2) - (a*d)/(b*pow(e,2)) - (b*d)/(a*pow(e,2)))*f)/(b*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)))*((d*(((-a + b)*c*(-(1/e) + a/(b*e) + b/(a*e)))/(a*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) - (a*(-(1/e) + a/(b*e) + b/(a*e))*f)/(b*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)))*Sigmag2*Sigmag3)/e + (((-a + b)*c*(d/pow(e,2) - (a*d)/(b*pow(e,2)) - (b*d)/(a*pow(e,2))))/(a*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) - (a*(d/pow(e,2) - (a*d)/(b*pow(e,2)) - (b*d)/(a*pow(e,2)))*f)/ (b*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)))*pow(Sigmag3,2)) + (pow(-a + b,2)*pow(Sigmam0,2))/(pow(a,2)*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)) + (pow(a,2)*pow(Sigmamc,2))/(pow(b,2)*pow(1 - b/a - d/e + (a*d)/(b*e) + (b*d)/(a*e),2)));
  }
}


Double_t SetFlav(Int_t id){
  switch(id) {
  case  511 : return 0; break;  // B0
  case -511 : return 1; break;  // B0bar
  case  521 : return 2; break;  // B+
  case -521 : return 3; break;  // B-
  default : return -3;
  }
}


void VirClass::SavePDFTree()
{
  cout << " SAVING PDF TREE " << endl;
  TFile *_file = new TFile(TString( DIRNAME+"/PDFfile.root" ),"CREATE");
  _file->cd();
  _file->Add(fOutTree);
  _file->Write();
  _file->Close();
  _file = NULL;
  fHistFile->cd();
  //  delete fOutTree;
  // delete _file;  
}

void VirClass::openPdfToyFile(const TString& fname) {

  if( ! READPDFTREE )  {
    cout << "Warning, variable READPDFTREE set to false! Cannot proceed or something can be screwed! Program will most likely crash now.." << endl;
    fPdfToyFile = NULL;
  } else {
    cout << "OPENING PDFTOYFILE " << fname.Data() << endl;
    fPdfToyFile = new TFile(fname,"READ");
  }
}

RooDataSet* VirClass::RetrieveDataset(Int_t mesIdx) {
  RooDataSet *dset = NULL; 

  fPdfToyFile->cd();
  dset = (RooDataSet*)fPdfToyFile->Get(Form("dataset_%d",mesIdx));
  
  /*TKey* key;
  

  TIter nextkey(fPdfToyFile->GetListOfKeys());
  while ( (key = (TKey*)nextkey()) ) {
    TObject *obj = key->ReadObj();

    if( strcmp((obj->IsA())->GetName(),"RooDataSet") == 0 ) 
      if( strcmp( obj->GetName(), Form("dataset_%d",mesIdx) ) == 0 ) {
	cout << "Found Dataset " << obj->GetName() << " matching mesIdx " << mesIdx << endl;
	dset = (RooDataSet*)obj;
	break;
      }  
  }
  
  if( dset == NULL ) {
    cout << mesIdx << " mes fit not found in file " << fPdfToyFile->GetName() << "! Returning an empty Dataset " << endl;
    dset = new RooDataSet();
  }
  
  cout << "returning dset " << dset->GetName() << " " << dset->GetTitle() << endl;
  */

  fHistFile->cd();
  return dset;
}


void VirClass::ApplyCrossFeedCalculations(const TString& dset, const TString& cut, const TVector2& chgreco, const TVector2& neureco, TVector2& res){

  cout << " Applying crossFeedCalculations to " << dset.Data() << " with cut " << cut.Data() << endl;

  const Int_t SIZE = 2;
  Int_t count = 0;
  Double_t measarray[SIZE];
  bool isMC = (dset.CompareTo("DATA") == 0) ? false : true;

  measarray[0] = neureco.X();
  measarray[1] = chgreco.X();
 
  for(UInt_t i = 0; i < cfdump.size(); i++)
    if( cfdump[i]->nm.CompareTo(dset) == 0 && cut.CompareTo(cfdump[i]->ct) == 0 )
      {	count = i; break;  }

  //handle special DATA case
  if ( dset.CompareTo("DATA") == 0)
    count = cut.CompareTo("lepYes == 1") == 0 ? 0 : 1;
    
  cout << "found in " << count << cfdump[count]->nm << endl;
  
  TMatrixD meas = TMatrixD(SIZE,1);
  meas.SetMatrixArray(measarray);
  
  TMatrixDRow mm0(meas,0);
  TMatrixDRow mm1(meas,1);
  
  TMatrixDRow pp0(cfdump[count]->probinv,0);
  TMatrixDRow pp1(cfdump[count]->probinv,1);
  
  cout <<" retrieving Matrix " << pp0[0] << " " << pp0[1] << endl;
  cout <<" retrieving Matrix " << pp1[0] << " " << pp1[1] << endl;

  cout <<" Measured quantities for " << dset.Data() << " with cut " << cut.Data() << " vector " << mm0[0] << " +- " << neureco.Y() << endl;
  cout <<" Measured quantities for " << dset.Data() << " with cut " << cut.Data() << " vector " << mm1[0] << " +- " << chgreco.Y() << endl;

  TMatrixD c = cfdump[count]->probinv * meas;
  TMatrixDRow neu(c,0);
  TMatrixDRow chg(c,1);

  double tmp = BTYPE == 0 ? neu[0] : chg[0];

  double errtmp = CFerrorProp(isMC,BTYPE,cfdump[count]->gnn,cfdump[count]->sigmagnn,cfdump[count]->gn,cfdump[count]->sigmagn,measarray[0],neureco.Y(),
			      cfdump[count]->gcc,cfdump[count]->sigmagcc,cfdump[count]->gc,cfdump[count]->sigmagc,measarray[1],chgreco.Y(),
			      cfdump[count]->meastotneu,cfdump[count]->meastotcha);
  
  errtmp = TMath::IsNaN(errtmp) ? 0 : errtmp;
  tmp = TMath::IsNaN(tmp) ? 0 : tmp;

  res.Set(tmp,errtmp);
			
  cout << "At the end returning " << res.X() << " +- " << res.Y() << endl;

}
/*
void VirClass::ApplyCrossFeedCalculations(const TString& dset, const TString& cut, TH1D* histoch, TH1D* histoneu){
  
  cout << " Applying crossFeedCalculations HISTOGRAMES !!! to  " << dset.Data() << " with cut " << cut.Data() << endl;

  Int_t count = 0;
  const Int_t SIZE = 2;
  Double_t measarray[SIZE], errmeasarray[SIZE];
  double tmp;
  TH1D *htemp, *hdel;
  bool isMC = (dset.CompareTo("DATA") == 0) ? false : true;

  for(UInt_t i = 0; i < cfdump.size(); i++)
    if( cfdump[i]->nm.CompareTo(dset) == 0 && cut.CompareTo(cfdump[i]->ct) == 0 )
      {	count = i; break;  }

  //handle special DATA case
  if ( dset.CompareTo("DATA") == 0)
    count = cut.CompareTo("lepYes == 1") == 0 ? 0 : 1;
  
  cout << "found in " << count << cfdump[count]->nm << endl;
  
  if(histoneu->GetNbinsX() != histoch->GetNbinsX()) {
    cout <<  "!!!!!!! !!!!! THIS IS FATAL ERROR: neutral and charged histo with different binnings !!! " << endl;
    return;
  }
    
  htemp = BTYPE == 0 ? histoneu : histoch;
  hdel  = BTYPE == 0 ? histoch : histoneu;

  for(Int_t i = 1; i < histoneu->GetNbinsX()+1; i++) {
   
    measarray[0] = histoneu->GetBinContent(i);
    measarray[1] = histoch->GetBinContent(i);
    
    errmeasarray[0] = histoneu->GetBinError(i);
    errmeasarray[1] = histoch->GetBinError(i);

    TMatrixD meas = TMatrixD(SIZE,1);
    meas.SetMatrixArray(measarray);
    
    TMatrixD c = cfdump[count]->probinv * meas;

    TMatrixDRow pp0(cfdump[count]->probinv,0);
    TMatrixDRow pp1(cfdump[count]->probinv,1);


    TMatrixDRow neu(c,0);
    TMatrixDRow chg(c,1);

    cout <<" retrieving Matrix " << pp0[0] << " " << pp0[1] << endl;
    cout <<" retrieving Matrix " << pp1[0] << " " << pp1[1] << endl;

    cout <<" Measured quantities for " << dset.Data() << " with cut " << cut.Data() << " neutral " << measarray[0] << " +- " << errmeasarray[0] << endl;
    cout <<" Measured quantities for " << dset.Data() << " with cut " << cut.Data() << " charged " << measarray[1] << " +- " << errmeasarray[1] << endl;

    tmp = BTYPE == 0 ? neu[0] : chg[0];
    
    htemp->SetBinContent(i,tmp);

    double errtmp = CFerrorProp(isMC,BTYPE,cfdump[count]->gnn,cfdump[count]->sigmagnn,cfdump[count]->gn,cfdump[count]->sigmagn,measarray[0],errmeasarray[0],
				cfdump[count]->gcc,cfdump[count]->sigmagcc,cfdump[count]->gc,cfdump[count]->sigmagc,measarray[1],errmeasarray[1]);
  
    errtmp = TMath::IsNaN(errtmp) ? 0 : errtmp;
  
    htemp->SetBinError(i,errtmp);
				     
  }
  
  //This clears the unused histogram

  hdel->Reset();
}
*/
// ###################

void VirClass::ApplyCrossFeedCalculations(const TString& dset, const TString& cut, TH1* histoch, TH1* histoneu){

  cout << " Applying crossFeedCalculations HISTOGRAMES 2D !!! to  " << dset.Data() << " with cut " << cut.Data() << endl;

  Int_t count = 0;
  const Int_t SIZE = 2;
  Double_t measarray[SIZE], errmeasarray[SIZE];
  double tmp;
  TH1 *htemp, *hdel;
  bool isMC = (dset.CompareTo("DATA") == 0) ? false : true;

  for(UInt_t i = 0; i < cfdump.size(); i++)
    if( cfdump[i]->nm.CompareTo(dset) == 0 && cut.CompareTo(cfdump[i]->ct) == 0 )
      {	count = i; break;  }

  //handle special DATA case
  if ( dset.CompareTo("DATA") == 0)
    count = cut.CompareTo("lepYes == 1") == 0 ? 0 : 1;
  
  cout << "found in " << count << cfdump[count]->nm << endl;
  
  if(histoneu->GetNbinsX() != histoch->GetNbinsX() || histoneu->GetNbinsY() != histoch->GetNbinsY()) {
    cout <<  "!!!!!!! !!!!! THIS IS FATAL ERROR: neutral and charged histo with different binnings !!! " << endl;
    return;
  }
    
  htemp = BTYPE == 0 ? histoneu : histoch;
  hdel  = BTYPE == 0 ? histoch : histoneu;

  for(Int_t i = 1; i < histoneu->GetNbinsX()+1; i++) 
    for(Int_t j = 1; j < histoneu->GetNbinsY()+1; j++){
   
    measarray[0] = histoneu->GetBinContent(i,j);
    measarray[1] = histoch->GetBinContent(i,j);
    
    errmeasarray[0] = histoneu->GetBinError(i,j);
    errmeasarray[1] = histoch->GetBinError(i,j);

    TMatrixD meas = TMatrixD(SIZE,1);
    meas.SetMatrixArray(measarray);
    
    TMatrixD c = cfdump[count]->probinv * meas;

    TMatrixDRow pp0(cfdump[count]->probinv,0);
    TMatrixDRow pp1(cfdump[count]->probinv,1);


    TMatrixDRow neu(c,0);
    TMatrixDRow chg(c,1);

    cout <<" retrieving Matrix " << pp0[0] << " " << pp0[1] << endl;
    cout <<" retrieving Matrix " << pp1[0] << " " << pp1[1] << endl;

    cout <<" Histogrames: Measured quantities for bin x (mx) " << i << " bin y (q2) " << j << " " << dset.Data() << " with cut " << cut.Data() << " neutral " << measarray[0] << " +- " << errmeasarray[0] << endl;
    cout <<" Histogrames: Measured quantities for bin x (mx) " << i << " bin y (q2) " << j << " " << dset.Data() << " with cut " << cut.Data() << " charged " << measarray[1] << " +- " << errmeasarray[1] << endl;

    tmp = BTYPE == 0 ? neu[0] : chg[0];
    
    htemp->SetBinContent(i,j,tmp);

    double errtmp = CFerrorProp(isMC,BTYPE,cfdump[count]->gnn,cfdump[count]->sigmagnn,cfdump[count]->gn,cfdump[count]->sigmagn,measarray[0],errmeasarray[0],
				cfdump[count]->gcc,cfdump[count]->sigmagcc,cfdump[count]->gc,cfdump[count]->sigmagc,measarray[1],errmeasarray[1],
				cfdump[count]->meastotneu,cfdump[count]->meastotcha);
  
    errtmp = TMath::IsNaN(errtmp) ? 0 : errtmp;
  
    htemp->SetBinError(i,j,errtmp);
				     
    }
  
  //This clears the unused histogram
  
  hdel->Reset();

}


// ###################

CFUtil::CFUtil() : rds(NULL), mesinitpar(NULL) {}

CFUtil::CFUtil(RooDataSet *r, vector<double>& par){
  rds = r;
  mesinitpar = &par;
}

CFUtil::~CFUtil() {}

void CFUtil::SetMesInitPar(vector<double>& par){
  mesinitpar = &par;
}

RooDataSet* CFUtil::GetDataset() const {
  return rds;
}

vector<double> CFUtil::GetMesParams() const {
  return *mesinitpar;
}

// #####################

CFDump::CFDump() {
  nm = TString("");
  ct = TString("");
  probinv = TMatrixD();
  gnn = 0;
  sigmagnn = 0;
  gn = 0;
  sigmagn = 0;
  gcc = 0;
  sigmagcc = 0;
  gc = 0;
  sigmagc = 0;
  meastotneu = 0;
  meastotcha = 0;
}

CFDump::CFDump(const TString& name, const TString& cut, const TMatrixD& prob, Double_t Gnn, Double_t SigmaGnn, Double_t Gn, Double_t SigmaGn, 
	       Double_t Gcc, Double_t SigmaGcc, Double_t Gc, Double_t SigmaGc, Double_t Mnt, Double_t Mct) : nm(TString(name)), ct(TString(cut)), probinv(TMatrixD(prob)), 
													     gnn(Gnn),  sigmagnn(SigmaGnn), gn(Gn), sigmagn(SigmaGn),gcc(Gcc),
													     sigmagcc(SigmaGcc), gc(Gc), sigmagc(SigmaGc), meastotneu(Mnt),
													     meastotcha(Mct) {}



CFDump::~CFDump() {}


  

  
